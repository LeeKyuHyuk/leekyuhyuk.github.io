{"pageProps":{"excerpt":" 이전 글 에서 CMD0 , CMD8 그리고 CMD58 을 사용하는 방법을 소개했습니다. 이제 SDCard의 초기화 과정을 거의 완료했습니다. 아래 다이어그램을 보면 다음 단계는 ACMD41 라는 것을 알 수 있습니다. ACMD41 (SD_SEND_OP_COND) ACMD41 (Send","url":"/article/avr/2022/09/02/AVR-ATmega328P-SDCard-3","frontmatter":{"title":"[AVR] ATmega328P SDCard 구현 (3)","date":"2022-09-02 23:57:51","category":"AVR"},"content":"\n[이전 글](https://kyuhyuk.kr/article/avr/2022/09/01/AVR-ATmega328P-SDCard-2)에서 `CMD0`, `CMD8` 그리고 `CMD58`을 사용하는 방법을 소개했습니다. 이제 SDCard의 초기화 과정을 거의 완료했습니다. 아래 다이어그램을 보면 다음 단계는 `ACMD41`라는 것을 알 수 있습니다.\n\n![SDCard SPI Mode Initalization Flow](/assets/image/2022-08-28-AVR-ATmega328P-SDCard-1/AVR-ATmega328P-SDCard-1_5.png)\n\n# `ACMD41` (SD_SEND_OP_COND)\n\n`ACMD41`(Send Operating Condition)는 SDCard의 초기화 과정을 시작합니다. 여기서 주의해야 하는 점은 `ACMD41`과 같이 `A`로 시작하는 Command는 사용하기 전에 `CMD55`(APP_CMD)를 보내서 다음에 사용하려는 Command이 `ACMD`라는 것을 SDCard에게 알려야 합니다.\n\n다음은 `CMD55`의 형식입니다:\n\n![CMD55 Format](/assets/image/2022-09-02-AVR-ATmega328P-SDCard-3/AVR-ATmega328P-SDCard-3_1.png)\n\n`ACMD41`의 형식은 아래와 같습니다:\n\n![ACMD41 Format](/assets/image/2022-09-02-AVR-ATmega328P-SDCard-3/AVR-ATmega328P-SDCard-3_2.png)\n\n`ACMD41`의 대부분 비트는 Reserved이지만, 고용량 카드를 지원함을 나타내기 위해 Bit 30을 1로 설정하는 부분이 있습니다. CRC는 이러한 명령에 대해 무시되므로 아무거나 설정할 수 있습니다.\n\n```c\n#define CMD55       55\n#define CMD55_ARG   0x00000000\n#define CMD55_CRC   0x00\n\n#define ACMD41      41\n#define ACMD41_ARG  0x40000000\n#define ACMD41_CRC  0x00\n```\n\n`ACMD41`은 `CMD41`과 마찬가지로 Command Index를 `41`을 사용합니다. `CMD55`가 먼저 전송되지 않는 경우에는 `CMD41`가 전송됩니다.\n\n`CMD55`와 `ACMD41`은 `R1`의 Response를 반환합니다.\n\n```c\nuint8_t sdSendApp()\n{\n    // SDCard CS Assert\n    spiTransfer(0xFF);\n    CS_ENABLE();\n    spiTransfer(0xFF);\n\n    // CMD55 전송\n    sdCommand(CMD55, CMD55_ARG, CMD55_CRC);\n\n    // Response를 읽습니다\n    uint8_t r1 = sdReadRes1();\n\n    // SDCard CS Deassert\n    spiTransfer(0xFF);\n    CS_DISABLE();\n    spiTransfer(0xFF);\n\n    return r1;\n}\n\nuint8_t sdSendOpCond()\n{\n    // SDCard CS Assert\n    spiTransfer(0xFF);\n    CS_ENABLE();\n    spiTransfer(0xFF);\n\n    // ACMD41 전송\n    sdCommand(ACMD41, ACMD41_ARG, ACMD41_CRC);\n\n    // Response를 읽습니다\n    uint8_t r1 = sdReadRes1();\n\n    // SDCard CS Deassert\n    spiTransfer(0xFF);\n    CS_DISABLE();\n    spiTransfer(0xFF);\n\n    return r1;\n}\n```\n\n위에서 설명했듯이 `ACMD41`은 초기화 과정을 시작합니다. Startup Sequence에서 SDCard가 `R1 = 0x00`인 'in_idle_state'로 응답할 때까지 `ACMD41`(항상 `CMD55`를 먼저 보내고 실행)을 계속 보냅니다.\n\n`R1 = 0x00`을 받으면 CCS 값을 보기 위해 `CMD58`을 보내야 합니다. CCS를 통해 SDCard가 SDHC(고용량 SDCard)인지 SCXC(확장 용량 SDCard)인지 알 수 있습니다.\n\n[이전 글](https://kyuhyuk.kr/article/avr/2022/09/01/AVR-ATmega328P-SDCard-2)에서 작성한 `main()`을 아래와 같이 수정합니다.\n\n```c\n/*\n  CPU의 Frequency를 16MHz로 설정합니다\n*/\n#define F_CPU 16000000UL\n#include <util/delay.h>\n\nint main(void)\n{\n  uint8_t res[5];\n  char c;\n\n  // UART를 초기화 합니다\n  const unsigned int baudRate = (F_CPU / 16 / 9600) - 1;\n  uartInit(baudRate);\n\n  // SPI를 초기화 합니다\n  spiInit();\n\n  // SDCard에 VCC가 충분히 공급될때까지 기다립니다\n  _delay_ms(10);\n\n  // Power Up Sequence를 시작합니다\n  sdPowerUpSeq();\n\n  while (1)\n  {\n    // 메뉴를 출력합니다\n    uartPuts(\"MENU\\r\\n\");\n    uartPuts(\"------------------\\r\\n\");\n    uartPuts(\"0 - Send CMD0\\r\\n1 - Send CMD8\\r\\n2 - Send CMD58\\r\\n\");\n    uartPuts(\"3 - Send CMD55\\r\\n4 - Send ACMD41\\r\\n\");\n    uartPuts(\"------------------\\r\\n\");\n\n    // 사용자에게 명령(문자)를 입력받습니다\n    c = uartGet();\n\n    if (c == '0')\n    {\n      // CMD0을 보내고 응답을 읽고 출력합니다\n      uartPuts(\"Sending CMD0...\\r\\n\");\n      res[0] = sdGoIdleState();\n      uartPuts(\"Response:\\r\\n\");\n      sdPrintR1(res[0]);\n    }\n    else if (c == '1')\n    {\n      // CMD8을 보내고 응답을 읽고 출력합니다\n      uartPuts(\"Sending CMD8...\\r\\n\");\n      sdSendIfCond(res);\n      uartPuts(\"Response:\\r\\n\");\n      sdPrintR7(res);\n    }\n    else if (c == '2')\n    {\n      // CMD58을 보내고 응답을 읽고 출력합니다\n      uartPuts(\"Sending CMD58...\\r\\n\");\n      sdReadOcr(res);\n      uartPuts(\"Response:\\r\\n\");\n      sdPrintR3(res);\n    }\n    else if (c == '3')\n    {\n      // CMD55를 보내고 응답을 읽고 출력합니다\n      uartPuts(\"Sending CMD55...\\r\\n\");\n      res[0] = sdSendApp();\n      uartPuts(\"Response:\\r\\n\");\n      sdPrintR1(res[0]);\n    }\n    else if (c == '4')\n    {\n      // ACMD41을 보내고 응답을 읽고 출력합니다\n      uartPuts(\"Sending ACMD41...\\r\\n\");\n      res[0] = sdSendOpCond();\n      uartPuts(\"Response:\\r\\n\");\n      sdPrintR1(res[0]);\n    }\n    else\n    {\n      uartPuts(\"Unrecognized command\\r\\n\");\n    }\n  }\n}\n```\n\n`CMD0`을 보낸 다음 `CMD8`과 `CMD58`을 보냅니다. SDCard가 Ready 되었다고 출력될 때까지 `CMD55`와 `ACMD41`을 차례대로 보냅니다.  \n![CLI 1](/assets/image/2022-09-02-AVR-ATmega328P-SDCard-3/AVR-ATmega328P-SDCard-3_3.png)\n\nSDCard가 Ready가 되었다면, CCS를 얻기 위해 마지막에 `CMD58`을 보냅니다.  \n![CLI 2](/assets/image/2022-09-02-AVR-ATmega328P-SDCard-3/AVR-ATmega328P-SDCard-3_4.png)\n\n`ACMD41`을 처음 보낼 때는 IDLE 상태로 출력되었지만, 두 번째에는 Ready 상태임을 확인할 수 있습니다. 그 이후에 `CMD58`을 사용해서 OCR을 읽을 때 SDCard가 Power Up Process를 완료했으므로 CCS 비트가 유효하다고 볼 수 있습니다. 위의 경우에는 `1`로 설정되어 있는데, 이것은 SDXC 또는 SDHD를 사용하고 있음을 의미합니다.\n\n# SDCard 초기화\n\n이제 SDCard를 초기화하는 `sdInit()`을 구현해 보겠습니다. SDCard 초기화를 구현하기 위해서 Power Up Diagram을 다시 봐봅시다:\n\n![Power-up Diagram](/assets/image/2022-08-28-AVR-ATmega328P-SDCard-1/AVR-ATmega328P-SDCard-1_3.png)\n\n위의 다이어그램을 보면, `ACMD41`의 타임아웃은 1초입니다. 최소 1초 동안 SDCard 초기화를 계속 시도해야 합니다. 우리는 `ACMD41`을 다시 시도할 때 10ms의 Delay를 설정하고, 최대 100번을 시도하도록 구현할 것입니다.\n\n```c\n#define SD_READY    0\n#define SD_SUCCESS  0\n#define SD_ERROR    1\n\nuint8_t sdInit()\n{\n    uint8_t res[5], cmdAttempts = 0;\n\n    sdPowerUpSeq();\n\n    /*\n      CMD0을 보내서 SDCard를 IDLE로 만듭니다\n      최대 10번 Retry 합니다\n    */\n    while((res[0] = sdGoIdleState()) != 0x01)\n    {\n        cmdAttempts++;\n        if(cmdAttempts > 10) return SD_ERROR;\n    }\n\n    // CMD8을 보냅니다\n    sdSendIfCond(res);\n    if(res[0] != 0x01)\n    {\n        return SD_ERROR;\n    }\n\n    // Echo Pattern을 확인합니다\n    if(res[4] != 0xAA)\n    {\n        return SD_ERROR;\n    }\n\n    // ACMD41을 통해 SDCard 초기화를 시도합니다\n    cmdAttempts = 0;\n    do\n    {\n        if(cmdAttempts > 100) return SD_ERROR;\n\n        // ACMD41을 보내기전에 CMD55를 보냅니다\n        res[0] = sdSendApp();\n\n        // Response에 Error가 없다면 ACMD41을 보냅니다\n        if(res[0] < 2)\n        {\n            res[0] = sdSendOpCond();\n        }\n\n        // 10ms동안 기다립니다\n        _delay_ms(10);\n\n        cmdAttempts++;\n    }\n    while(res[0] != SD_READY);\n\n    // OCR을 읽습니다\n    sdReadOcr(res);\n\n    // SDCard가 Ready 상태인지 확인합니다\n    if(!(res[1] & 0x80)) return SD_ERROR;\n\n    return SD_SUCCESS;\n}\n```\n\n여기까지 모두 진행했다면 SPI 모드에서 SDCard를 초기화하는 것을 성공한 것입니다!\n"},"__N_SSG":true}