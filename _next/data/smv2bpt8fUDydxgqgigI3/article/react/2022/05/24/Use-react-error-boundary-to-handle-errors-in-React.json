{"pageProps":{"excerpt":" 이 글은 Use react-error-boundary to handle errors in React 를 번역했습니다. 아래 코드에는 어떤 문제가 있을까요? import ReactDOM from \"react-dom/client\"; function Greeting({ subject }) ","url":"/article/react/2022/05/24/Use-react-error-boundary-to-handle-errors-in-React","frontmatter":{"title":"react-error-boundary를 사용하여 오류 처리하기","date":"2022-05-24 02:46:33","category":"React"},"content":"\r\n> 이 글은 [Use react-error-boundary to handle errors in React](https://kentcdodds.com/blog/use-react-error-boundary-to-handle-errors-in-react)를 번역했습니다.\r\n\r\n아래 코드에는 어떤 문제가 있을까요?\r\n\r\n```jsx\r\nimport ReactDOM from \"react-dom/client\";\r\n\r\nfunction Greeting({ subject }) {\r\n  return <div>Hello {subject.toUpperCase()}</div>;\r\n}\r\n\r\nfunction Farewell({ subject }) {\r\n  return <div>Goodbye {subject.toUpperCase()}</div>;\r\n}\r\n\r\nfunction App() {\r\n  return (\r\n    <div>\r\n      <Greeting />\r\n      <Farewell />\r\n    </div>\r\n  );\r\n}\r\n\r\nconst root = ReactDOM.createRoot(\r\n  document.getElementById(\"root\") as HTMLElement\r\n);\r\nroot.render(<App />);\r\n```\r\n\r\n만약 위의 코드를 배포하게 되면, 사용자는 하얀 화면을 보게 될것입니다.  \r\n그리고 콘솔창에 오류가 출력될 것입니다.  \r\n![Error](/assets/image/2022-05-24-Use-react-error-boundary-to-handle-errors-in-React/2022-05-24-Use-react-error-boundary-to-handle-errors-in-React_1.png)\r\n\r\n위 코드의 문제는 `subject` Prop를 문자열로 전달하거나 기본값을 설정해야 했습니다. 분명히 이것은 일부러 발생시킨 오류이지만, 런타임 오류는 항상 발생하므로 이러한 오류들을 정상적으로 처리하는 것이 좋습니다.  \r\n우선 이 오류를 그대로 두고 이와 같은 런타임 오류를 처리하기 위해 React가 어떤 해결 방법을 가지고 있는지 살펴봅시다.\r\n\r\n# try/catch?\r\n\r\n이러한 오류를 처리하는 가장 쉬운 접근 방법은 `try`/`catch`를 추가하는 것 입니다.\r\n\r\n```jsx\r\nimport ReactDOM from \"react-dom/client\";\r\n\r\nfunction ErrorFallback({ error }) {\r\n  return (\r\n    <div role=\"alert\">\r\n      <p>Something went wrong:</p>\r\n      <pre style={{ color: \"red\" }}>{error.message}</pre>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction Greeting({ subject }) {\r\n  try {\r\n    return <div>Hello {subject.toUpperCase()}</div>;\r\n  } catch (error) {\r\n    return <ErrorFallback error={error} />;\r\n  }\r\n}\r\n\r\nfunction Farewell({ subject }) {\r\n  try {\r\n    return <div>Goodbye {subject.toUpperCase()}</div>;\r\n  } catch (error) {\r\n    return <ErrorFallback error={error} />;\r\n  }\r\n}\r\n\r\nfunction App() {\r\n  return (\r\n    <div>\r\n      <Greeting />\r\n      <Farewell />\r\n    </div>\r\n  );\r\n}\r\n\r\nconst root = ReactDOM.createRoot(\r\n  document.getElementById(\"root\") as HTMLElement\r\n);\r\nroot.render(<App />);\r\n```\r\n\r\n이 방법은 **'작동합니다'**!\r\n\r\n![try/catch](/assets/image/2022-05-24-Use-react-error-boundary-to-handle-errors-in-React/2022-05-24-Use-react-error-boundary-to-handle-errors-in-React_2.png)\r\n\r\n모든 컴포넌트를 `try/catch` 블록으로 감싸고 싶지 않다면 어떻게 해야할까요? JavaScript에서는 단순히 호출 함수를 `try/catch`로 감쌀 수 있으며, 호출하는 함수에서 오류를 포착합니다. 아래와 같이 수정해보겠습니다.\r\n\r\n```jsx\r\nimport ReactDOM from 'react-dom/client';\r\n\r\nfunction ErrorFallback({ error }) {\r\n  return (\r\n    <div role=\"alert\">\r\n      <p>Something went wrong:</p>\r\n      <pre style={{ color: 'red' }}>{error.message}</pre>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction Greeting({ subject }) {\r\n  return <div>Hello {subject.toUpperCase()}</div>;\r\n}\r\n\r\nfunction Farewell({ subject }) {\r\n  return <div>Goodbye {subject.toUpperCase()}</div>;\r\n}\r\n\r\nfunction App() {\r\n  try {\r\n    return (\r\n      <div>\r\n        <Greeting />\r\n        <Farewell />\r\n      </div>\r\n    );\r\n  } catch (error) {\r\n    return <ErrorFallback error={error} />;\r\n  }\r\n}\r\n\r\nconst root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement);\r\nroot.render(<App />);\r\n```\r\n\r\n아쉽게도 이 방법은 작동하지 않습니다. 그 이유는 `Greeting`과 `Farewell`를 호출하는 것이 아니기 때문입니다.\r\n\r\n# React Error Boundary\r\n\r\n\"[Error Boundary](https://reactjs.org/docs/error-boundaries.html)\"는 위와 같은 런타임 오류를 처리하기 위해 작성하는 특수한 컴포넌트 입니다.  \r\n컴포넌트가 Error Boundary가 되려면,\r\n\r\n1. 클래스 컴포넌트 이어야 합니다🙁\r\n2. `getDerivedStateFromError` 또는 `componentDidCatch`를 구현해야 합니다.\r\n\r\n다행이게도, 우리에게는 [react-error-boundary](https://www.npmjs.com/package/react-error-boundary)가 있습니다. 이 라이브러리는 React Application에서 런타임 오류를 선언적으로 처리할 수 있도록 도와줍니다.\r\n\r\n[react-error-boundary](https://www.npmjs.com/package/react-error-boundary)를 프로젝트에 추가하고, `ErrorBoundary` 컴포넌트를 렌더링 해보겠습니다.\r\n\r\n```jsx\r\nimport ReactDOM from \"react-dom/client\";\r\nimport { ErrorBoundary } from \"react-error-boundary\";\r\n\r\nfunction ErrorFallback({ error }) {\r\n  return (\r\n    <div role=\"alert\">\r\n      <p>Something went wrong:</p>\r\n      <pre style={{ color: \"red\" }}>{error.message}</pre>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction Greeting({ subject }) {\r\n  return <div>Hello {subject.toUpperCase()}</div>;\r\n}\r\n\r\nfunction Farewell({ subject }) {\r\n  return <div>Goodbye {subject.toUpperCase()}</div>;\r\n}\r\n\r\nfunction App() {\r\n  return (\r\n    <div>\r\n      <ErrorBoundary FallbackComponent={ErrorFallback}>\r\n        <Greeting />\r\n        <Farewell />\r\n      </ErrorBoundary>\r\n    </div>\r\n  );\r\n}\r\n\r\nconst root = ReactDOM.createRoot(\r\n  document.getElementById(\"root\") as HTMLElement\r\n);\r\nroot.render(<App />);\r\n```\r\n\r\n이 방법은 완벽하게 작동합니다!\r\n\r\n![react-error-boundary](/assets/image/2022-05-24-Use-react-error-boundary-to-handle-errors-in-React/2022-05-24-Use-react-error-boundary-to-handle-errors-in-React_3.png)\r\n\r\n# Error Recovery\r\n\r\n위의 방법이 좋은 점은 여러분이 `try/catch` 블록을 수행하는 것과 같은 방식으로 `ErrorBoundary` 컴포넌트를 구성할 수 있다는 점입니다. 다양한 오류를 처리하기 위해 React 컴포넌트를 감싸거나 트리의 특정 부분으로 범위를 좁혀 더 세분화된 오류 처리 또는 복구를 수행할 수 있습니다. [react-error-boundary](https://www.npmjs.com/package/react-error-boundary)는 이 모든 것을 제공합니다.\r\n\r\n더 복잡한 예시는 아래와 같습니다:\r\n\r\n```jsx\r\nimport React from \"react\";\r\nimport ReactDOM from \"react-dom/client\";\r\nimport { ErrorBoundary } from \"react-error-boundary\";\r\n\r\nfunction ErrorFallback({ error, resetErrorBoundary }) {\r\n  return (\r\n    <div role=\"alert\">\r\n      <p>Something went wrong:</p>\r\n      <pre style={{ color: \"red\" }}>{error.message}</pre>\r\n      <button onClick={resetErrorBoundary}>Try again</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction Bomb({ username }) {\r\n  if (username === \"bomb\") {\r\n    throw new Error(\"💥 CABOOM 💥\");\r\n  }\r\n  return `Hi ${username}`;\r\n}\r\n\r\nfunction App() {\r\n  const [username, setUsername] = React.useState(\"\");\r\n  const usernameRef = React.useRef(null);\r\n\r\n  return (\r\n    <div>\r\n      <label>\r\n        {`Username (don't type \"bomb\"): `}\r\n        <input\r\n          placeholder={`type \"bomb\"`}\r\n          value={username}\r\n          onChange={(e) => setUsername(e.target.value)}\r\n          ref={usernameRef}\r\n        />\r\n      </label>\r\n      <div>\r\n        <ErrorBoundary\r\n          FallbackComponent={ErrorFallback}\r\n          onReset={() => {\r\n            setUsername(\"\");\r\n            usernameRef.current.focus();\r\n          }}\r\n          resetKeys={[username]}\r\n        >\r\n          <Bomb username={username} />\r\n        </ErrorBoundary>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nconst root = ReactDOM.createRoot(\r\n  document.getElementById(\"root\") as HTMLElement\r\n);\r\nroot.render(<App />);\r\n```\r\n\r\n\"bomb\"를 입력하면, `Bomb` 컴포넌트가 `ErrorFallback` 컴포 넌트로 대체되며 `username`을 변경하거나 \"Try again\" 버튼을 클릭해서 복구할 수 있습니다. `resetErrorBoundary`과 오류를 유발하지 않는 사용자 이름으로 State를 재설정하는 `onReset`이 있습니다.\r\n\r\n![Error Recovery](/assets/image/2022-05-24-Use-react-error-boundary-to-handle-errors-in-React/2022-05-24-Use-react-error-boundary-to-handle-errors-in-React_4.png)\r\n\r\n# Handle all errors\r\n\r\n아쉽게도, React가 Error Boundary에 넘길 수 없거나 전달할 수 없는 몇 가지 Error가 있습니다. [React 문서](https://reactjs.org/docs/error-boundaries.html#introducing-error-boundaries)를 보면 아래와 같습니다:\r\n\r\n> \"Error Boundary는 다음에 대한 오류는 포착하지 않습니다\"\r\n>\r\n> - 이벤트 핸들러 ([자세히 알아보기](https://reactjs.org/docs/error-boundaries.html#how-about-event-handlers))\r\n> - 비동기 코드 (예: `setTimeout` 또는 `requestAnimationFrame` 콜백)\r\n> - 서버 측 렌더링\r\n> - Error Boundary 자체에서 발생한 오류\r\n\r\n대부분의 경우에는 다음과 같이 일부 오류 상태를 관리하고 오류 발생시 다른 것을 렌더링 합니다.\r\n\r\n```jsx\r\nfunction Greeting() {\r\n  const [{ status, greeting, error }, setState] = React.useState({\r\n    status: 'idle',\r\n    greeting: null,\r\n    error: null,\r\n  });\r\n\r\n  function handleSubmit(event) {\r\n    event.preventDefault();\r\n    const name = event.target.elements.name.value;\r\n    setState({ status: 'pending' });\r\n    fetchGreeting(name).then(\r\n      (newGreeting) => setState({ greeting: newGreeting, status: 'resolved' }),\r\n      (newError) => setState({ error: newError, status: 'rejected' })\r\n    );\r\n  }\r\n\r\n  return status === 'rejected' ? (\r\n    <ErrorFallback error={error} />\r\n  ) : status === 'resolved' ? (\r\n    <div>{greeting}</div>\r\n  ) : (\r\n    <form onSubmit={handleSubmit}>\r\n      <label>Name</label>\r\n      <input id=\"name\" />\r\n      <button type=\"submit\" onClick={handleClick}>\r\n        get a greeting\r\n      </button>\r\n    </form>\r\n  );\r\n}\r\n```\r\n\r\n하지만, 위와 같은 방법을 사용하려면 오류를 처리하는 두 가지 방법을 유지해야 합니다.\r\n\r\n1. 런타임 오류\r\n2. `fetchGreeting` 오류\r\n\r\n역시나 다행이게도, [react-error-boundary](https://www.npmjs.com/package/react-error-boundary)는 이러한 상황에도 도움이 되는 간단한 Hook을 제공하고 있습니다. 아래와 같이 사용할 수 있습니다.\r\n\r\n```jsx\r\nfunction Greeting() {\r\n  const [{ status, greeting }, setState] = React.useState({\r\n    status: 'idle',\r\n    greeting: null,\r\n  });\r\n  const handleError = useErrorHandler();\r\n\r\n  function handleSubmit(event) {\r\n    event.preventDefault();\r\n    const name = event.target.elements.name.value;\r\n    setState({ status: 'pending' });\r\n    fetchGreeting(name).then(\r\n      (newGreeting) => setState({ greeting: newGreeting, status: 'resolved' }),\r\n      (error) => handleError(error)\r\n    );\r\n  }\r\n\r\n  return status === 'resolved' ? (\r\n    <div>{greeting}</div>\r\n  ) : (\r\n    <form onSubmit={handleSubmit}>\r\n      <label>Name</label>\r\n      <input id=\"name\" />\r\n      <button type=\"submit\" onClick={handleClick}>\r\n        get a greeting\r\n      </button>\r\n    </form>\r\n  );\r\n}\r\n```\r\n\r\n`fetchGreeting` Promise가 Rejected 되면 `handleError` 함수가 오류와 함께 호출되고, [react-error-boundary](https://www.npmjs.com/package/react-error-boundary)는 가장 가까운 Error Boundary로 전달합니다.\r\n\r\n추가로 `error`의 유무를 제공하는 Hook을 사용하고 있다고 가정해 보겠습니다.\r\n\r\n```jsx\r\nfunction Greeting() {\r\n  const [name, setName] = React.useState('');\r\n  const { status, greeting, error } = useGreeting(name);\r\n  useErrorHandler(error);\r\n\r\n  function handleSubmit(event) {\r\n    event.preventDefault();\r\n    const name = event.target.elements.name.value;\r\n    setName(name);\r\n  }\r\n\r\n  return status === 'resolved' ? (\r\n    <div>{greeting}</div>\r\n  ) : (\r\n    <form onSubmit={handleSubmit}>\r\n      <label>Name</label>\r\n      <input id=\"name\" />\r\n      <button type=\"submit\" onClick={handleClick}>\r\n        get a greeting\r\n      </button>\r\n    </form>\r\n  );\r\n}\r\n```\r\n\r\n이 경우에는 `error`가 `true`가 되면 가장 가까운 Error Boundary로 전달됩니다.\r\n\r\n두 경우 모두 다음과 같은 오류를 처리할 수 있습니다.\r\n\r\n```jsx\r\nconst ui = (\r\n  <ErrorBoundary FallbackComponent={ErrorFallback}>\r\n    <Greeting />\r\n  </ErrorBoundary>\r\n);\r\n```\r\n\r\n이제 런타임 오류와 `fetchGreeting` 또는 `useGreeting` 코드의 비동기 오류를 처리할 수 있습니다.\r\n\r\n만약, [react-error-boundary](https://www.npmjs.com/package/react-error-boundary)를 사용해 보지 않았다면 지금 한번 사용해 보세요! 강력하게 추천드립니다.\r\n"},"__N_SSG":true}