{"pageProps":{"excerpt":" ARM CPU의 기본 구성 R0 ~ R14 총 15개의 범용 레지스터를 가지고 있습니다. 범용 레지스터 R13 는 특수 레지스터 SP 로 사용됩니다. SP 는 C언어 사용시 스택의 주소를 저장하는 레지스터입니다. 범용 레지스터 R14 는 특수 레지스터 LR 로 사용됩니다. LR 은 함","url":"/article/raspberry-pi/2019/05/15/ARM-Assembly","frontmatter":{"title":"ARM Assembly 기초","date":"2019-05-15 20:36:56","category":"Raspberry-Pi"},"content":"\n- ARM CPU의 기본 구성\n\n  - `R0`~`R14` 총 15개의 범용 레지스터를 가지고 있습니다.\n  - 범용 레지스터 `R13`는 특수 레지스터 `SP`로 사용됩니다.\n    - `SP`는 C언어 사용시 스택의 주소를 저장하는 레지스터입니다.\n  - 범용 레지스터 `R14`는 특수 레지스터 `LR`로 사용됩니다.\n    - `LR`은 함수 호출 시 되돌아갈 함수의 주소가 저장되는 레지스터입니다.\n  - 범용 레지스터 `R15`는 특수 레지스터 `PC`로 사용됩니다.\n    - `PC`는 다음 실행할 프로그램의 주소를 가지고 있는 레지스터입니다.\n  - `CPSR`이라는 상태 레지스터를 가지고 있습니다.  \n    ![Operand](/assets/image/2019-05-15-ARM-Assembly/operand.jpg)\n\n  - `Rs`, `Rd`는 반드시 레지스터(`R0`~`R15`)이어야 합니다.\n    - `OP1`은 항상 레지스터 입니다.\n  - **`OP2`는 레지스터 일수도 있고, 레지스터가 아닐수도 있습니다.**\n  - [`Rs`, `Rd`, `OP2`의 대상으로 직접 외부 메모리를 접근할수 없습니다.](#ldr-str-쉽게-이해하는-방법)\n\n---\n\n# Load, Store\n\n## `MOV` 명령\n\n- ARM에서 레지스터의 데이터 이동은 `MOV` 명령을 사용합니다.\n  - 예) `MOV R0, R1` : `R1`의 내용을 `R0`으로 복사\n  - 예) `MOV R0, #1` : 상수 `1`을 `R0`으로 복사\n- 메모리→레지스터 : `LDR` (Load to Register)\n- 레지스터→메모리 : `STR` (Store to Memory)\n\n## 상수 값을 레지스터에 저장\n\n- `LDR` 명령 사용 방법\n  - `LDR Rn, =Value`\n  - **`LDR`을 사용하여 상수의 값을 레지스터에 저장할때 `=Value`에서 `=`를 빼먹지 않게 주의합니다.**\n    - 다른 명령어에서는 상수 입력에 `#`이 들어가지만 `LDR`만 `=`이 들어가니 주의합시다.\n  - 레지스터간 데이터 복사는 `MOV`를 사용합니다.\n  - `Rn` : `R0` ~ `R15` (대소문자 구분 없음)\n  - `=Value` : 상수 값 (최대 4바이트)\n    - 10진수 :\n      - **예)** `41`, `-27`\n    - 16진수 :\n      - **예)** `0x1234`, `-0x1EF`\n    - 예) `LDR R0, =100`, `LDR R13, =0x1234`\n\n## 상수 표현\n\n- `OP2`의 상수는 8비트의 값고 짝수 비트 ROR(Rotate Right)로 표현되어야 합니다.\n  - 32비트 명령 안에서 상수 값을 함께 저장하다보니 범위 제한이 발생하기 때문입니다.\n  - `0`~`255` 범위의 상수는 무조건 사용이 가능합니다.\n\n## 사용된 상수가 `MOV` 명령에서 사용 가능한지 불가능한지 판단해보자\n\n- `MOV R0, #0x7F00` : **가능** ![Example 1](/assets/image/2019-05-15-ARM-Assembly/example1.png)\n\n- `MOV R0, #0x30C0` : **가능** ![Example 2](/assets/image/2019-05-15-ARM-Assembly/example2.png)\n\n- `MOV R3, #0x14E` : **불가능** ![Example 3](/assets/image/2019-05-15-ARM-Assembly/example3.png)\n\n- `LDR`을 사용하면, **범위 제한 없는 32비트 값으로 표현 가능**\n  - 실제 상수 값은 메모리에 존재하며 레지스터 참조로 변환됩니다.\n\n> `MOV`보다 `LDR`이 느리지만, `LDR`은 32비트 데이터를 사용할 수 있습니다.\n\n## 레지스터 간접참조 `LDR`, `STR`\n\n- 레지스터 간접 참조 :\n  - `LDR Rd, [Rs]`\n    - `Rs` 레지스터 값을 메모리 주소로 하여 `Rd`에 저장\n    - `Rs`, `Rd` : `R0` ~ `R15`\n  - `STR Rs, [Rd]`\n    - `Rd` 레지스터 값을 메모리 주소로 하여 `Rs`를 저장\n    - `Rs`, `Rd` : `R0` ~ `R15`\n\n### 예)\n\n```assembly\n  LDR R0, =0x1000   @ R0에 상수 0x1000 저장\n  LDR R1, =80       @ R1에 상수 80 저장\n  STR R1, [R0]      @ R0의 값인 0x1000를 메모리 주소로 참조하여\n                    @ 0x1000에 상수 80을 저장\n```\n\n## `LDR`, `STR` 쉽게 이해하는 방법\n\n![LDR, STR 쉽게 이해하는 방법](/assets/image/2019-05-15-ARM-Assembly/ldr_str_tip.png)\n\n## Label\n\n```assembly\nSTART:  MOV R0, #10       @ R0 레지스터에 상수 10을 저장\n        STR R0, [R1]      @ R1에 저장되어 있는 주소에 R0 값을 저장\n        LDR PC, =START    @ START의 주소를 PC(Program counter)에 저장\n```\n\n- Label은 모두 주소 값(해당 Label 위치의 주소)입니다.\n- 위의 코드는 `START`의 주소 값을 PC(Program counter)에 저장하여 무한 루프를 하게 됩니다.\n\n# `LDR`, `STR` Post Indexing\n\n## Post Indexing 사용 방법:\n\n```assembly\n  LDR R0, [R1], #4            @ R1 주소에 있는 값을 R0에 넣고, R1에 4를 더합니다.\n  STR R0, [R2], #-4           @ R0의 값을 R2의 주소에 넣고, R2에 4를 뺍니다.\n```\n\n```assembly\n  LDR R0, [R1], R3            @ R1 주소에 있는 값을 R0에 넣고, R1에 R3의 값을 더합니다.\n  STR R0, [R2], -R3           @ R0의 값을 R2의 주소에 넣고, R2에 R3의 값을 뺍니다.\n```\n\n```assembly\n  LDR R0, [R1], R3, LSL #2    @ R1 주소에 있는 값을 R0에 넣고,\n                              @ R1에 R3, LSL #2한 값을 더합니다.\n  STR R0, [R2], -R3, ASR #2   @ R2 주소에 있는 값을 R0에 넣고,\n                              @ R2에 R3, ASR #2한 값을 뺍니다.\n```\n\n### 예)\n\n```assembly\n  LDR R1, 0x1000              @ R1에 상수 0x1000을 넣습니다.\n                              @ R1 : 0x1000\n\n  LDR R0, [R1], #4            @ R0에 0x1000를 참조한 값(R1의 메모리 참조주소)을 넣고,\n                              @ R1에 4를 더합니다.\n                              @ R1 : 0x1004\n\n  LDR R2, [R1], #4            @ R2에 0x1004를 참조한 값(R1의 메모리 참조주소)을 넣고,\n                              @ R1에 4를 더합니다.\n                              @ R1 : 0x1008\n```\n\n# `LDR`, `STR` Pre Indexing\n\n## Pre Indexing 사용 방법:\n\n```assembly\n  LDR R0, [R1], #4            @ R1에 4를 더한것을 참조하여 R0에 넣습니다.\n  STR R0, [R2], #-4           @ R0의 값을 R2에 4를 뺀 주소에 넣습니다.\n```\n\n```assembly\n  LDR R0, [R1], R3            @ R1에 R3의 값을 더한것을 참조하여 R0에 넣습니다.\n  STR R0, [R2], -R3           @ R0의 값을 R2에 R3의 값을 뺀 주소에 넣습니다.\n```\n\n```assembly\n  LDR R0, [R1], R3, LSL #2    @ R1에 R3, LSL #2한 값을 더한뒤,\n                              @ 주소에 있는 값을 R0에 넣습니다.\n  STR R0, [R2], -R3, ASR #2   @ R2에 R3, ASR #2한 값을 뺀뒤,\n                              @ R0의 값을 변경된 주소로 넣습니다.\n```\n\n### 예)\n\n```assembly\n  LDR R1, 0x1000              @ R1에 상수 0x1000을 넣습니다.\n                              @ R1 : 0x1000\n\n  LDR R0, [R1, #4]            @ R1에 4를 더한 주소의 참조한 값(0x1004)을 R0에 넣습니다.\n                              @ R1 : 0x1000\n\n  LDR R2, [R1, #4]            @ R1에 4를 더한 주소의 참조한 값(0x1004)을 R2에 넣습니다.\n                              @ R1 : 0x1000\n```\n\n> Pre Indexing에서는 **값이 업데이트 되지 않습니다!** 만약 값을 업데이트하고 싶다면 아래의 `!`(Auto Update) 옵션을 사용해야합니다.\n\n### '`!`(Auto Update) suffix' 사용 예시)\n\n```assembly\n  LDR R1, 0x1000              @ R1에 상수 0x1000을 넣습니다.\n                              @ R1 : 0x1000\n\n  LDR R0, [R1, #4]!           @ R1에 4를 더한 주소의 참조한 값(0x1004)을 R0에 넣습니다.\n                              @ ! suffix가 있으므로, 자동으로 값이 업데이트 됩니다.\n                              @ R1 : 0x1004\n\n  LDR R2, [R1, #4]            @ R1에 4를 더한 주소의 참조한 값(0x1008)을 R2에 넣습니다.\n                              @ ! suffix가 없으므로, 자동으로 값이 업데이트 되지 않습니다.\n                              @ R1 : 0x1004\n```\n\n## `LSL`, `LSR` Shift\n\n- `LSL #n` : 최후에 밀려난 비트가 `CPSR`(상태레지스터)의 C(Carry) flag에 저장\n  - Logical Shift Left\n  - `LSL` : `signed/unsigned` 곱하기 2\n- `LSR #n` : 최후에 밀려난 비트가 `CPSR`(상태레지스터)의 C(Carry) flag에 저장\n  - Logical Shift Right\n  - `LSR` : `unsigned` 나누기 2\n\n## `ASR` Shift\n\n- `ASR #n` : MSB(부호)를 유지하고, 밀려난 비트가 `CPSR`(상태레지스터)의 C(Carry) flag에 저장\n  - 레지스터를 우측으로 지정한 비트 수 만큼 **부호를 유지하며** Shift합니다.\n  - `ASR`은 `signed int`의 나누기 2 동작을 수행합니다.\n\n---\n\n# 비트제어 명령어\n\n- `ORR` : 원하는 비트만 1로 설정합니다.\n\n  - 예) `ORR R0, R0, #0x1F` , `ORR R0, R1, R2, LSL #2`\n\n- `EOR` : 원하는 비트만 반전 시킵니다.\n\n  - 예) `EOR R0, R0, #0x1F` , `EOR R0, R1, R2, LSL #2`\n\n- `AND` : 원하는 비트만 0으로 설정합니다.\n\n  - **0인 비트에 0으로 설정합니다.**\n  - 예) `AND R0, R0, #0x1F` , `AND R0, R1, R2, LSL #2`\n\n- `BIC` : 원하는 비트만 0으로 설정합니다.\n  - **1인 비트에 0으로 설정합니다.**\n  - `AND`보다 편리한 장점이 있습니다.\n  - 예) `BIC R0, R0, #0x1F` , `BIC R0, R1, R2, LSL #2`\n\n## 다양한 비트연산\n\n- **[문제]** `0x1000`의 4~7번 비트를 `1010`으로 변경하는 어셈블리 코드를 작성하세요.\n\n![Example 4](/assets/image/2019-05-15-ARM-Assembly/example4.png)\n\n```assembly\n  LDR R0, =0x1000           @ R0에 상수 0x1000을 넣습니다.\n  LDR R1, [R0]              @ R1에 R0을 참조한 값을 넣습니다.\n  BIC R1, R1, 0xF << 4      @ '1111'을 4번 Left Shift하면 '11110000'가 됩니다.\n                            @ BIC로 R1의 4~7 비트를 0으로 설정합니다.\n  ORR R1, R1, 0xA << 4      @ '1010'을 4번 Left Shift하면 '10100000'가 됩니다.\n                            @ ORR로 R1의 5, 7번 비트를 1로 설정합니다.\n  STR R1, [R0]              @ R1의 데이터를 R0에 저장되어있는 메모리주소에 저장합니다.\n```\n\n---\n\n# 분기 명령어\n\n- `B` 명령 사용 예시:\n  1. `B add` : Global Label\n  2. `B 1f` : Local Label\n  3. `B . ` : 무한 루프 (`.`은 제자리를 말합니다.)\n- `B R0`와 같이 `B` 명령은 분기 주소로 레지스터를 쓸수 없습니다.\n\n---\n\n## 비교 연산 명령어\n\n- `CMP` : `CMP Rs, OP2`\n  - `Rn - OP2` 연산을 하여 `CPSR`(상태레지스터)의 Flag만 변경합니다.\n- `CMN` : `CMN Rs, OP2`\n  - `Rn + OP2` 연산을 하여 `CPSR`(상태레지스터)의 Flag만 변경합니다.\n  - 컴파일러단에서 주로 사용되니, 되도록이면 `CMP`를 사용하자.\n- `TST` : `TST Rs, OP2`\n  - `Rn & OP2` 연산을 하여 `CPSR`(상태레지스터)의 Flag만 변경합니다.\n  - **특정비트를 확인하기 위해 사용됩니다.**\n  - 비교 비트가 **1이면, Z clear, 0이면 Z set**\n- `TEQ` : `TEQ Rs, OP2`\n  - `Rn ^ OP2` 연산을 하여 `CPSR`(상태레지스터)의 Flag만 변경합니다.\n  - **두 데이터의 비트가 완전 똑같은지 확인하기 위해 사용됩니다**\n  - 비트 패턴이 **동일하면, Zero set**\n\n> 비교연산은 레지스터에 변화가 없으며, Flag만 변합니다.\n\n- **[문제]** `R0`의 7번 비트가 `1`이면 `R1` 레지스터에 2를 기록하고, `0`이면 `R1` 레지스터에 3을 기록하는 프로그램을 작성하시오.\n\n- `AND`를 사용하여 해결:\n\n```assembly\n  AND R0, R0, #1 << 7\n  CMP R0, #0\n  MOVEQ R1, #3\n  MOVNE R1, #2\n```\n\n- `TST`를 사용하여 해결:\n\n```assembly\n  TST R0, #1 << 7\n  MOVEQ R1, #3\n  MOVNE R1, #2\n```\n\n---\n\n# `CPSR`(상태레지스터)과 Flag\n\n![CPSR - https://www.wikinote.org/Main/Savitribai-Phule-Pune-University/ENTC/AP-TE/Unit-1/Registers-CPSR-SPSR/](/assets/image/2019-05-15-ARM-Assembly/cpsr.jpg)\n\n비교 연산을 할때는 NZCV만 사용한다\n\n- N (Negative) : 연산결과가 음수인 경우\n- Z (Zero) : 연산결과가 0인 경우\n- C (Carry) : 덧셈 Carry에 Set, 뺄셈 Borrow에 Clear, Rotate시 밀린 비트 저장\n- V (oVerflow) : `signed` 덧셈, 뺄셈 연산 결과로 값의 초과가 발생한 경우\n\n> Carry는 덧셈을 했을때 범위를 초과해서 자리 올림이 발생했을때를 말하는것입니다. Overflow와는 다릅니다.\n\n## 상태 플래그와 조건\n\n```assembly\n  CMP R0, R1\n  B□□ LOOP\n```\n\n□ 부분에 아래의 16가지 조건식이 들어가게 됩니다.\n\n| 약어          | 뜻                                     | Flag 상태                    |\n| ------------- | -------------------------------------- | ---------------------------- |\n| **`EQ`**      | **Eq**ual / Equals zero (False)        | Z set                        |\n| **`NE`**      | **N**ot **E**qual (True)               | Z clear                      |\n| **`CS`**/`HS` | Carry Set / Unsigned higher or same    | **C set**                    |\n| **`CC`**/`LO` | Carry Clear / Unsigned Lower           | **C clear**                  |\n| **`MI`**      | **Mi**nus / Negative                   | N set                        |\n| **`PL`**      | **Pl**us / Positive or zero            | N clear                      |\n| **`VS`**      | Overflow                               | **V s**et                    |\n| **`VC`**      | No Overflow                            | **V c**lear                  |\n| **`HI`**      | `Unsigned` **hi**gher                  | C set and Z clear            |\n| **`LS`**      | `Unsigned` **l**ower or **s**ame       | C clear and Z set            |\n| **`GE`**      | `Signed` **g**reater then or **e**qual | N equals V                   |\n| **`LT`**      | `Signed` **l**ess **t**han             | N is not equals V            |\n| **`GT`**      | `Signed` **g**reater **t**han          | Z clear and N equals V       |\n| **`LE`**      | `Signed` **l**ess than or **e**qual    | Z set or N is not equal to V |\n| **`AL`**      | **Al**ways                             | Any state                    |\n| **`NV`**      | **N**e**v**er                          | None                         |\n\n- 주소 연산을 할때는 `HI`, `LO`, `HS`, `LS`와 같은 `Unsigned` 비교를 사용합니다.\n\n---\n\n# 산술 명령어\n\n- **ADD** : `ADD Rd, Rs, OP2`\n  - `Rd := Rs + OP2`\n- **ADC** : `ADC Rd, Rs, OP2`\n  - `Rd := Rs + OP2 + Carry`\n- **SUB** : `SUB Rd, Rs, OP2`\n  - `Rd := Rs - OP2`\n- **SBC** : `SBC Rd, Rs, OP2`\n  - `Rd := Rs - OP2 - !Carry`\n- **RSB** : `RSB Rd, Rs, OP2`\n  - `Rd := OP2 - Rs`\n- **RSC** : `RSC Rd, Rs, OP2`\n\n  - `Rd := OP2 - Rs - !Carry`\n\n- `RSB`, `RSC`에 있는 R은 Reverse라고 생각합시다.\n\n## 일정 횟수를 반복하는 프로그램\n\n1. `for(i=0; i<10; i++)` 방식\n\n```assembly\n  MOV R0, #0\n1:\n  @ 이곳에 코드 작성\n\n  ADD R0, R0, #1\n  CMP R0, #10\n  BLT 1b\n```\n\n2. `for(i=10; i>0; i--)` 방식\n\n```assembly\n  MOV R0, #10\n1:\n  @ 이곳에 코드 작성\n\n  SUB R0, R0, #1\n  CMP R0, #0\n  BGT 1b\n```\n\n위의 두 방법도 좋지만, Down Count 방식에 S-Suffix를 사용하는게 더 효율적입니다.\n\n```assembly\n  MOV R0, #10\n1:\n  @ 이곳에 코드 작성\n\n  SUBS R0, R0, #1\n  BGT 1b\n```\n\n---\n\n# 서브루틴 호출\n\n- `BL label` : Branch and Link\n  - `BL` : 서브루틴 호출 명령\n  - `label` : 서브루틴의 상대주소 값\n  - `B`와 달리 복귀한 주소(따음 명령 주소) 값을 `R14`에 저장합니다.  \n    ![Subroutine](/assets/image/2019-05-15-ARM-Assembly/subroutine.png)\n  - `BL`은 분기 주소로 레지스터를 사용하지 못합니다.\n\n## 서브루틴 호출과 복귀\n\n- **서브루틴 호출** (`BL label`):\n  1. 복귀할 주소를 `LR`(`R14`)에 저장합니다.\n  2. 서브루틴의 주소를 `PC`(`R15`)에 저장합니다.\n- **서브루틴 복귀** (`BX LR`):\n\n  - `LR`(`R14`)의 값을 `PC`(`R15`)에 저장하여 복귀합니다.\n\n- 왜 함수라고 하지 않고 서브루틴이라고 부를까?\n  - 함수는 다른 값들에 영향을 주지 않지만, 서브루틴은 다른 값들에 영향을 줄수 있습니다.\n\n---\n\n# 특수용도 레지스터\n\n| 레지스터     | 설명                            | 용도                                         |\n| ------------ | ------------------------------- | -------------------------------------------- |\n| `SP` / `R13` | Stack Pointer                   | C언어 사용시 스택의 주소를 저장              |\n| `LR` / `R14` | Link Register                   | 함수 호출 시 되돌아갈 함수의 주소가 저장     |\n| `PC` / `R15` | Program Counter                 | 프로그램 수행 시 읽어오는 명령의 주소를 저장 |\n| CPSR         | Current Program Status Register | 연산결과, IRQ, FIQ금지, 동작모드 등을 저장   |\n"},"__N_SSG":true}