<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta property="og:image" content="https://kyuhyuk.kr/thumbnail.png"/><title>[AVR] ATmega328P SDCard 구현 (2)</title><meta name="author" content="KyuHyuk Lee"/><meta name="generator" content="KyuHyuk Lee"/><meta name="description" content=" 이전 글 에서 CMD0 를 사용해서 SDCard를 IDLE 상태로 만들었습니다. 이 글에서는 그 이후의 초기화 과정을 소개하고 구현해 볼 것입니다. CMD8 (SEND_IF_COND) CMD8 (SEND_IF_COND, Send Interface Condition)은 장착된 SDCar"/><meta itemProp="url" content="https://kyuhyuk.kr/article/avr/2022/09/01/AVR-ATmega328P-SDCard-2"/><meta itemProp="headline" content="[AVR] ATmega328P SDCard 구현 (2)"/><meta property="og:type" content="article"/><meta property="og:url" content="https://kyuhyuk.kr/article/avr/2022/09/01/AVR-ATmega328P-SDCard-2"/><meta property="og:title" content="[AVR] ATmega328P SDCard 구현 (2)"/><meta property="og:description" content=" 이전 글 에서 CMD0 를 사용해서 SDCard를 IDLE 상태로 만들었습니다. 이 글에서는 그 이후의 초기화 과정을 소개하고 구현해 볼 것입니다. CMD8 (SEND_IF_COND) CMD8 (SEND_IF_COND, Send Interface Condition)은 장착된 SDCar"/><meta property="og:site_name" content="KyuHyuk Blog"/><meta property="og:locale" content="ko_KR"/><meta name="next-head-count" content="15"/><style id="stitches">--sxs{--sxs:2 c-opBYf c-bHyrwK c-uBnvQ c-hehuMV c-bjkCdF c-hAoZGi c-jfcKOQ c-fxvkZv c-iosjjB c-jYwCTI c-dIcdES c-cpkrrK c-fiqONv c-iUFgVP c-cshSRb}@media{.c-opBYf{display:flex;align-items:center;background:#FFFFFF;height:60px;justify-content:space-between;-webkit-box-align:center;-webkit-box-pack:justify}.c-bHyrwK{display:flex;align-items:center;justify-content:center;-webkit-box-align:center;-webkit-box-pack:center}.c-uBnvQ{width:32px;height:32px;color:#FFFFFF;background:#000000;border-radius:4px;display:flex;align-items:center;justify-content:center;margin-right:12px;font-weight:700;cursor:default;-webkit-box-align:center;-webkit-box-pack:center}.c-hehuMV{font-weight:900;font-size:18px;letter-spacing:0.5px;color:#000000;cursor:default}.c-bjkCdF{list-style:none;padding:0;margin:0;display:flex;justify-content:center;align-items:center;font-size:24px;color:rgb(134, 142, 150);transition:all 0.3s ease 0s;-webkit-box-pack:center;-webkit-box-align:center}.c-hAoZGi{font-size:28px;color:inherit;text-decoration:none;margin:8px}.c-jfcKOQ{max-width:768px;margin-top:2rem;margin-left:auto;margin-right:auto}.c-fxvkZv{font-size:2.5rem;line-height:1.5;letter-spacing:-0.004em;margin-top:0;margin-bottom:2rem;font-weight:700;color:#212529;word-break:keep-all;transition:color 0.125s ease-in 0s;}.c-iosjjB{background:#F8F9FA;padding:0 1rem;height:2rem;border-radius:1rem;display:inline-flex;align-items:center;margin-right:0.875rem;color:#12B886;text-decoration:none;font-weight:400;font-size:1rem}.c-jYwCTI{font-size:1rem;color:#495057}.c-dIcdES{margin-top:2rem;font-size:1.125rem;color:#212529;transition:color 0.125s ease-in 0s;;line-height:1.7;letter-spacing:-0.004em;word-break:keep-all;overflow-wrap:break-word}.c-cpkrrK{width:100%;height:300px;display:flex;align-items:center;justify-content:center;flex-direction:column;-webkit-box-align:center;-webkit-box-pack:center}.c-fiqONv{color:rgb(206, 212, 218);margin-bottom:8px;font-size:22px;font-weight:700}.c-iUFgVP{width:32px;height:32px;color:#FFFFFF;background:rgb(206, 212, 218);border-radius:4px;display:flex;align-items:center;justify-content:center;margin-right:12px;font-weight:700;cursor:default;-webkit-box-align:center;-webkit-box-pack:center}.c-cshSRb{font-weight:900;font-size:18px;letter-spacing:0.5px;color:rgb(206, 212, 218);cursor:default;text-transform:uppercase}}</style><link rel="preload" href="/_next/static/css/98b299b94b0a7962.css" as="style"/><link rel="stylesheet" href="/_next/static/css/98b299b94b0a7962.css" data-n-g=""/><link rel="preload" href="/_next/static/css/c2a527101433f11d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c2a527101433f11d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-af3068766efac2e7.js" defer=""></script><script src="/_next/static/chunks/pages/_app-1152a1d584800b30.js" defer=""></script><script src="/_next/static/chunks/413-67b20b8229b03582.js" defer=""></script><script src="/_next/static/chunks/796-a00c9a8c08a47d16.js" defer=""></script><script src="/_next/static/chunks/pages/article/%5Bcategory%5D/%5Byear%5D/%5Bmonth%5D/%5Bday%5D/%5Bslug%5D-a6ddc2a5f4e4754e.js" defer=""></script><script src="/_next/static/QV7HAc_WM_SwrI_XVNTV_/_buildManifest.js" defer=""></script><script src="/_next/static/QV7HAc_WM_SwrI_XVNTV_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="c-opBYf"><a href="https://kyuhyuk.kr"><div class="c-bHyrwK"><div class="c-uBnvQ">Kh.</div><div class="c-hehuMV">KyuHyuk Blog</div></div></a><ul class="c-bjkCdF"><li><a href="https://github.com/LeeKyuHyuk" class="c-hAoZGi"><span role="img" aria-label="github" class="anticon anticon-github"><svg viewBox="64 64 896 896" focusable="false" data-icon="github" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0138.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"></path></svg></span></a></li><li><a href="https://linkedin.com/in/leekyuhyuk" class="c-hAoZGi"><span role="img" aria-label="linkedin" class="anticon anticon-linkedin"><svg viewBox="64 64 896 896" focusable="false" data-icon="linkedin" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zM349.3 793.7H230.6V411.9h118.7v381.8zm-59.3-434a68.8 68.8 0 1168.8-68.8c-.1 38-30.9 68.8-68.8 68.8zm503.7 434H675.1V608c0-44.3-.8-101.2-61.7-101.2-61.7 0-71.2 48.2-71.2 98v188.9H423.7V411.9h113.8v52.2h1.6c15.8-30 54.5-61.7 112.3-61.7 120.2 0 142.3 79.1 142.3 181.9v209.4z"></path></svg></span></a></li><li><a href="mailto:lee@kyuhyuk.kr" class="c-hAoZGi"><span role="img" aria-label="mail" class="anticon anticon-mail"><svg viewBox="64 64 896 896" focusable="false" data-icon="mail" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-80.8 108.9L531.7 514.4c-7.8 6.1-18.7 6.1-26.5 0L189.6 268.9A7.2 7.2 0 01194 256h648.8a7.2 7.2 0 014.4 12.9z"></path></svg></span></a></li></ul></header><main class="c-jfcKOQ"><article><h1 class="c-fxvkZv"><a href="https://kyuhyuk.kr/article/avr/2022/09/01/AVR-ATmega328P-SDCard-2">[AVR] ATmega328P SDCard 구현 (2)</a></h1><a href="https://kyuhyuk.kr/category/AVR" class="c-iosjjB">AVR</a><time dateTime="2022-09-01 22:50:19" class="c-jYwCTI">Sep 01, 2022 10:50:19 PM</time><div id="post" class="c-dIcdES"><p><a href="https://kyuhyuk.kr/article/avr/2022/08/28/AVR-ATmega328P-SDCard-1">이전 글</a>에서 <code>CMD0</code>를 사용해서 SDCard를 IDLE 상태로 만들었습니다. 이 글에서는 그 이후의 초기화 과정을 소개하고 구현해 볼 것입니다.</p>
<p><img src="/assets/image/2022-08-28-AVR-ATmega328P-SDCard-1/AVR-ATmega328P-SDCard-1_5.png" alt="SDCard SPI Mode Initalization Flow"></p>
<h1><code>CMD8</code> (SEND_IF_COND)</h1>
<p><code>CMD8</code>(SEND_IF_COND, Send Interface Condition)은 장착된 SDCard가 Version 1.0인지 Version 2.0 (또는 그 이상)인지 확인하는 데 사용됩니다. SDCard가 Version 1.0인 경우에는 R1의 형태의 응답의 Bit 2가 <code>1</code> 입니다. 이럴 경우에는 초기화 다이어그램에서 왼쪽(Illegal Command)으로 내려갑니다. 만약 그렇지 않으면 Version 2.0로 이동하게 됩니다. 참고로 이 글에서는 Version 2.0의 SDCard를 사용하고 있습니다.</p>
<p><img src="/assets/image/2022-09-01-AVR-ATmega328P-SDCard-2/AVR-ATmega328P-SDCard-2_1.png" alt="SDCard SPI Mode Initalization Flow"></p>
<p><code>CMD8</code>를 전송하기 위해 Command Index를 <code>8 (001000b)</code>로 설정합니다. 3.3V에서 작동하므로 <code>VHS</code>는 <code>0001b</code>로 설정합니다. Check Pattern은 아무 값이나 설정이 가능하며, SDCard는 명령이 올바르게 처리되었는지 확인하기 위해 응답으로 반환합니다. 참고로 <a href="/assets/file/2022-08-28-AVR-ATmega328P-SDCard-1/Part_1_Physical_Layer_Simplified_Specification_Ver2.00_060925.pdf">SDCard Physical Specification</a> 51페이지를 보면 <code>10101010b</code>를 권장하고 있습니다. 그리고 마지막으로 CRC를 설정해야 하는데 <code>CMD8</code>은 올바른 CRC가 필요한 <code>CMD0</code> 이외의 유일한 명령입니다. 3.3V <code>VHS</code>를 사용하고 권장되는 Check Pattern를 Command에 지정된 대로 모든 비트를 설정하면 올바른 CRC는 <code>01000011b</code> 입니다. 아래와 같이 <code>CMD8</code> 명령을 전송할 수 있습니다.</p>
<p>만약, CRC 계산을 직접 하고 싶다면, <a href="https://kyuhyuk.kr/crc7-mmc-calc/">CRC7-MMC Calculator</a>에 접속해서 계산할 수 있습니다.<br>
계산 방법은 <a href="https://github.com/LeeKyuHyuk/crc7-mmc-calc">https://github.com/LeeKyuHyuk/crc7-mmc-calc</a>를 참조하시길 바랍니다.<br>
<img src="/assets/image/2022-09-01-AVR-ATmega328P-SDCard-2/AVR-ATmega328P-SDCard-2_2.png" alt="CRC7-MMC Calculator"></p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD8        8</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD8_ARG    0x000001AA <span class="hljs-comment">// 0000000110101010b</span></span>
<span class="hljs-comment">/*
    CMD8_CRC = (01000011 &lt;&lt; 1)
    End Bit자리를 만들어줘야 하기 때문에 &lt;&lt; 1 을 합니다
    End Bit을 1로 설정하는 부분은 sdCommand()의
    spiTransfer(crc | 0x01); 에서 처리합니다
*/</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD8_CRC    0x86</span>

<span class="hljs-comment">// send CMD8</span>
sdCommand(CMD8, CMD8_ARG, CMD8_CRC);
</code></pre>
<h1>R7 Response</h1>
<p><code>CMD8</code>에 대한 응답은 <code>R7</code> 형식으로 수신받으며, 아래와 같습니다:</p>
<p><img src="/assets/image/2022-09-01-AVR-ATmega328P-SDCard-2/AVR-ATmega328P-SDCard-2_3.png" alt="R7 Response Format"></p>
<p><code>R7</code>의 길이는 5바이트이며, 첫 번째 바이트는 <code>R1</code>과 동일합니다. 그다음에는 Command Version, Voltage Accepted 필드와 Command에서 보낸 Check Pattern의 'Echo-Back'이 있습니다. 만약 SDCard가 Version 1.0이면 Illegal Bit Command가 Set된 <code>R1</code>을 반환합니다.</p>
<p>이제 <code>R7</code>을 수신하는 <code>sdReadRes7()</code>를 작성해 봅시다.</p>
<blockquote>
<p><a href="https://kyuhyuk.kr/article/avr/2022/08/28/AVR-ATmega328P-SDCard-1">이전 글</a>에서 작성한 <code>sdReadRes1()</code>을 사용합니다.</p>
</blockquote>
<pre><code class="language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">sdReadRes7</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *res)</span>
{
    <span class="hljs-comment">// R7에서 R1 Response를 읽습니다</span>
    res[<span class="hljs-number">0</span>] = sdReadRes1();

    <span class="hljs-comment">/*
      R1 Response에 Error가 존재하면
      더 이상 진행하지 않고 반환합니다
    */</span>
    <span class="hljs-keyword">if</span>(res[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">/*
      R1 Response에 Error가 없다면
      남은 바이트를 읽습니다
    */</span>
    res[<span class="hljs-number">1</span>] = spiTransfer(<span class="hljs-number">0xFF</span>);
    res[<span class="hljs-number">2</span>] = spiTransfer(<span class="hljs-number">0xFF</span>);
    res[<span class="hljs-number">3</span>] = spiTransfer(<span class="hljs-number">0xFF</span>);
    res[<span class="hljs-number">4</span>] = spiTransfer(<span class="hljs-number">0xFF</span>);
}
</code></pre>
<h1><code>CMD8</code> 함수 구현하기</h1>
<p>위에서 작성한 코드를 바탕으로 <code>CMD8</code>을 전송하고 응답을 받아보겠습니다.</p>
<pre><code class="language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">sdSendIfCond</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *res)</span>
{
    <span class="hljs-comment">// SDCard CS Assert</span>
    spiTransfer(<span class="hljs-number">0xFF</span>);
    CS_ENABLE();
    spiTransfer(<span class="hljs-number">0xFF</span>);

    <span class="hljs-comment">// CMD8 전송</span>
    sdCommand(CMD8, CMD8_ARG, CMD8_CRC);

    <span class="hljs-comment">// CMD8에 대한 Rsponse를 읽습니다</span>
    sdReadRes7(res);

    <span class="hljs-comment">// SDCard CS Deassert</span>
    spiTransfer(<span class="hljs-number">0xFF</span>);
    CS_DISABLE();
    spiTransfer(<span class="hljs-number">0xFF</span>);
}
</code></pre>
<p><code>sdSendIfCond()</code>에서 사용되는 <code>res</code>는 전체 Response(5바이트)를 담을 수 있는 <code>uint8_t</code> 배열에 대한 포인터를 받습니다.</p>
<h1>UART로 출력하기</h1>
<p>SDCard가 무엇을 하는지 보기 위해 UART로 출력하는 부분을 구현합니다. UART 구현의 부분은 <a href="https://kyuhyuk.kr/article/avr/2022/08/28/AVR-ATmega328P-UART">이 글</a>을 참고해 주세요.</p>
<p>일단 <code>R1</code>을 출력하는 <code>sdPrintR1()</code>을 구현합시다.</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PARAM_ERROR(X)      X &amp; 0b01000000</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ADDR_ERROR(X)       X &amp; 0b00100000</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ERASE_SEQ_ERROR(X)  X &amp; 0b00010000</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CRC_ERROR(X)        X &amp; 0b00001000</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ILLEGAL_CMD(X)      X &amp; 0b00000100</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ERASE_RESET(X)      X &amp; 0b00000010</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> IN_IDLE(X)          X &amp; 0b00000001</span>

<span class="hljs-type">void</span> <span class="hljs-title function_">sdPrintR1</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> res)</span>
{
    <span class="hljs-keyword">if</span>(res &amp; <span class="hljs-number">0b10000000</span>) {
        uartPuts(<span class="hljs-string">&quot;\tError: MSB = 1\r\n&quot;</span>);
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span>(res == <span class="hljs-number">0</span>) {
        uartPuts(<span class="hljs-string">&quot;\tCard Ready\r\n&quot;</span>);
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span>(PARAM_ERROR(res))
        uartPuts(<span class="hljs-string">&quot;\tParameter Error\r\n&quot;</span>);
    <span class="hljs-keyword">if</span>(ADDR_ERROR(res))
        uartPuts(<span class="hljs-string">&quot;\tAddress Error\r\n&quot;</span>);
    <span class="hljs-keyword">if</span>(ERASE_SEQ_ERROR(res))
        uartPuts(<span class="hljs-string">&quot;\tErase Sequence Error\r\n&quot;</span>);
    <span class="hljs-keyword">if</span>(CRC_ERROR(res))
        uartPuts(<span class="hljs-string">&quot;\tCRC Error\r\n&quot;</span>);
    <span class="hljs-keyword">if</span>(ILLEGAL_CMD(res))
        uartPuts(<span class="hljs-string">&quot;\tIllegal Command\r\n&quot;</span>);
    <span class="hljs-keyword">if</span>(ERASE_RESET(res))
        uartPuts(<span class="hljs-string">&quot;\tErase Reset Error\r\n&quot;</span>);
    <span class="hljs-keyword">if</span>(IN_IDLE(res))
        uartPuts(<span class="hljs-string">&quot;\tIn Idle State\r\n&quot;</span>);
}
</code></pre>
<p><code>sdPrintR1()</code>는 Response에 존재할 수 있는 오류들을 확인하고 설명을 출력합니다. 만약, MSB가 <code>1</code>(Response 수신 오류를 나타냅니다)이고 Flag가 설정되어 있지 않은 경우(이미 SDCard 초기화되어 있을 경우)에는 즉시 반환합니다.</p>
<p>다음으로 위에서 작성한 거와 비슷한 <code>sdPrintR7()</code>을 구현하겠습니다.</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD_VER(X)          ((X &gt;&gt; 4) &amp; 0xF0)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> VOL_ACC(X)          (X &amp; 0x1F)</span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> VOLTAGE_ACC_27_33   0b00000001</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> VOLTAGE_ACC_LOW     0b00000010</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> VOLTAGE_ACC_RES1    0b00000100</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> VOLTAGE_ACC_RES2    0b00001000</span>

<span class="hljs-type">void</span> <span class="hljs-title function_">sdPrintR7</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *res)</span>
{
    sdPrintR1(res[<span class="hljs-number">0</span>]);

    <span class="hljs-keyword">if</span>(res[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;

    uartPuts(<span class="hljs-string">&quot;\tCommand Version: &quot;</span>);
    uartPutHex8(CMD_VER(res[<span class="hljs-number">1</span>]));
    uartPuts(<span class="hljs-string">&quot;\r\n&quot;</span>);

    uartPuts(<span class="hljs-string">&quot;\tVoltage Accepted: &quot;</span>);
    <span class="hljs-keyword">if</span>(VOL_ACC(res[<span class="hljs-number">3</span>]) == VOLTAGE_ACC_27_33)
        uartPuts(<span class="hljs-string">&quot;2.7-3.6V\r\n&quot;</span>);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(VOL_ACC(res[<span class="hljs-number">3</span>]) == VOLTAGE_ACC_LOW)
        uartPuts(<span class="hljs-string">&quot;LOW VOLTAGE\r\n&quot;</span>);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(VOL_ACC(res[<span class="hljs-number">3</span>]) == VOLTAGE_ACC_RES1)
        uartPuts(<span class="hljs-string">&quot;RESERVED\r\n&quot;</span>);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(VOL_ACC(res[<span class="hljs-number">3</span>]) == VOLTAGE_ACC_RES2)
        uartPuts(<span class="hljs-string">&quot;RESERVED\r\n&quot;</span>);
    <span class="hljs-keyword">else</span>
        uartPuts(<span class="hljs-string">&quot;NOT DEFINED\r\n&quot;</span>);

    uartPuts(<span class="hljs-string">&quot;\tEcho: &quot;</span>);
    uartPutHex8(res[<span class="hljs-number">4</span>]);
    uartPuts(<span class="hljs-string">&quot;\r\n&quot;</span>);
}
</code></pre>
<h1><code>CMD0</code>와 <code>CMD8</code> 보내기</h1>
<p>이제 <code>CMD0</code>와 <code>CMD8</code>을 SDCard로 보내고 Response를 읽어보겠습니다.</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> F_CPU 16000000UL</span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    <span class="hljs-comment">// Response를 담을 배열을 선언합니다</span>
    <span class="hljs-type">uint8_t</span> res[<span class="hljs-number">5</span>];

    <span class="hljs-comment">// UART를 초기화 합니다</span>
    <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> baudRate = (F_CPU / <span class="hljs-number">16</span> / <span class="hljs-number">9600</span>) - <span class="hljs-number">1</span>;
    uartInit(baudRate);

    <span class="hljs-comment">// SPI를 초기화 합니다</span>
    spiInit();

    <span class="hljs-comment">// Power Up Sequence를 시작합니다</span>
    sdPowerUpSeq();

    <span class="hljs-comment">// CMD0를 SDCard로 전송합니다</span>
    uartPuts(<span class="hljs-string">&quot;Sending CMD0...\r\n&quot;</span>);
    res[<span class="hljs-number">0</span>] = sdGoIdleState();
    uartPuts(<span class="hljs-string">&quot;Response:\r\n&quot;</span>);
    sdPrintR1(res[<span class="hljs-number">0</span>]);

    <span class="hljs-comment">// CMD8을 SDCard로 전송합니다</span>
    uartPuts(<span class="hljs-string">&quot;Sending CMD8...\r\n&quot;</span>);
    sdSendIfCond(res);
    uartPuts(<span class="hljs-string">&quot;Response:\r\n&quot;</span>);
    sdPrintR7(res);

    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);
}
</code></pre>
<p>UART를 통해 출력되는 내용은 아래와 같습니다:<br>
<img src="/assets/image/2022-09-01-AVR-ATmega328P-SDCard-2/AVR-ATmega328P-SDCard-2_4.png" alt="UART Output"></p>
<p>정상적으로 동작하는 것을 확실하게 보고 싶다면 Logic Analyzer로 <code>CMD8</code>에 대한 Output을 확인해 보는 것도 좋습니다.<br>
<img src="/assets/image/2022-09-01-AVR-ATmega328P-SDCard-2/AVR-ATmega328P-SDCard-2_5.png" alt="Logic Analyzer"></p>
<p>SDCard에서 받은 응답인 <code>R7</code>의 처음 8바이트에서 잘못된 명령으로 출력되지 않았으며, 전압 범위(2.7~3.6V)도 확인했습니다. 또한 Check Pattern인 <code>0xAA</code>를 Response에서 받을 수 있었습니다. 모두 정상 작동하는 것을 확인할 수 있습니다.</p>
<h1><code>CMD58</code> (READ_OCR)</h1>
<p>이제 다음 단계인 OCR(Operation Conditions Register)를 읽는 <code>CMD58</code>를 살펴보겠습니다.<br>
<img src="/assets/image/2022-09-01-AVR-ATmega328P-SDCard-2/AVR-ATmega328P-SDCard-2_6.png" alt="CMD58 Format"></p>
<p>Argument는 Stuff Bit이고 CRC는 무시해도 됩니다. Response는 <code>R3</code> 형식으로 받으며 아래와 같습니다.<br>
<img src="/assets/image/2022-09-01-AVR-ATmega328P-SDCard-2/AVR-ATmega328P-SDCard-2_7.png" alt="R3 Format"></p>
<p><code>R7</code>과 마찬가지로 첫 번째 바이트는 <code>R1</code>과 동일하고, 다음 4바이트는 OCR이 담겨있습니다. OCR은 아래와 같이 정의되어 있습니다.<br>
<img src="/assets/image/2022-09-01-AVR-ATmega328P-SDCard-2/AVR-ATmega328P-SDCard-2_8.png" alt="OCR Register Definition"></p>
<p>OCR의 Bit 15~24는 SDCard에서 지원하는 전압의 값을 나타냅니다. Bit 31은 SDCard의 Power Up 상태를 나타냅니다. 만약, SDCard가 Power Up Routine을 완료하지 않은 경우에는 LOW로 설정되어 있습니다. 그리고 Bit 30은 Power Up Status(Bit 31)이 Set된 상태에서만 유효한 값을 가지며, SDCard가 고용량(SDHC)인지 확장 용량(SCXC)인지 SDSC인지를 나타냅니다.</p>
<p><code>CMD58</code>에서는 Argument와 CRC가 중요하지 않으므로 모두 <code>0</code>으로 설정합니다.</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD58       58</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD58_ARG   0x00000000</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD58_CRC   0x00</span>

<span class="hljs-comment">// CMD58 전송</span>
sdCommand(CMD58, CMD58_ARG, CMD_CRC);
</code></pre>
<h1>R3 Response</h1>
<p><code>R3</code>을 수신하는 함수는 <code>R7</code>과 동일합니다. 둘 다 길이가 5바이트이고 <code>R1</code>으로 시작하기 때문입니다. 이전에 구현한 <code>sdReadRes7()</code>를 재사용하고 아래와 같이 이름을 바꿀 수 있습니다.</p>
<pre><code class="language-diff"><span class="hljs-deletion">- void sdReadRes7(uint8_t *res)</span>
<span class="hljs-addition">+ void sdReadRes3Res7(uint8_t *res)</span>
 {
<span class="hljs-deletion">-    // R7에서 R1 Response를 읽습니다</span>
<span class="hljs-addition">+    // R1 Response를 읽습니다</span>
     res[0] = sdReadRes1();

     /*
       R1 Response에 Error가 존재하면
       더 이상 진행하지 않고 반환합니다
     */
     if(res[0] &gt; 1) return;

     /*
       R1 Response에 Error가 없다면
       남은 바이트를 읽습니다
     */
     res[1] = spiTransfer(0xFF);
     res[2] = spiTransfer(0xFF);
     res[3] = spiTransfer(0xFF);
     res[4] = spiTransfer(0xFF);
}
</code></pre>
<h1><code>CMD58</code> 함수 구현하기</h1>
<p>아래와 같이 <code>CMD58</code>을 전송하고, Response를 받는 <code>sdReadOcr()</code>를 구현해 봅시다.</p>
<pre><code class="language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">sdReadOcr</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *res)</span>
{
    <span class="hljs-comment">// SDCard CS Assert</span>
    spiTransfer(<span class="hljs-number">0xFF</span>);
    CS_ENABLE();
    spiTransfer(<span class="hljs-number">0xFF</span>);

    <span class="hljs-comment">// CMD58 전송</span>
    sdCommand(CMD58, CMD58_ARG, CMD58_CRC);

    <span class="hljs-comment">// Response를 읽습니다</span>
    sdReadRes3Res7(res);

    <span class="hljs-comment">// SDCard CS Deassert</span>
    spiTransfer(<span class="hljs-number">0xFF</span>);
    CS_DISABLE();
    spiTransfer(<span class="hljs-number">0xFF</span>);
}
</code></pre>
<h1><code>R3</code> Response와 OCR 출력하기</h1>
<p><code>R7</code>과 마찬가지로 먼저 <code>R1</code>을 확인하고 오류가 있으면 나머지 Response의 출력을 건너뜁니다. <code>R1</code>에 오류가 없으면 OCR을 출력합니다.</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> POWER_UP_STATUS(X)  X &amp; 0x40</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CCS_VAL(X)          X &amp; 0x40</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> VDD_2728(X)         X &amp; 0b10000000</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> VDD_2829(X)         X &amp; 0b00000001</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> VDD_2930(X)         X &amp; 0b00000010</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> VDD_3031(X)         X &amp; 0b00000100</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> VDD_3132(X)         X &amp; 0b00001000</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> VDD_3233(X)         X &amp; 0b00010000</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> VDD_3334(X)         X &amp; 0b00100000</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> VDD_3435(X)         X &amp; 0b01000000</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> VDD_3536(X)         X &amp; 0b10000000</span>

<span class="hljs-type">void</span> <span class="hljs-title function_">sdPrintR3</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *res)</span>
{
    sdPrintR1(res[<span class="hljs-number">0</span>]);

    <span class="hljs-keyword">if</span>(res[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;

    uartPuts(<span class="hljs-string">&quot;\tCard Power Up Status: &quot;</span>);
    <span class="hljs-keyword">if</span>(POWER_UP_STATUS(res[<span class="hljs-number">1</span>]))
    {
        uartPuts(<span class="hljs-string">&quot;READY\r\n&quot;</span>);
        uartPuts(<span class="hljs-string">&quot;\tCCS Status: &quot;</span>);
        <span class="hljs-keyword">if</span>(CCS_VAL(res[<span class="hljs-number">1</span>])){ uartPuts(<span class="hljs-string">&quot;1\r\n&quot;</span>); }
        <span class="hljs-keyword">else</span> uartPuts(<span class="hljs-string">&quot;0\r\n&quot;</span>);
    }
    <span class="hljs-keyword">else</span>
    {
        uartPuts(<span class="hljs-string">&quot;BUSY\r\n&quot;</span>);
    }

    uartPuts(<span class="hljs-string">&quot;\tVDD Window: &quot;</span>);
    <span class="hljs-keyword">if</span>(VDD_2728(res[<span class="hljs-number">3</span>])) uartPuts(<span class="hljs-string">&quot;2.7-2.8, &quot;</span>);
    <span class="hljs-keyword">if</span>(VDD_2829(res[<span class="hljs-number">2</span>])) uartPuts(<span class="hljs-string">&quot;2.8-2.9, &quot;</span>);
    <span class="hljs-keyword">if</span>(VDD_2930(res[<span class="hljs-number">2</span>])) uartPuts(<span class="hljs-string">&quot;2.9-3.0, &quot;</span>);
    <span class="hljs-keyword">if</span>(VDD_3031(res[<span class="hljs-number">2</span>])) uartPuts(<span class="hljs-string">&quot;3.0-3.1, &quot;</span>);
    <span class="hljs-keyword">if</span>(VDD_3132(res[<span class="hljs-number">2</span>])) uartPuts(<span class="hljs-string">&quot;3.1-3.2, &quot;</span>);
    <span class="hljs-keyword">if</span>(VDD_3233(res[<span class="hljs-number">2</span>])) uartPuts(<span class="hljs-string">&quot;3.2-3.3, &quot;</span>);
    <span class="hljs-keyword">if</span>(VDD_3334(res[<span class="hljs-number">2</span>])) uartPuts(<span class="hljs-string">&quot;3.3-3.4, &quot;</span>);
    <span class="hljs-keyword">if</span>(VDD_3435(res[<span class="hljs-number">2</span>])) uartPuts(<span class="hljs-string">&quot;3.4-3.5, &quot;</span>);
    <span class="hljs-keyword">if</span>(VDD_3536(res[<span class="hljs-number">2</span>])) uartPuts(<span class="hljs-string">&quot;3.5-3.6&quot;</span>);
    uartPuts(<span class="hljs-string">&quot;\r\n&quot;</span>);
}
</code></pre>
<p>Power Up Status가 <code>1</code>인 경우에만 CCS를 출력합니다. Power Up Status가 <code>1</code>이 아닐 때는 CCS의 값이 유효하지 않기 때문입니다.</p>
<h1>간단한 CLI 만들기</h1>
<p>SDCard를 초기화하고 디버깅하는 방법을 배우는 가장 좋은 방법 중 하나는 CLI 프로그램을 만드는 것입니다. UART를 사용해서 원하는 Command를 SDCard로 보내고 Response를 출력하도록 만들 것입니다. UART에 <code>0</code>~<code>2</code>가 입력되면 <code>CMD0</code>, <code>CMD8</code>, <code>CMD58</code>을 보낼 것입니다.</p>
<pre><code class="language-c"><span class="hljs-comment">/*
  CPU의 Frequency를 16MHz로 설정합니다
*/</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> F_CPU 16000000UL</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;util/delay.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
  <span class="hljs-type">uint8_t</span> res[<span class="hljs-number">5</span>];
  <span class="hljs-type">char</span> c;

  <span class="hljs-comment">// UART를 초기화 합니다</span>
  <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> baudRate = (F_CPU / <span class="hljs-number">16</span> / <span class="hljs-number">9600</span>) - <span class="hljs-number">1</span>;
  uartInit(baudRate);

  <span class="hljs-comment">// SPI를 초기화 합니다</span>
  spiInit();

  <span class="hljs-comment">// SDCard에 VCC가 충분히 공급될때까지 기다립니다</span>
  _delay_ms(<span class="hljs-number">10</span>);

  <span class="hljs-comment">// Power Up Sequence를 시작합니다</span>
  sdPowerUpSeq();

  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)
  {
    <span class="hljs-comment">// 메뉴를 출력합니다</span>
    uartPuts(<span class="hljs-string">&quot;MENU\r\n&quot;</span>);
    uartPuts(<span class="hljs-string">&quot;------------------\r\n&quot;</span>);
    uartPuts(<span class="hljs-string">&quot;0 - Send CMD0\r\n1 - Send CMD8\r\n2 - Send CMD58\r\n&quot;</span>);
    uartPuts(<span class="hljs-string">&quot;------------------\r\n&quot;</span>);

    <span class="hljs-comment">// 사용자에게 명령(문자)를 입력받습니다</span>
    c = uartGet();

    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;0&#x27;</span>)
    {
      <span class="hljs-comment">// CMD0을 보내고 응답을 읽습니다</span>
      uartPuts(<span class="hljs-string">&quot;Sending CMD0...\r\n&quot;</span>);
      CS_ENABLE();
      sdCommand(CMD0, CMD0_ARG, CMD0_CRC);
      res[<span class="hljs-number">0</span>] = sdReadRes1();
      CS_DISABLE();
      spiTransfer(<span class="hljs-number">0xFF</span>);

      <span class="hljs-comment">// R1 출력</span>
      uartPuts(<span class="hljs-string">&quot;Response: \r\n&quot;</span>);
      sdPrintR1(res[<span class="hljs-number">0</span>]);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;1&#x27;</span>)
    {
      <span class="hljs-comment">// CMD8을 보내고 응답을 읽습니다</span>
      uartPuts(<span class="hljs-string">&quot;Sending CMD8...\r\n&quot;</span>);
      CS_ENABLE();
      sdCommand(CMD8, CMD8_ARG, CMD8_CRC);
      sdReadRes3Res7(res);
      CS_DISABLE();
      spiTransfer(<span class="hljs-number">0xFF</span>);

      <span class="hljs-comment">// R7 출력</span>
      uartPuts(<span class="hljs-string">&quot;Response: \r\n&quot;</span>);
      sdPrintR7(res);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;2&#x27;</span>)
    {
      <span class="hljs-comment">// CMD58을 보내고 응답을 읽습니다.</span>
      uartPuts(<span class="hljs-string">&quot;Sending CMD58...\r\n&quot;</span>);
      CS_ENABLE();
      sdCommand(CMD58, CMD58_ARG, CMD58_CRC);
      sdReadRes3Res7(res);
      CS_DISABLE();
      spiTransfer(<span class="hljs-number">0xFF</span>);

      <span class="hljs-comment">// R3 출력</span>
      uartPuts(<span class="hljs-string">&quot;Response: \r\n&quot;</span>);
      sdPrintR3(res);
    }
    <span class="hljs-keyword">else</span>
    {
      uartPuts(<span class="hljs-string">&quot;Unrecognized command\r\n&quot;</span>);
    }
  }
}
</code></pre>
<p>SDCard의 초기화 과정과 같이 <code>CMD0</code>, <code>CMD8</code>, <code>CMD58</code>을 <code>0</code>, <code>1</code>, <code>2</code>를 차례대로 입력하여 전송해 봅시다. 그러면 아래와 같이 출력됩니다.<br>
<img src="/assets/image/2022-09-01-AVR-ATmega328P-SDCard-2/AVR-ATmega328P-SDCard-2_9.png" alt="SDCard CLI"></p>
<p><code>CMD58</code>의 Response를 보면, SDCard가 2.7~3.6V 사이의 모든 전압을 지원하며, Power Up Status는 BUSY 상태입니다. (CCS가 없다는 것을 의미합니다). 만약 여기서 카드가 지원하지 않는 전압 값을 반환하면 사용할 수 없는 SDCard라고 볼 수 있습니다. 다행이게도 제가 사용한 SDCard는 실행 중인 값인 3.3V를 지원하기 때문에 초기화 과정을 계속 진행할 수 있습니다.</p>
</div></article></main><footer class="c-cpkrrK"><div class="c-fiqONv">© <!-- -->2023</div><div class="c-bHyrwK"><div class="c-iUFgVP">Kh.</div><div class="c-cshSRb">KyuHyuk Lee</div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"excerpt":" 이전 글 에서 CMD0 를 사용해서 SDCard를 IDLE 상태로 만들었습니다. 이 글에서는 그 이후의 초기화 과정을 소개하고 구현해 볼 것입니다. CMD8 (SEND_IF_COND) CMD8 (SEND_IF_COND, Send Interface Condition)은 장착된 SDCar","url":"/article/avr/2022/09/01/AVR-ATmega328P-SDCard-2","frontmatter":{"title":"[AVR] ATmega328P SDCard 구현 (2)","date":"2022-09-01 22:50:19","category":"AVR"},"content":"\n[이전 글](https://kyuhyuk.kr/article/avr/2022/08/28/AVR-ATmega328P-SDCard-1)에서 `CMD0`를 사용해서 SDCard를 IDLE 상태로 만들었습니다. 이 글에서는 그 이후의 초기화 과정을 소개하고 구현해 볼 것입니다.\n\n![SDCard SPI Mode Initalization Flow](/assets/image/2022-08-28-AVR-ATmega328P-SDCard-1/AVR-ATmega328P-SDCard-1_5.png)\n\n# `CMD8` (SEND_IF_COND)\n\n`CMD8`(SEND_IF_COND, Send Interface Condition)은 장착된 SDCard가 Version 1.0인지 Version 2.0 (또는 그 이상)인지 확인하는 데 사용됩니다. SDCard가 Version 1.0인 경우에는 R1의 형태의 응답의 Bit 2가 `1` 입니다. 이럴 경우에는 초기화 다이어그램에서 왼쪽(Illegal Command)으로 내려갑니다. 만약 그렇지 않으면 Version 2.0로 이동하게 됩니다. 참고로 이 글에서는 Version 2.0의 SDCard를 사용하고 있습니다.\n\n![SDCard SPI Mode Initalization Flow](/assets/image/2022-09-01-AVR-ATmega328P-SDCard-2/AVR-ATmega328P-SDCard-2_1.png)\n\n`CMD8`를 전송하기 위해 Command Index를 `8 (001000b)`로 설정합니다. 3.3V에서 작동하므로 `VHS`는 `0001b`로 설정합니다. Check Pattern은 아무 값이나 설정이 가능하며, SDCard는 명령이 올바르게 처리되었는지 확인하기 위해 응답으로 반환합니다. 참고로 [SDCard Physical Specification](/assets/file/2022-08-28-AVR-ATmega328P-SDCard-1/Part_1_Physical_Layer_Simplified_Specification_Ver2.00_060925.pdf) 51페이지를 보면 `10101010b`를 권장하고 있습니다. 그리고 마지막으로 CRC를 설정해야 하는데 `CMD8`은 올바른 CRC가 필요한 `CMD0` 이외의 유일한 명령입니다. 3.3V `VHS`를 사용하고 권장되는 Check Pattern를 Command에 지정된 대로 모든 비트를 설정하면 올바른 CRC는 `01000011b` 입니다. 아래와 같이 `CMD8` 명령을 전송할 수 있습니다.\n\n만약, CRC 계산을 직접 하고 싶다면, [CRC7-MMC Calculator](https://kyuhyuk.kr/crc7-mmc-calc/)에 접속해서 계산할 수 있습니다.  \n계산 방법은 [https://github.com/LeeKyuHyuk/crc7-mmc-calc](https://github.com/LeeKyuHyuk/crc7-mmc-calc)를 참조하시길 바랍니다.  \n![CRC7-MMC Calculator](/assets/image/2022-09-01-AVR-ATmega328P-SDCard-2/AVR-ATmega328P-SDCard-2_2.png)\n\n```c\n#define CMD8        8\n#define CMD8_ARG    0x000001AA // 0000000110101010b\n/*\n    CMD8_CRC = (01000011 \u003c\u003c 1)\n    End Bit자리를 만들어줘야 하기 때문에 \u003c\u003c 1 을 합니다\n    End Bit을 1로 설정하는 부분은 sdCommand()의\n    spiTransfer(crc | 0x01); 에서 처리합니다\n*/\n#define CMD8_CRC    0x86\n\n// send CMD8\nsdCommand(CMD8, CMD8_ARG, CMD8_CRC);\n```\n\n# R7 Response\n\n`CMD8`에 대한 응답은 `R7` 형식으로 수신받으며, 아래와 같습니다:\n\n![R7 Response Format](/assets/image/2022-09-01-AVR-ATmega328P-SDCard-2/AVR-ATmega328P-SDCard-2_3.png)\n\n`R7`의 길이는 5바이트이며, 첫 번째 바이트는 `R1`과 동일합니다. 그다음에는 Command Version, Voltage Accepted 필드와 Command에서 보낸 Check Pattern의 'Echo-Back'이 있습니다. 만약 SDCard가 Version 1.0이면 Illegal Bit Command가 Set된 `R1`을 반환합니다.\n\n이제 `R7`을 수신하는 `sdReadRes7()`를 작성해 봅시다.\n\n\u003e [이전 글](https://kyuhyuk.kr/article/avr/2022/08/28/AVR-ATmega328P-SDCard-1)에서 작성한 `sdReadRes1()`을 사용합니다.\n\n```c\nvoid sdReadRes7(uint8_t *res)\n{\n    // R7에서 R1 Response를 읽습니다\n    res[0] = sdReadRes1();\n\n    /*\n      R1 Response에 Error가 존재하면\n      더 이상 진행하지 않고 반환합니다\n    */\n    if(res[0] \u003e 1) return;\n\n    /*\n      R1 Response에 Error가 없다면\n      남은 바이트를 읽습니다\n    */\n    res[1] = spiTransfer(0xFF);\n    res[2] = spiTransfer(0xFF);\n    res[3] = spiTransfer(0xFF);\n    res[4] = spiTransfer(0xFF);\n}\n```\n\n# `CMD8` 함수 구현하기\n\n위에서 작성한 코드를 바탕으로 `CMD8`을 전송하고 응답을 받아보겠습니다.\n\n```c\nvoid sdSendIfCond(uint8_t *res)\n{\n    // SDCard CS Assert\n    spiTransfer(0xFF);\n    CS_ENABLE();\n    spiTransfer(0xFF);\n\n    // CMD8 전송\n    sdCommand(CMD8, CMD8_ARG, CMD8_CRC);\n\n    // CMD8에 대한 Rsponse를 읽습니다\n    sdReadRes7(res);\n\n    // SDCard CS Deassert\n    spiTransfer(0xFF);\n    CS_DISABLE();\n    spiTransfer(0xFF);\n}\n```\n\n`sdSendIfCond()`에서 사용되는 `res`는 전체 Response(5바이트)를 담을 수 있는 `uint8_t` 배열에 대한 포인터를 받습니다.\n\n# UART로 출력하기\n\nSDCard가 무엇을 하는지 보기 위해 UART로 출력하는 부분을 구현합니다. UART 구현의 부분은 [이 글](https://kyuhyuk.kr/article/avr/2022/08/28/AVR-ATmega328P-UART)을 참고해 주세요.\n\n일단 `R1`을 출력하는 `sdPrintR1()`을 구현합시다.\n\n```c\n#define PARAM_ERROR(X)      X \u0026 0b01000000\n#define ADDR_ERROR(X)       X \u0026 0b00100000\n#define ERASE_SEQ_ERROR(X)  X \u0026 0b00010000\n#define CRC_ERROR(X)        X \u0026 0b00001000\n#define ILLEGAL_CMD(X)      X \u0026 0b00000100\n#define ERASE_RESET(X)      X \u0026 0b00000010\n#define IN_IDLE(X)          X \u0026 0b00000001\n\nvoid sdPrintR1(uint8_t res)\n{\n    if(res \u0026 0b10000000) {\n        uartPuts(\"\\tError: MSB = 1\\r\\n\");\n        return;\n    }\n    if(res == 0) {\n        uartPuts(\"\\tCard Ready\\r\\n\");\n        return;\n    }\n    if(PARAM_ERROR(res))\n        uartPuts(\"\\tParameter Error\\r\\n\");\n    if(ADDR_ERROR(res))\n        uartPuts(\"\\tAddress Error\\r\\n\");\n    if(ERASE_SEQ_ERROR(res))\n        uartPuts(\"\\tErase Sequence Error\\r\\n\");\n    if(CRC_ERROR(res))\n        uartPuts(\"\\tCRC Error\\r\\n\");\n    if(ILLEGAL_CMD(res))\n        uartPuts(\"\\tIllegal Command\\r\\n\");\n    if(ERASE_RESET(res))\n        uartPuts(\"\\tErase Reset Error\\r\\n\");\n    if(IN_IDLE(res))\n        uartPuts(\"\\tIn Idle State\\r\\n\");\n}\n```\n\n`sdPrintR1()`는 Response에 존재할 수 있는 오류들을 확인하고 설명을 출력합니다. 만약, MSB가 `1`(Response 수신 오류를 나타냅니다)이고 Flag가 설정되어 있지 않은 경우(이미 SDCard 초기화되어 있을 경우)에는 즉시 반환합니다.\n\n다음으로 위에서 작성한 거와 비슷한 `sdPrintR7()`을 구현하겠습니다.\n\n```c\n#define CMD_VER(X)          ((X \u003e\u003e 4) \u0026 0xF0)\n#define VOL_ACC(X)          (X \u0026 0x1F)\n\n#define VOLTAGE_ACC_27_33   0b00000001\n#define VOLTAGE_ACC_LOW     0b00000010\n#define VOLTAGE_ACC_RES1    0b00000100\n#define VOLTAGE_ACC_RES2    0b00001000\n\nvoid sdPrintR7(uint8_t *res)\n{\n    sdPrintR1(res[0]);\n\n    if(res[0] \u003e 1) return;\n\n    uartPuts(\"\\tCommand Version: \");\n    uartPutHex8(CMD_VER(res[1]));\n    uartPuts(\"\\r\\n\");\n\n    uartPuts(\"\\tVoltage Accepted: \");\n    if(VOL_ACC(res[3]) == VOLTAGE_ACC_27_33)\n        uartPuts(\"2.7-3.6V\\r\\n\");\n    else if(VOL_ACC(res[3]) == VOLTAGE_ACC_LOW)\n        uartPuts(\"LOW VOLTAGE\\r\\n\");\n    else if(VOL_ACC(res[3]) == VOLTAGE_ACC_RES1)\n        uartPuts(\"RESERVED\\r\\n\");\n    else if(VOL_ACC(res[3]) == VOLTAGE_ACC_RES2)\n        uartPuts(\"RESERVED\\r\\n\");\n    else\n        uartPuts(\"NOT DEFINED\\r\\n\");\n\n    uartPuts(\"\\tEcho: \");\n    uartPutHex8(res[4]);\n    uartPuts(\"\\r\\n\");\n}\n```\n\n# `CMD0`와 `CMD8` 보내기\n\n이제 `CMD0`와 `CMD8`을 SDCard로 보내고 Response를 읽어보겠습니다.\n\n```c\n#define F_CPU 16000000UL\n\nint main(void)\n{\n    // Response를 담을 배열을 선언합니다\n    uint8_t res[5];\n\n    // UART를 초기화 합니다\n    const unsigned int baudRate = (F_CPU / 16 / 9600) - 1;\n    uartInit(baudRate);\n\n    // SPI를 초기화 합니다\n    spiInit();\n\n    // Power Up Sequence를 시작합니다\n    sdPowerUpSeq();\n\n    // CMD0를 SDCard로 전송합니다\n    uartPuts(\"Sending CMD0...\\r\\n\");\n    res[0] = sdGoIdleState();\n    uartPuts(\"Response:\\r\\n\");\n    sdPrintR1(res[0]);\n\n    // CMD8을 SDCard로 전송합니다\n    uartPuts(\"Sending CMD8...\\r\\n\");\n    sdSendIfCond(res);\n    uartPuts(\"Response:\\r\\n\");\n    sdPrintR7(res);\n\n    while(1);\n}\n```\n\nUART를 통해 출력되는 내용은 아래와 같습니다:  \n![UART Output](/assets/image/2022-09-01-AVR-ATmega328P-SDCard-2/AVR-ATmega328P-SDCard-2_4.png)\n\n정상적으로 동작하는 것을 확실하게 보고 싶다면 Logic Analyzer로 `CMD8`에 대한 Output을 확인해 보는 것도 좋습니다.  \n![Logic Analyzer](/assets/image/2022-09-01-AVR-ATmega328P-SDCard-2/AVR-ATmega328P-SDCard-2_5.png)\n\nSDCard에서 받은 응답인 `R7`의 처음 8바이트에서 잘못된 명령으로 출력되지 않았으며, 전압 범위(2.7~3.6V)도 확인했습니다. 또한 Check Pattern인 `0xAA`를 Response에서 받을 수 있었습니다. 모두 정상 작동하는 것을 확인할 수 있습니다.\n\n# `CMD58` (READ_OCR)\n\n이제 다음 단계인 OCR(Operation Conditions Register)를 읽는 `CMD58`를 살펴보겠습니다.  \n![CMD58 Format](/assets/image/2022-09-01-AVR-ATmega328P-SDCard-2/AVR-ATmega328P-SDCard-2_6.png)\n\nArgument는 Stuff Bit이고 CRC는 무시해도 됩니다. Response는 `R3` 형식으로 받으며 아래와 같습니다.  \n![R3 Format](/assets/image/2022-09-01-AVR-ATmega328P-SDCard-2/AVR-ATmega328P-SDCard-2_7.png)\n\n`R7`과 마찬가지로 첫 번째 바이트는 `R1`과 동일하고, 다음 4바이트는 OCR이 담겨있습니다. OCR은 아래와 같이 정의되어 있습니다.  \n![OCR Register Definition](/assets/image/2022-09-01-AVR-ATmega328P-SDCard-2/AVR-ATmega328P-SDCard-2_8.png)\n\nOCR의 Bit 15~24는 SDCard에서 지원하는 전압의 값을 나타냅니다. Bit 31은 SDCard의 Power Up 상태를 나타냅니다. 만약, SDCard가 Power Up Routine을 완료하지 않은 경우에는 LOW로 설정되어 있습니다. 그리고 Bit 30은 Power Up Status(Bit 31)이 Set된 상태에서만 유효한 값을 가지며, SDCard가 고용량(SDHC)인지 확장 용량(SCXC)인지 SDSC인지를 나타냅니다.\n\n`CMD58`에서는 Argument와 CRC가 중요하지 않으므로 모두 `0`으로 설정합니다.\n\n```c\n#define CMD58       58\n#define CMD58_ARG   0x00000000\n#define CMD58_CRC   0x00\n\n// CMD58 전송\nsdCommand(CMD58, CMD58_ARG, CMD_CRC);\n```\n\n# R3 Response\n\n`R3`을 수신하는 함수는 `R7`과 동일합니다. 둘 다 길이가 5바이트이고 `R1`으로 시작하기 때문입니다. 이전에 구현한 `sdReadRes7()`를 재사용하고 아래와 같이 이름을 바꿀 수 있습니다.\n\n```diff\n- void sdReadRes7(uint8_t *res)\n+ void sdReadRes3Res7(uint8_t *res)\n {\n-    // R7에서 R1 Response를 읽습니다\n+    // R1 Response를 읽습니다\n     res[0] = sdReadRes1();\n\n     /*\n       R1 Response에 Error가 존재하면\n       더 이상 진행하지 않고 반환합니다\n     */\n     if(res[0] \u003e 1) return;\n\n     /*\n       R1 Response에 Error가 없다면\n       남은 바이트를 읽습니다\n     */\n     res[1] = spiTransfer(0xFF);\n     res[2] = spiTransfer(0xFF);\n     res[3] = spiTransfer(0xFF);\n     res[4] = spiTransfer(0xFF);\n}\n```\n\n# `CMD58` 함수 구현하기\n\n아래와 같이 `CMD58`을 전송하고, Response를 받는 `sdReadOcr()`를 구현해 봅시다.\n\n```c\nvoid sdReadOcr(uint8_t *res)\n{\n    // SDCard CS Assert\n    spiTransfer(0xFF);\n    CS_ENABLE();\n    spiTransfer(0xFF);\n\n    // CMD58 전송\n    sdCommand(CMD58, CMD58_ARG, CMD58_CRC);\n\n    // Response를 읽습니다\n    sdReadRes3Res7(res);\n\n    // SDCard CS Deassert\n    spiTransfer(0xFF);\n    CS_DISABLE();\n    spiTransfer(0xFF);\n}\n```\n\n# `R3` Response와 OCR 출력하기\n\n`R7`과 마찬가지로 먼저 `R1`을 확인하고 오류가 있으면 나머지 Response의 출력을 건너뜁니다. `R1`에 오류가 없으면 OCR을 출력합니다.\n\n```c\n#define POWER_UP_STATUS(X)  X \u0026 0x40\n#define CCS_VAL(X)          X \u0026 0x40\n#define VDD_2728(X)         X \u0026 0b10000000\n#define VDD_2829(X)         X \u0026 0b00000001\n#define VDD_2930(X)         X \u0026 0b00000010\n#define VDD_3031(X)         X \u0026 0b00000100\n#define VDD_3132(X)         X \u0026 0b00001000\n#define VDD_3233(X)         X \u0026 0b00010000\n#define VDD_3334(X)         X \u0026 0b00100000\n#define VDD_3435(X)         X \u0026 0b01000000\n#define VDD_3536(X)         X \u0026 0b10000000\n\nvoid sdPrintR3(uint8_t *res)\n{\n    sdPrintR1(res[0]);\n\n    if(res[0] \u003e 1) return;\n\n    uartPuts(\"\\tCard Power Up Status: \");\n    if(POWER_UP_STATUS(res[1]))\n    {\n        uartPuts(\"READY\\r\\n\");\n        uartPuts(\"\\tCCS Status: \");\n        if(CCS_VAL(res[1])){ uartPuts(\"1\\r\\n\"); }\n        else uartPuts(\"0\\r\\n\");\n    }\n    else\n    {\n        uartPuts(\"BUSY\\r\\n\");\n    }\n\n    uartPuts(\"\\tVDD Window: \");\n    if(VDD_2728(res[3])) uartPuts(\"2.7-2.8, \");\n    if(VDD_2829(res[2])) uartPuts(\"2.8-2.9, \");\n    if(VDD_2930(res[2])) uartPuts(\"2.9-3.0, \");\n    if(VDD_3031(res[2])) uartPuts(\"3.0-3.1, \");\n    if(VDD_3132(res[2])) uartPuts(\"3.1-3.2, \");\n    if(VDD_3233(res[2])) uartPuts(\"3.2-3.3, \");\n    if(VDD_3334(res[2])) uartPuts(\"3.3-3.4, \");\n    if(VDD_3435(res[2])) uartPuts(\"3.4-3.5, \");\n    if(VDD_3536(res[2])) uartPuts(\"3.5-3.6\");\n    uartPuts(\"\\r\\n\");\n}\n```\n\nPower Up Status가 `1`인 경우에만 CCS를 출력합니다. Power Up Status가 `1`이 아닐 때는 CCS의 값이 유효하지 않기 때문입니다.\n\n# 간단한 CLI 만들기\n\nSDCard를 초기화하고 디버깅하는 방법을 배우는 가장 좋은 방법 중 하나는 CLI 프로그램을 만드는 것입니다. UART를 사용해서 원하는 Command를 SDCard로 보내고 Response를 출력하도록 만들 것입니다. UART에 `0`~`2`가 입력되면 `CMD0`, `CMD8`, `CMD58`을 보낼 것입니다.\n\n```c\n/*\n  CPU의 Frequency를 16MHz로 설정합니다\n*/\n#define F_CPU 16000000UL\n#include \u003cutil/delay.h\u003e\n\nint main(void)\n{\n  uint8_t res[5];\n  char c;\n\n  // UART를 초기화 합니다\n  const unsigned int baudRate = (F_CPU / 16 / 9600) - 1;\n  uartInit(baudRate);\n\n  // SPI를 초기화 합니다\n  spiInit();\n\n  // SDCard에 VCC가 충분히 공급될때까지 기다립니다\n  _delay_ms(10);\n\n  // Power Up Sequence를 시작합니다\n  sdPowerUpSeq();\n\n  while (1)\n  {\n    // 메뉴를 출력합니다\n    uartPuts(\"MENU\\r\\n\");\n    uartPuts(\"------------------\\r\\n\");\n    uartPuts(\"0 - Send CMD0\\r\\n1 - Send CMD8\\r\\n2 - Send CMD58\\r\\n\");\n    uartPuts(\"------------------\\r\\n\");\n\n    // 사용자에게 명령(문자)를 입력받습니다\n    c = uartGet();\n\n    if (c == '0')\n    {\n      // CMD0을 보내고 응답을 읽습니다\n      uartPuts(\"Sending CMD0...\\r\\n\");\n      CS_ENABLE();\n      sdCommand(CMD0, CMD0_ARG, CMD0_CRC);\n      res[0] = sdReadRes1();\n      CS_DISABLE();\n      spiTransfer(0xFF);\n\n      // R1 출력\n      uartPuts(\"Response: \\r\\n\");\n      sdPrintR1(res[0]);\n    }\n    else if (c == '1')\n    {\n      // CMD8을 보내고 응답을 읽습니다\n      uartPuts(\"Sending CMD8...\\r\\n\");\n      CS_ENABLE();\n      sdCommand(CMD8, CMD8_ARG, CMD8_CRC);\n      sdReadRes3Res7(res);\n      CS_DISABLE();\n      spiTransfer(0xFF);\n\n      // R7 출력\n      uartPuts(\"Response: \\r\\n\");\n      sdPrintR7(res);\n    }\n    else if (c == '2')\n    {\n      // CMD58을 보내고 응답을 읽습니다.\n      uartPuts(\"Sending CMD58...\\r\\n\");\n      CS_ENABLE();\n      sdCommand(CMD58, CMD58_ARG, CMD58_CRC);\n      sdReadRes3Res7(res);\n      CS_DISABLE();\n      spiTransfer(0xFF);\n\n      // R3 출력\n      uartPuts(\"Response: \\r\\n\");\n      sdPrintR3(res);\n    }\n    else\n    {\n      uartPuts(\"Unrecognized command\\r\\n\");\n    }\n  }\n}\n```\n\nSDCard의 초기화 과정과 같이 `CMD0`, `CMD8`, `CMD58`을 `0`, `1`, `2`를 차례대로 입력하여 전송해 봅시다. 그러면 아래와 같이 출력됩니다.  \n![SDCard CLI](/assets/image/2022-09-01-AVR-ATmega328P-SDCard-2/AVR-ATmega328P-SDCard-2_9.png)\n\n`CMD58`의 Response를 보면, SDCard가 2.7~3.6V 사이의 모든 전압을 지원하며, Power Up Status는 BUSY 상태입니다. (CCS가 없다는 것을 의미합니다). 만약 여기서 카드가 지원하지 않는 전압 값을 반환하면 사용할 수 없는 SDCard라고 볼 수 있습니다. 다행이게도 제가 사용한 SDCard는 실행 중인 값인 3.3V를 지원하기 때문에 초기화 과정을 계속 진행할 수 있습니다.\n"},"__N_SSG":true},"page":"/article/[category]/[year]/[month]/[day]/[slug]","query":{"category":"avr","year":"2022","month":"09","day":"01","slug":"AVR-ATmega328P-SDCard-2"},"buildId":"QV7HAc_WM_SwrI_XVNTV_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>