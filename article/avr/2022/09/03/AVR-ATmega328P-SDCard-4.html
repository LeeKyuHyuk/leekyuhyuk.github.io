<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta property="og:image" content="https://kyuhyuk.kr/thumbnail.png"/><title>[AVR] ATmega328P SDCard 구현 (4)</title><meta name="author" content="KyuHyuk Lee"/><meta name="generator" content="KyuHyuk Lee"/><meta name="description" content=" 이전 글 에서 SDCard 초기화 과정을 구현했습니다. 이 글에서는 SDCard에 데이터를 읽고 쓰는 방법을 구현합니다. CMD16 (SET_BLOCKLEN) SDCard의 읽기 및 쓰기 작업은 설정된 길이의 블록으로 수행됩니다. 블록 길이는 CMD16 을 사용해서 설정할 수 있습니다"/><meta itemProp="url" content="https://kyuhyuk.kr/article/avr/2022/09/03/AVR-ATmega328P-SDCard-4"/><meta itemProp="headline" content="[AVR] ATmega328P SDCard 구현 (4)"/><meta property="og:type" content="article"/><meta property="og:url" content="https://kyuhyuk.kr/article/avr/2022/09/03/AVR-ATmega328P-SDCard-4"/><meta property="og:title" content="[AVR] ATmega328P SDCard 구현 (4)"/><meta property="og:description" content=" 이전 글 에서 SDCard 초기화 과정을 구현했습니다. 이 글에서는 SDCard에 데이터를 읽고 쓰는 방법을 구현합니다. CMD16 (SET_BLOCKLEN) SDCard의 읽기 및 쓰기 작업은 설정된 길이의 블록으로 수행됩니다. 블록 길이는 CMD16 을 사용해서 설정할 수 있습니다"/><meta property="og:site_name" content="KyuHyuk Blog"/><meta property="og:locale" content="ko_KR"/><meta name="next-head-count" content="15"/><style id="stitches">--sxs{--sxs:2 c-opBYf c-bHyrwK c-uBnvQ c-hehuMV c-bjkCdF c-hAoZGi c-jfcKOQ c-ezyKJG c-iAzQif c-bvdusc c-ezRQNp c-iosjjB c-jYwCTI c-iOPkYY c-cpkrrK c-fiqONv c-iUFgVP c-cshSRb c-fxvkZv c-dIcdES}@media{.c-opBYf{display:flex;align-items:center;background:#FFFFFF;height:60px;justify-content:space-between;-webkit-box-align:center;-webkit-box-pack:justify}.c-bHyrwK{display:flex;align-items:center;justify-content:center;-webkit-box-align:center;-webkit-box-pack:center}.c-uBnvQ{width:32px;height:32px;color:#FFFFFF;background:#000000;border-radius:4px;display:flex;align-items:center;justify-content:center;margin-right:12px;font-weight:700;cursor:default;-webkit-box-align:center;-webkit-box-pack:center}.c-hehuMV{font-weight:900;font-size:18px;letter-spacing:0.5px;color:#000000;cursor:default}.c-bjkCdF{list-style:none;padding:0;margin:0;display:flex;justify-content:center;align-items:center;font-size:24px;color:rgb(134, 142, 150);transition:all 0.3s ease 0s;-webkit-box-pack:center;-webkit-box-align:center}.c-hAoZGi{font-size:28px;color:inherit;text-decoration:none;margin:8px}.c-jfcKOQ{max-width:768px;margin-top:2rem;margin-left:auto;margin-right:auto}.c-ezyKJG{min-width:72px;display:flex;flex-direction:row;justify-content:center;align-items:center;padding:6px 16px;background:#12B886;box-shadow:0px 1px 2px rgba(98, 16, 204, 0.3);border:none;border-radius:14px;vertical-align:middle;color:#FFFFFF;font-size:1rem;height:2rem;float:right}.c-iAzQif{display:inline-block;margin-top:2rem}.c-bvdusc{font-size:2rem;line-height:1.5;letter-spacing:-0.004em;margin-top:0;margin-bottom:2rem;font-weight:700;color:#212529;word-break:keep-all;transition:color 0.125s ease-in 0s;}.c-ezRQNp{font-size:1.125rem;color:#212529;transition:color 0.125s ease-in 0s;;line-height:1.7;letter-spacing:-0.004em;word-break:break-all;overflow-wrap:break-word}.c-iosjjB{background:#F8F9FA;padding:0 1rem;height:2rem;border-radius:1rem;display:inline-flex;align-items:center;margin-right:0.875rem;color:#12B886;text-decoration:none;font-weight:400;font-size:1rem}.c-jYwCTI{font-size:1rem;color:#495057}.c-iOPkYY{margin-top:3rem;background-color:rgba(51,51,51,.1);border:0;height:1px}.c-cpkrrK{width:100%;height:300px;display:flex;align-items:center;justify-content:center;flex-direction:column;-webkit-box-align:center;-webkit-box-pack:center}.c-fiqONv{color:rgb(206, 212, 218);margin-bottom:8px;font-size:22px;font-weight:700}.c-iUFgVP{width:32px;height:32px;color:#FFFFFF;background:rgb(206, 212, 218);border-radius:4px;display:flex;align-items:center;justify-content:center;margin-right:12px;font-weight:700;cursor:default;-webkit-box-align:center;-webkit-box-pack:center}.c-cshSRb{font-weight:900;font-size:18px;letter-spacing:0.5px;color:rgb(206, 212, 218);cursor:default;text-transform:uppercase}.c-fxvkZv{font-size:2.5rem;line-height:1.5;letter-spacing:-0.004em;margin-top:0;margin-bottom:2rem;font-weight:700;color:#212529;word-break:keep-all;transition:color 0.125s ease-in 0s;}.c-dIcdES{margin-top:2rem;font-size:1.125rem;color:#212529;transition:color 0.125s ease-in 0s;;line-height:1.7;letter-spacing:-0.004em;word-break:keep-all;overflow-wrap:break-word}}</style><link rel="preload" href="/_next/static/css/98b299b94b0a7962.css" as="style"/><link rel="stylesheet" href="/_next/static/css/98b299b94b0a7962.css" data-n-g=""/><link rel="preload" href="/_next/static/css/c2a527101433f11d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c2a527101433f11d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-c354a30bda3d62a6.js" defer=""></script><script src="/_next/static/chunks/pages/_app-8265bb1a072646d3.js" defer=""></script><script src="/_next/static/chunks/776-f277552409ab147f.js" defer=""></script><script src="/_next/static/chunks/305-e325b960616dc0fd.js" defer=""></script><script src="/_next/static/chunks/pages/article/%5Bcategory%5D/%5Byear%5D/%5Bmonth%5D/%5Bday%5D/%5Bslug%5D-aa033f8eb8939164.js" defer=""></script><script src="/_next/static/cYbDaMF1ARyMLu5tcmUx6/_buildManifest.js" defer=""></script><script src="/_next/static/cYbDaMF1ARyMLu5tcmUx6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="c-opBYf"><a href="https://kyuhyuk.kr"><div class="c-bHyrwK"><div class="c-uBnvQ">Kh.</div><div class="c-hehuMV">KyuHyuk Blog</div></div></a><ul class="c-bjkCdF"><li><a href="https://github.com/LeeKyuHyuk" class="c-hAoZGi"><span role="img" aria-label="github" class="anticon anticon-github"><svg viewBox="64 64 896 896" focusable="false" data-icon="github" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0138.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"></path></svg></span></a></li><li><a href="https://linkedin.com/in/leekyuhyuk" class="c-hAoZGi"><span role="img" aria-label="linkedin" class="anticon anticon-linkedin"><svg viewBox="64 64 896 896" focusable="false" data-icon="linkedin" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zM349.3 793.7H230.6V411.9h118.7v381.8zm-59.3-434a68.8 68.8 0 1168.8-68.8c-.1 38-30.9 68.8-68.8 68.8zm503.7 434H675.1V608c0-44.3-.8-101.2-61.7-101.2-61.7 0-71.2 48.2-71.2 98v188.9H423.7V411.9h113.8v52.2h1.6c15.8-30 54.5-61.7 112.3-61.7 120.2 0 142.3 79.1 142.3 181.9v209.4z"></path></svg></span></a></li><li><a href="mailto:lee@kyuhyuk.kr" class="c-hAoZGi"><span role="img" aria-label="mail" class="anticon anticon-mail"><svg viewBox="64 64 896 896" focusable="false" data-icon="mail" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-80.8 108.9L531.7 514.4c-7.8 6.1-18.7 6.1-26.5 0L189.6 268.9A7.2 7.2 0 01194 256h648.8a7.2 7.2 0 014.4 12.9z"></path></svg></span></a></li></ul></header><main class="c-jfcKOQ"><article><h1 class="c-fxvkZv"><a href="https://kyuhyuk.kr/article/avr/2022/09/03/AVR-ATmega328P-SDCard-4">[AVR] ATmega328P SDCard 구현 (4)</a></h1><a href="https://kyuhyuk.kr/category/AVR" class="c-iosjjB">AVR</a><time dateTime="2022-09-03 04:32:01" class="c-jYwCTI">Sep 03, 2022 04:32:01 AM</time><div id="post" class="c-dIcdES"><p><a href="https://kyuhyuk.kr/article/avr/2022/09/02/AVR-ATmega328P-SDCard-3">이전 글</a>에서 SDCard 초기화 과정을 구현했습니다. 이 글에서는 SDCard에 데이터를 읽고 쓰는 방법을 구현합니다.</p>
<h1><code>CMD16</code> (SET_BLOCKLEN)</h1>
<p>SDCard의 읽기 및 쓰기 작업은 설정된 길이의 블록으로 수행됩니다. 블록 길이는 <code>CMD16</code>을 사용해서 설정할 수 있습니다. 이 글에서는 블록 길이가 항상 512바이트로 설정되는 SDHC와 SDXC만 고려합니다.</p>
<h1><code>CMD17</code> (READ_SINGLE_BLOCK)</h1>
<p><code>CMD17</code>(READ_SINGLE_BLOCK)은 단일 블록 읽기 명령입니다. <code>CMD17</code>의 형식은 아래와 같습니다.</p>
<p><img src="/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_1.png" alt="CMD17 Format"></p>
<p>Argument에 SDCard에서 읽을 주소를 지정해야 합니다. SDHC와 SDXC는 블록 주소로 지정됩니다. 예를 들어 주소를 <code>0</code>으로 설정하면 <code>0</code>~<code>511</code> 바이트를 읽어 오고, 주소를 <code>1</code>으로 설정하면 <code>512</code>~<code>1023</code> 바이트를 읽어 옵니다. 32비트를 사용했을 때 SDCard에서 읽을 수 있는 최대 크기는 <code>(2^32)*512 = 2048MB</code> 또는 <code>2TB</code>입니다.</p>
<p>단일 블록을 읽어오는 과정은 아래 다이어그램을 참고하세요.</p>
<p><img src="/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_2.png" alt="Single Block Read Operation"></p>
<p><code>CMD17</code>이 전송되면 <code>R1</code>으로 응답하고 데이터 블록이 CRC와 함께 옵니다. <code>R1</code> Response를 보내는 것과 첫 번째 데이터 바이트 사이에 시간이 걸릴 수도 있습니다. 데이터가 실제로 시작되는 시점은 단일 데이터 블록일 경우에는 시작 토큰인 <code>0xFE</code>(<code>11111110b</code>)가 먼저 옵니다.</p>
<p><img src="/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_3.png" alt="Single Block - Start Token"></p>
<p>시작 토큰과 함께 SDCard는 블록 길이(SDHC와 SDXC는 항상 512바이트) 만큼 데이터를 보냅니다. 그다음에 16비트의 CRC가 옵니다.</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD17                   17</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD17_CRC               0x00</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SD_MAX_READ_ATTEMPTS    1563</span>

<span class="hljs-comment">/*
  512바이트 단일 블록을 읽습니다
  token = 0xFE // 읽기 성공
  token = 0x0X // 데이터 에러
  token = 0xFF // 타임아웃
*/</span>
<span class="hljs-type">uint8_t</span> <span class="hljs-title function_">sdReadSingleBlock</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> addr, <span class="hljs-type">uint8_t</span> *buf, <span class="hljs-type">uint8_t</span> *token)</span>
{
    <span class="hljs-type">uint8_t</span> res1, read;
    <span class="hljs-type">uint16_t</span> readAttempts;

    <span class="hljs-comment">// Token을 초기화 합니다</span>
    *token = <span class="hljs-number">0xFF</span>;

    <span class="hljs-comment">// SDCard CS Assert</span>
    spiTransfer(<span class="hljs-number">0xFF</span>);
    CS_ENABLE();
    spiTransfer(<span class="hljs-number">0xFF</span>);

    <span class="hljs-comment">// CMD17 전송</span>
    sdCommand(CMD17, addr, CMD17_CRC);

    <span class="hljs-comment">// Response를 읽습니다</span>
    res1 = sdReadRes1();

    <span class="hljs-comment">// SDCard에서 Response를 받은 경우</span>
    <span class="hljs-keyword">if</span>(res1 != <span class="hljs-number">0xFF</span>)
    {
        <span class="hljs-comment">// Response Token을 기다립니다 (Timeout은 100ms 입니다)</span>
        readAttempts = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(++readAttempts != SD_MAX_READ_ATTEMPTS)
            <span class="hljs-keyword">if</span>((read = spiTransfer(<span class="hljs-number">0xFF</span>)) != <span class="hljs-number">0xFF</span>) <span class="hljs-keyword">break</span>;

        <span class="hljs-comment">// Response Token이 0xFE(시작 토큰)인 경우</span>
        <span class="hljs-keyword">if</span>(read == <span class="hljs-number">0xFE</span>)
        {
            <span class="hljs-comment">// 512바이트의 블록을 읽습니다</span>
            <span class="hljs-keyword">for</span>(<span class="hljs-type">uint16_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">512</span>; i++) *buf++ = spiTransfer(<span class="hljs-number">0xFF</span>);

            <span class="hljs-comment">// 16비트의 CRC를 읽습니다</span>
            spiTransfer(<span class="hljs-number">0xFF</span>);
            spiTransfer(<span class="hljs-number">0xFF</span>);
        }

        <span class="hljs-comment">// Token을 SDCard의 Response로 설정합니다</span>
        *token = read;
    }

    <span class="hljs-comment">// SDCard CS Deassert</span>
    spiTransfer(<span class="hljs-number">0xFF</span>);
    CS_DISABLE();
    spiTransfer(<span class="hljs-number">0xFF</span>);

    <span class="hljs-keyword">return</span> res1;
}
</code></pre>
<p><code>sdReadSingleBlock()</code>는 32비트의 <code>addr</code>을 Argumemt로 사용하고, 데이터를 저장하기 위해 최소 512바이트의 버퍼(<code>buf</code>)가 필요합니다. 데이터 토큰을 저장하는 데 사용할 8비트 값에 대한 포인터(<code>token</code>)도 함께 전달합니다.</p>
<p><code>R1</code>을 읽을 후 비어 있지 않은 경우(카드가 명령에 응답한 경우) 토큰을 받거나 Timeout까지 SDCard를 계속 폴링 합니다.</p>
<pre><code class="language-c"><span class="hljs-comment">// SDCard에서 Response를 받은 경우</span>
    <span class="hljs-keyword">if</span>(res1 != <span class="hljs-number">0xFF</span>)
    {
        <span class="hljs-comment">// Response Token을 기다립니다 (Timeout은 100ms 입니다)</span>
        readAttempts = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(++readAttempts != SD_MAX_READ_ATTEMPTS)
            <span class="hljs-keyword">if</span>((read = spiTransfer(<span class="hljs-number">0xFF</span>)) != <span class="hljs-number">0xFF</span>) <span class="hljs-keyword">break</span>;
    }
</code></pre>
<p><a href="/assets/file/2022-08-28-AVR-ATmega328P-SDCard-1/Part_1_Physical_Layer_Simplified_Specification_Ver2.00_060925.pdf">SDCard Physical Specification</a>의 4.6.2.1 섹션을 보면 아래와 같은 내용이 있습니다:</p>
<blockquote>
<p>Host는 단일 및 다중 읽기 작업에 대해 최소 100ms의 Timeout을 사용해야 합니다.</p>
</blockquote>
<p>우리의 환경은 16MHz의 발진기(Oscillator)를 사용하고 SPI의 클럭을 128로 나누도록 설정했습니다. 따라서 100ms을 만족하기 위해 SPI를 통해 보내야 하는 바이트의 개수를 얻으려면 아래와 같이 계산할 수 있습니다.</p>
<p><code>(0.1s * 16000000 Hz) / (128 * 8 Bytes) = 1562.5 ≈ 1563</code></p>
<p>시작 토큰을 받으면 버퍼에 512바이트를 넣고, 16비트 CRC를 읽습니다.</p>
<pre><code class="language-c"><span class="hljs-comment">// Response Token이 0xFE(시작 토큰)인 경우</span>
<span class="hljs-keyword">if</span>(read == <span class="hljs-number">0xFE</span>)
{
    <span class="hljs-comment">// 512바이트의 블록을 읽습니다</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">uint16_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">512</span>; i++) *buf++ = spiTransfer(<span class="hljs-number">0xFF</span>);

    <span class="hljs-comment">// 16비트의 CRC를 읽습니다</span>
    spiTransfer(<span class="hljs-number">0xFF</span>);
    spiTransfer(<span class="hljs-number">0xFF</span>);
}
</code></pre>
<p>시작 토큰을 받지 못하면 SDCard에서 블록을 읽으려고 시도하지 않습니다. 토큰이 <code>0xFF</code> 이면 SDCard에서 아무것도 수신하지 못한 것입니다. 이럴 경우에는 Timeout이 발생하게 됩니다. 만약 이런 경우가 아니라면 오류 토큰을 수신해야 합니다. 오류 토큰을 수신하는 부분은 나중에 다시 자세하게 설명하겠습니다.</p>
<h1>테스트 해보기</h1>
<p><a href="https://kyuhyuk.kr/article/avr/2022/09/02/AVR-ATmega328P-SDCard-3">이전 글</a>의 초기화 코드를 사용하여 SDCard에서 맨 처음 블록을 읽어 보겠습니다.</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SD_R1_NO_ERROR(X)   X &lt; 0x02</span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
  <span class="hljs-comment">// Response를 담을 배열을 선언합니다</span>
  <span class="hljs-type">uint8_t</span> res[<span class="hljs-number">5</span>], sdBuf[<span class="hljs-number">512</span>], token;

  <span class="hljs-comment">// UART를 초기화 합니다</span>
  <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> baudRate = (F_CPU / <span class="hljs-number">16</span> / <span class="hljs-number">9600</span>) - <span class="hljs-number">1</span>;
  uartInit(baudRate);

  <span class="hljs-comment">// SPI를 초기화 합니다</span>
  spiInit();

  <span class="hljs-comment">// SDCard를 초기화 합니다</span>
  <span class="hljs-keyword">if</span> (sdInit() != SD_SUCCESS)
  {
    uartPuts(<span class="hljs-string">&quot;Error initializaing SD CARD\r\n&quot;</span>);
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)
      ;
  }
  <span class="hljs-keyword">else</span>
  {
    uartPuts(<span class="hljs-string">&quot;SD Card initialized\r\n&quot;</span>);

    <span class="hljs-comment">// Sector 0을 읽습니다</span>
    res[<span class="hljs-number">0</span>] = sdReadSingleBlock(<span class="hljs-number">0x00000000</span>, sdBuf, &amp;token);

    <span class="hljs-comment">// Response를 출력합니다</span>
    <span class="hljs-keyword">if</span> (SD_R1_NO_ERROR(res[<span class="hljs-number">0</span>]) &amp;&amp; (token == <span class="hljs-number">0xFE</span>))
    {
      <span class="hljs-keyword">for</span> (<span class="hljs-type">uint16_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">512</span>; i++)
      {
        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">32</span> == <span class="hljs-number">0</span>)
          uartPuts(<span class="hljs-string">&quot;\r\n&quot;</span>);
        uartPutHex8(sdBuf[i]);
      }
      uartPuts(<span class="hljs-string">&quot;\r\n&quot;</span>);
    }
    <span class="hljs-keyword">else</span>
    {
      uartPuts(<span class="hljs-string">&quot;Error reading sector\r\n&quot;</span>);
    }
  }

  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)
    ;
}
</code></pre>
<p>UART에 아래와 같이 출력됩니다:<br>
<img src="/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_4.png" alt="UART - Read Single Block"></p>
<p>마지막 2개의 바이트 <code>0x55</code>와 <code>0xAA</code>는 MBR에 있는 Boot Signature 입니다. SDCard를 읽기 전에 PC에서 이미 포맷한 경우에는 2개의 바이트는 동일하게 표시될 것입니다.</p>
<p>Logic Analyzer로 보면, <code>R1</code>에서 데이터 블록 전송을 하는 부분은 아래와 같이 보일 것입니다.<br>
<img src="/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_5.png" alt="Logic Analyzer - Read Single Block"></p>
<p>위의 스크린샷을 보면 시작 토큰을 보내기 전에 5바이트 동안은 SDCard는 IDLE 상태였습니다. (시작 토큰이 없으면 SDCard가 IDLE 상태인지 모두 <code>1</code>인 데이터인지를 구분할 수 없습니다)</p>
<h1>Read Errors</h1>
<p>SDCard가 요청된 데이터를 찾을 수 없는 경우에는 데이터 시작 토큰 대신 데이터 오류 토큰을 보냅니다. 이 과정은 아래 다이어그램에서 볼 수 있습니다.</p>
<p><img src="/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_6.png" alt="Read Operation - Data Error"></p>
<p>데이터 오류 토큰의 형식은 아래와 같습니다.</p>
<p><img src="/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_7.png" alt="Data Error Token"></p>
<p>먼저 오류 토큰을 출력하는 <code>sdPrintDataErrToken()</code>을 작성하겠습니다:</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SD_TOKEN_OOR(X)     X &amp; 0b00001000</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SD_TOKEN_CECC(X)    X &amp; 0b00000100</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SD_TOKEN_CC(X)      X &amp; 0b00000010</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SD_TOKEN_ERROR(X)   X &amp; 0b00000001</span>

<span class="hljs-type">void</span> <span class="hljs-title function_">sdPrintDataErrToken</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> token)</span>
{
    <span class="hljs-keyword">if</span>(SD_TOKEN_OOR(token))
        uartPuts(<span class="hljs-string">&quot;\tData out of range\r\n&quot;</span>);
    <span class="hljs-keyword">if</span>(SD_TOKEN_CECC(token))
        uartPuts(<span class="hljs-string">&quot;\tCard ECC failed\r\n&quot;</span>);
    <span class="hljs-keyword">if</span>(SD_TOKEN_CC(token))
        uartPuts(<span class="hljs-string">&quot;\tCC Error\r\n&quot;</span>);
    <span class="hljs-keyword">if</span>(SD_TOKEN_ERROR(token))
        uartPuts(<span class="hljs-string">&quot;\tError\r\n&quot;</span>);
}
</code></pre>
<p>SDCard의 범위를 벗어난 메모리 위치에 접근하려고 하면, 아마 데이터 토큰이 아닌 오류 토큰을 받게 될 것입니다. 메모리 주소 <code>0xFFFFFFFF</code>에 접근해 보겠습니다. 2TB의 SDCard가 아니라면 오류가 발생할 것입니다.</p>
<pre><code class="language-c"><span class="hljs-type">uint8_t</span> res, sdBuf[<span class="hljs-number">512</span>], token;
res = sdReadSingleBlock(<span class="hljs-number">0xffffffff</span>, sdBuf, &amp;token);

uartPuts(<span class="hljs-string">&quot;Response 1:\r\n&quot;</span>);
sdPrintR1(res);

<span class="hljs-comment">// 오류 토큰을 수신했을때</span>
<span class="hljs-keyword">if</span>(!(token &amp; <span class="hljs-number">0xF0</span>))
{
    uartPuts(<span class="hljs-string">&quot;Error token:\r\n&quot;</span>);
    sdPrintDataErrToken(token);
}
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(token == <span class="hljs-number">0xFF</span>)
{
    uartPuts(<span class="hljs-string">&quot;Timeout\r\n&quot;</span>);
}
</code></pre>
<p>다음은 UART를 통해 출력되는 내용입니다.<br>
<img src="/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_8.png" alt="SanDisk SDCard"></p>
<p><code>R1</code>에서 주소 오류가 있다고 출력합니다. 하지만, 오류 토큰은 보이지 않습니다.</p>
<p>사실 이 동작은 SDCard마다 다르게 응답합니다. 방금 UART로 출력된 내용은 SanDisk SDCard에서 출력되었습니다. 만약 Samsung SDCard에서 동일한 코드를 실행하면 아래와 같이 출력됩니다.<br>
<img src="/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_9.png" alt="Samsung SDCard"></p>
<p>혹시 코드가 잘못되었나 확인하기 위해 Logic Analyzer로 확인해 봤지만, 제가 가진 SDCard에서는 오류 토큰을 받은 적이 없으며 ~100ms 후에 Timeout이 되었습니다.<br>
<img src="/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_10.png" alt="Logic Analyzer - Read Single Block"></p>
<h1><code>CMD24</code> (WRITE_BLOCK)</h1>
<p>읽기와 마찬가지로 쓰기도 512바이트 블록에서 수행됩니다. <code>CMD24</code>를 사용하여 쓰기를 수행합니다. 이 명령의 형식은 아래와 같습니다.</p>
<p><img src="/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_11.png" alt="CMD24"></p>
<p>단일 블록에 쓰는 방법은 아래와 같습니다.</p>
<p><img src="/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_12.png" alt="Single Block Write Operation"></p>
<p><code>CMD24</code>를 보내고 Response(<code>R1</code>)을 기다린 다음, Start Block Token(<code>0xFE</code>)를 보내고 쓸 데이터 512바이트를 보냅니다. 그리고 SDCard에서 새로운 유형의 토큰인 Data Response Token을 기다립니다. Data Response Token의 형식은 아래와 같습니다.</p>
<p><img src="/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_13.png" alt="Data Response Token"></p>
<p>SDCard가 데이터를 수락하면 Token <code>xxx00101b</code>를 받게 됩니다. SDCard는 데이터 쓰기 작업이 완료될 때까지 Busy Token인 <code>0x00</code>을 보냅니다.</p>
<p>방금 설명한 내용을 바탕으로 <code>sdWriteSingleBlock()</code>를 작성해 보겠습니다.</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD24                   24</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD24_ARG               0x00</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD24_CRC               0x00</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SD_MAX_WRITE_ATTEMPTS   3907</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SD_BLOCK_LEN            512</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SD_START_TOKEN          0xFE</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SD_ERROR_TOKEN          0x00</span>

<span class="hljs-comment">/*
  512바이트 단일 블록을 기록합니다
  token = 0x00 // Busy 타임아웃
  token = 0x05 // 데이터 수락
  token = 0xFF // 응답 타임아웃
*/</span>
<span class="hljs-type">uint8_t</span> <span class="hljs-title function_">sdWriteSingleBlock</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> addr, <span class="hljs-type">uint8_t</span> *buf, <span class="hljs-type">uint8_t</span> *token)</span>
{
    <span class="hljs-type">uint8_t</span> res1;
    <span class="hljs-type">uint8_t</span> readAttempts, read;

    <span class="hljs-comment">// Token을 초기화 합니다</span>
    *token = <span class="hljs-number">0xFF</span>;

    <span class="hljs-comment">// SDCard CS Assert</span>
    spiTransfer(<span class="hljs-number">0xFF</span>);
    CS_ENABLE();
    spiTransfer(<span class="hljs-number">0xFF</span>);

    <span class="hljs-comment">// CMD24 전송</span>
    sdCommand(CMD24, addr, CMD24_CRC);

    <span class="hljs-comment">// Response를 읽습니다</span>
    res1 = sdReadRes1();

    <span class="hljs-comment">// Response에 오류가 없는 경우</span>
    <span class="hljs-keyword">if</span>(res1 == SD_READY)
    {
        <span class="hljs-comment">// Start Token을 전송합니다</span>
        spiTransfer(SD_START_TOKEN);

        <span class="hljs-comment">// Buffer의 내용을 전송합니다</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-type">uint16_t</span> i = <span class="hljs-number">0</span>; i &lt; SD_BLOCK_LEN; i++) spiTransfer(buf[i]);

        <span class="hljs-comment">// Response를 기다립니다 (Timeout = 250ms)</span>
        readAttempts = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(++readAttempts != SD_MAX_WRITE_ATTEMPTS)
            <span class="hljs-keyword">if</span>((read = spiTransfer(<span class="hljs-number">0xFF</span>)) != <span class="hljs-number">0xFF</span>) { *token = <span class="hljs-number">0xFF</span>; <span class="hljs-keyword">break</span>; }

        <span class="hljs-comment">// 데이터가 수락되면 실행합니다</span>
        <span class="hljs-keyword">if</span>((read &amp; <span class="hljs-number">0x1F</span>) == <span class="hljs-number">0x05</span>)
        {
            <span class="hljs-comment">// Token을 &#x27;데이터 수락&#x27;으로 설정</span>
            *token = <span class="hljs-number">0x05</span>;

            <span class="hljs-comment">// 쓰기 작업이 끝날때까지 기다립니다 (Timeout = 250ms)</span>
            readAttempts = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">while</span>(spiTransfer(<span class="hljs-number">0xFF</span>) == <span class="hljs-number">0x00</span>)
                <span class="hljs-keyword">if</span>(++readAttempts == SD_MAX_WRITE_ATTEMPTS) { *token = <span class="hljs-number">0x00</span>; <span class="hljs-keyword">break</span>; }
        }
    }

    <span class="hljs-comment">// SDCard CS Deassert</span>
    spiTransfer(<span class="hljs-number">0xFF</span>);
    CS_DISABLE();
    spiTransfer(<span class="hljs-number">0xFF</span>);

    <span class="hljs-keyword">return</span> res1;
}
</code></pre>
<p>읽기 작업과 마찬가지로 타임아웃 값을 설정합니다. <a href="/assets/file/2022-08-28-AVR-ATmega328P-SDCard-1/Part_1_Physical_Layer_Simplified_Specification_Ver2.00_060925.pdf">SDCard Physical Specification</a>의 4.6.2.2 섹션을 보면 모든 쓰기 작업에 대해 타임아웃은 250ms로 정의해야 한다고 언급하고 있습니다. <code>(0.25s * 16000000 Hz) / (128 * 8 Bytes) = 3906.25</code>이지만, <code>3907</code>로 250ms보다 조금 크게 설정했습니다.</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SD_MAX_WRITE_ATTEMPTS   3907</span>
</code></pre>
<p><code>CMD24</code>(쓰기 명령)을 SDCard에 보내고 <code>R1</code> Response에 오류가 없는지 확인합니다.</p>
<pre><code class="language-c"><span class="hljs-comment">// CMD24 전송</span>
sdCommand(CMD24, addr, CMD24_CRC);

<span class="hljs-comment">// Response를 읽습니다</span>
res[<span class="hljs-number">0</span>] = sdReadRes1();

<span class="hljs-comment">// Response에 오류가 없는 경우</span>
<span class="hljs-keyword">if</span>(res[<span class="hljs-number">0</span>] == SD_READY)
{
    <span class="hljs-comment">/* ... */</span>
}
</code></pre>
<p><code>R1</code>에 오류가 없으면 Start Token을 보낸 다음 Buffer에서 데이터 전송을 시작합니다.</p>
<pre><code class="language-c"><span class="hljs-comment">// Start Token을 전송합니다</span>
spiTransfer(SD_START_TOKEN);

<span class="hljs-comment">// Buffer의 내용을 전송합니다</span>
<span class="hljs-keyword">for</span>(<span class="hljs-type">uint16_t</span> i = <span class="hljs-number">0</span>; i &lt; SD_BLOCK_LEN; i++) spiTransfer(buf[i]);
</code></pre>
<p>Buffer의 내용을 전송하는 작업이 끝나면, SDCard가 Data Response Token을 보낼 때까지 기다립니다. 데이터 수락 토큰은 <code>xxx00101b</code> 입니다.</p>
<pre><code class="language-c"><span class="hljs-comment">// Response를 기다립니다 (Timeout = 250ms)</span>
readAttempts = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span>(++readAttempts != SD_MAX_WRITE_ATTEMPTS)
    <span class="hljs-keyword">if</span>((read = spiTransfer(<span class="hljs-number">0xFF</span>)) != <span class="hljs-number">0xFF</span>) { *token = <span class="hljs-number">0xFF</span>; <span class="hljs-keyword">break</span>; }

<span class="hljs-comment">// 데이터가 수락되면 실행합니다</span>
<span class="hljs-keyword">if</span>((read &amp; <span class="hljs-number">0x1F</span>) == <span class="hljs-number">0x05</span>)
{
    <span class="hljs-comment">/* ... */</span>
}
</code></pre>
<p>마지막으로 SDCard가 데이터를 쓰는 것을 완료할 때까지 기다립니다.</p>
<pre><code class="language-c"><span class="hljs-comment">// 쓰기 작업이 끝날때까지 기다립니다 (Timeout = 250ms)</span>
readAttempts = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span>(spiTransfer(<span class="hljs-number">0xFF</span>) == <span class="hljs-number">0x00</span>)
    <span class="hljs-keyword">if</span>(++readAttempts == SD_MAX_WRITE_ATTEMPTS) { *token = <span class="hljs-number">0x00</span>; <span class="hljs-keyword">break</span>; }
</code></pre>
<p>이제 간단한 데이터를 한번 기록해 봅시다. <code>0x55</code>로 만 이루어진 버퍼를 SDCard의 <code>0x00000100</code>에 써보겠습니다.</p>
<pre><code class="language-c"><span class="hljs-comment">// 0x55로 버퍼를 채웁니다</span>
<span class="hljs-keyword">for</span>(<span class="hljs-type">uint16_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">512</span>; i++) buf[i] = <span class="hljs-number">0x55</span>;

<span class="hljs-comment">// 주소 0x100 (256)에 0x55를 기록합니다</span>
res = sdWriteSingleBlock(<span class="hljs-number">0x00000100</span>, buf, &amp;token);
</code></pre>
<p>위의 코드를 실행해 보면 아래와 같이 <code>0x00</code>으로 채워져있던 <code>0x00000100</code>에 <code>0x55</code>가 기록된 것을 볼 수 있습니다.<br>
<img src="/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_14.png" alt="sdWriteSingleBlock UART"></p>
<p>Logic Analyzer로 확인해 보면 <code>R1</code>으로 응답한 뒤 바로 시작 토큰을 보내고, 기록할 데이터 전송을 시작합니다.<br>
<img src="/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_15.png" alt="Logic Analyzer"></p>
<p>전송이 끝날 때, SDCard는 응답 토큰 <code>0xE5</code>(<code>11100101b</code>)를 보냅니다. 데이터 수락 토큰은 <code>xxx00101b</code> 형식이므로 데이터를 성공적으로 보낸 것을 확인할 수 있습니다. 그 이후에 SDCard는 Busy 상태인 것을 나타내기 위해 <code>0x00</code>을 보냅니다.<br>
<img src="/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_16.png" alt="Logic Analyzer"></p>
<p>참고로 <code>sdWriteSingleBlock()</code>을 호출한 후 확인해야 하는 4가지 경우가 있습니다. 이 부분은 각자 구현해 보면 좋을 거 같습니다.</p>
<ul>
<li><code>R1 != 0x00</code> → 블록 쓰기 오류 (자세한 내용은 <code>R1</code>을 분석해야 합니다)</li>
<li><code>R1 == 0x00</code> &amp;&amp; <code>token == 0x05</code> → 성공</li>
<li><code>R1 == 0x00</code> &amp;&amp; <code>token == 0x00</code> → 타임아웃</li>
<li><code>R1 == 0x00</code> &amp;&amp; <code>token == 0xFF</code> → <code>R1</code> 이후 응답 없음</li>
</ul>
</div></article></main><footer class="c-cpkrrK"><div class="c-fiqONv">© <!-- -->2022</div><div class="c-bHyrwK"><div class="c-iUFgVP">Kh.</div><div class="c-cshSRb">KyuHyuk Lee</div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"excerpt":" 이전 글 에서 SDCard 초기화 과정을 구현했습니다. 이 글에서는 SDCard에 데이터를 읽고 쓰는 방법을 구현합니다. CMD16 (SET_BLOCKLEN) SDCard의 읽기 및 쓰기 작업은 설정된 길이의 블록으로 수행됩니다. 블록 길이는 CMD16 을 사용해서 설정할 수 있습니다","url":"/article/avr/2022/09/03/AVR-ATmega328P-SDCard-4","frontmatter":{"title":"[AVR] ATmega328P SDCard 구현 (4)","date":"2022-09-03 04:32:01","category":"AVR"},"content":"\n[이전 글](https://kyuhyuk.kr/article/avr/2022/09/02/AVR-ATmega328P-SDCard-3)에서 SDCard 초기화 과정을 구현했습니다. 이 글에서는 SDCard에 데이터를 읽고 쓰는 방법을 구현합니다.\n\n# `CMD16` (SET_BLOCKLEN)\n\nSDCard의 읽기 및 쓰기 작업은 설정된 길이의 블록으로 수행됩니다. 블록 길이는 `CMD16`을 사용해서 설정할 수 있습니다. 이 글에서는 블록 길이가 항상 512바이트로 설정되는 SDHC와 SDXC만 고려합니다.\n\n# `CMD17` (READ_SINGLE_BLOCK)\n\n`CMD17`(READ_SINGLE_BLOCK)은 단일 블록 읽기 명령입니다. `CMD17`의 형식은 아래와 같습니다.\n\n![CMD17 Format](/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_1.png)\n\nArgument에 SDCard에서 읽을 주소를 지정해야 합니다. SDHC와 SDXC는 블록 주소로 지정됩니다. 예를 들어 주소를 `0`으로 설정하면 `0`~`511` 바이트를 읽어 오고, 주소를 `1`으로 설정하면 `512`~`1023` 바이트를 읽어 옵니다. 32비트를 사용했을 때 SDCard에서 읽을 수 있는 최대 크기는 `(2^32)*512 = 2048MB` 또는 `2TB`입니다.\n\n단일 블록을 읽어오는 과정은 아래 다이어그램을 참고하세요.\n\n![Single Block Read Operation](/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_2.png)\n\n`CMD17`이 전송되면 `R1`으로 응답하고 데이터 블록이 CRC와 함께 옵니다. `R1` Response를 보내는 것과 첫 번째 데이터 바이트 사이에 시간이 걸릴 수도 있습니다. 데이터가 실제로 시작되는 시점은 단일 데이터 블록일 경우에는 시작 토큰인 `0xFE`(`11111110b`)가 먼저 옵니다.\n\n![Single Block - Start Token](/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_3.png)\n\n시작 토큰과 함께 SDCard는 블록 길이(SDHC와 SDXC는 항상 512바이트) 만큼 데이터를 보냅니다. 그다음에 16비트의 CRC가 옵니다.\n\n```c\n#define CMD17                   17\n#define CMD17_CRC               0x00\n#define SD_MAX_READ_ATTEMPTS    1563\n\n/*\n  512바이트 단일 블록을 읽습니다\n  token = 0xFE // 읽기 성공\n  token = 0x0X // 데이터 에러\n  token = 0xFF // 타임아웃\n*/\nuint8_t sdReadSingleBlock(uint32_t addr, uint8_t *buf, uint8_t *token)\n{\n    uint8_t res1, read;\n    uint16_t readAttempts;\n\n    // Token을 초기화 합니다\n    *token = 0xFF;\n\n    // SDCard CS Assert\n    spiTransfer(0xFF);\n    CS_ENABLE();\n    spiTransfer(0xFF);\n\n    // CMD17 전송\n    sdCommand(CMD17, addr, CMD17_CRC);\n\n    // Response를 읽습니다\n    res1 = sdReadRes1();\n\n    // SDCard에서 Response를 받은 경우\n    if(res1 != 0xFF)\n    {\n        // Response Token을 기다립니다 (Timeout은 100ms 입니다)\n        readAttempts = 0;\n        while(++readAttempts != SD_MAX_READ_ATTEMPTS)\n            if((read = spiTransfer(0xFF)) != 0xFF) break;\n\n        // Response Token이 0xFE(시작 토큰)인 경우\n        if(read == 0xFE)\n        {\n            // 512바이트의 블록을 읽습니다\n            for(uint16_t i = 0; i \u003c 512; i++) *buf++ = spiTransfer(0xFF);\n\n            // 16비트의 CRC를 읽습니다\n            spiTransfer(0xFF);\n            spiTransfer(0xFF);\n        }\n\n        // Token을 SDCard의 Response로 설정합니다\n        *token = read;\n    }\n\n    // SDCard CS Deassert\n    spiTransfer(0xFF);\n    CS_DISABLE();\n    spiTransfer(0xFF);\n\n    return res1;\n}\n```\n\n`sdReadSingleBlock()`는 32비트의 `addr`을 Argumemt로 사용하고, 데이터를 저장하기 위해 최소 512바이트의 버퍼(`buf`)가 필요합니다. 데이터 토큰을 저장하는 데 사용할 8비트 값에 대한 포인터(`token`)도 함께 전달합니다.\n\n`R1`을 읽을 후 비어 있지 않은 경우(카드가 명령에 응답한 경우) 토큰을 받거나 Timeout까지 SDCard를 계속 폴링 합니다.\n\n```c\n// SDCard에서 Response를 받은 경우\n    if(res1 != 0xFF)\n    {\n        // Response Token을 기다립니다 (Timeout은 100ms 입니다)\n        readAttempts = 0;\n        while(++readAttempts != SD_MAX_READ_ATTEMPTS)\n            if((read = spiTransfer(0xFF)) != 0xFF) break;\n    }\n```\n\n[SDCard Physical Specification](/assets/file/2022-08-28-AVR-ATmega328P-SDCard-1/Part_1_Physical_Layer_Simplified_Specification_Ver2.00_060925.pdf)의 4.6.2.1 섹션을 보면 아래와 같은 내용이 있습니다:\n\n\u003e Host는 단일 및 다중 읽기 작업에 대해 최소 100ms의 Timeout을 사용해야 합니다.\n\n우리의 환경은 16MHz의 발진기(Oscillator)를 사용하고 SPI의 클럭을 128로 나누도록 설정했습니다. 따라서 100ms을 만족하기 위해 SPI를 통해 보내야 하는 바이트의 개수를 얻으려면 아래와 같이 계산할 수 있습니다.\n\n`(0.1s * 16000000 Hz) / (128 * 8 Bytes) = 1562.5 ≈ 1563`\n\n시작 토큰을 받으면 버퍼에 512바이트를 넣고, 16비트 CRC를 읽습니다.\n\n```c\n// Response Token이 0xFE(시작 토큰)인 경우\nif(read == 0xFE)\n{\n    // 512바이트의 블록을 읽습니다\n    for(uint16_t i = 0; i \u003c 512; i++) *buf++ = spiTransfer(0xFF);\n\n    // 16비트의 CRC를 읽습니다\n    spiTransfer(0xFF);\n    spiTransfer(0xFF);\n}\n```\n\n시작 토큰을 받지 못하면 SDCard에서 블록을 읽으려고 시도하지 않습니다. 토큰이 `0xFF` 이면 SDCard에서 아무것도 수신하지 못한 것입니다. 이럴 경우에는 Timeout이 발생하게 됩니다. 만약 이런 경우가 아니라면 오류 토큰을 수신해야 합니다. 오류 토큰을 수신하는 부분은 나중에 다시 자세하게 설명하겠습니다.\n\n# 테스트 해보기\n\n[이전 글](https://kyuhyuk.kr/article/avr/2022/09/02/AVR-ATmega328P-SDCard-3)의 초기화 코드를 사용하여 SDCard에서 맨 처음 블록을 읽어 보겠습니다.\n\n```c\n#define SD_R1_NO_ERROR(X)   X \u003c 0x02\n\nint main(void)\n{\n  // Response를 담을 배열을 선언합니다\n  uint8_t res[5], sdBuf[512], token;\n\n  // UART를 초기화 합니다\n  const unsigned int baudRate = (F_CPU / 16 / 9600) - 1;\n  uartInit(baudRate);\n\n  // SPI를 초기화 합니다\n  spiInit();\n\n  // SDCard를 초기화 합니다\n  if (sdInit() != SD_SUCCESS)\n  {\n    uartPuts(\"Error initializaing SD CARD\\r\\n\");\n    while (1)\n      ;\n  }\n  else\n  {\n    uartPuts(\"SD Card initialized\\r\\n\");\n\n    // Sector 0을 읽습니다\n    res[0] = sdReadSingleBlock(0x00000000, sdBuf, \u0026token);\n\n    // Response를 출력합니다\n    if (SD_R1_NO_ERROR(res[0]) \u0026\u0026 (token == 0xFE))\n    {\n      for (uint16_t i = 0; i \u003c 512; i++)\n      {\n        if (i % 32 == 0)\n          uartPuts(\"\\r\\n\");\n        uartPutHex8(sdBuf[i]);\n      }\n      uartPuts(\"\\r\\n\");\n    }\n    else\n    {\n      uartPuts(\"Error reading sector\\r\\n\");\n    }\n  }\n\n  while (1)\n    ;\n}\n```\n\nUART에 아래와 같이 출력됩니다:  \n![UART - Read Single Block](/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_4.png)\n\n마지막 2개의 바이트 `0x55`와 `0xAA`는 MBR에 있는 Boot Signature 입니다. SDCard를 읽기 전에 PC에서 이미 포맷한 경우에는 2개의 바이트는 동일하게 표시될 것입니다.\n\nLogic Analyzer로 보면, `R1`에서 데이터 블록 전송을 하는 부분은 아래와 같이 보일 것입니다.  \n![Logic Analyzer - Read Single Block](/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_5.png)\n\n위의 스크린샷을 보면 시작 토큰을 보내기 전에 5바이트 동안은 SDCard는 IDLE 상태였습니다. (시작 토큰이 없으면 SDCard가 IDLE 상태인지 모두 `1`인 데이터인지를 구분할 수 없습니다)\n\n# Read Errors\n\nSDCard가 요청된 데이터를 찾을 수 없는 경우에는 데이터 시작 토큰 대신 데이터 오류 토큰을 보냅니다. 이 과정은 아래 다이어그램에서 볼 수 있습니다.\n\n![Read Operation - Data Error](/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_6.png)\n\n데이터 오류 토큰의 형식은 아래와 같습니다.\n\n![Data Error Token](/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_7.png)\n\n먼저 오류 토큰을 출력하는 `sdPrintDataErrToken()`을 작성하겠습니다:\n\n```c\n#define SD_TOKEN_OOR(X)     X \u0026 0b00001000\n#define SD_TOKEN_CECC(X)    X \u0026 0b00000100\n#define SD_TOKEN_CC(X)      X \u0026 0b00000010\n#define SD_TOKEN_ERROR(X)   X \u0026 0b00000001\n\nvoid sdPrintDataErrToken(uint8_t token)\n{\n    if(SD_TOKEN_OOR(token))\n        uartPuts(\"\\tData out of range\\r\\n\");\n    if(SD_TOKEN_CECC(token))\n        uartPuts(\"\\tCard ECC failed\\r\\n\");\n    if(SD_TOKEN_CC(token))\n        uartPuts(\"\\tCC Error\\r\\n\");\n    if(SD_TOKEN_ERROR(token))\n        uartPuts(\"\\tError\\r\\n\");\n}\n```\n\nSDCard의 범위를 벗어난 메모리 위치에 접근하려고 하면, 아마 데이터 토큰이 아닌 오류 토큰을 받게 될 것입니다. 메모리 주소 `0xFFFFFFFF`에 접근해 보겠습니다. 2TB의 SDCard가 아니라면 오류가 발생할 것입니다.\n\n```c\nuint8_t res, sdBuf[512], token;\nres = sdReadSingleBlock(0xffffffff, sdBuf, \u0026token);\n\nuartPuts(\"Response 1:\\r\\n\");\nsdPrintR1(res);\n\n// 오류 토큰을 수신했을때\nif(!(token \u0026 0xF0))\n{\n    uartPuts(\"Error token:\\r\\n\");\n    sdPrintDataErrToken(token);\n}\nelse if(token == 0xFF)\n{\n    uartPuts(\"Timeout\\r\\n\");\n}\n```\n\n다음은 UART를 통해 출력되는 내용입니다.  \n![SanDisk SDCard](/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_8.png)\n\n`R1`에서 주소 오류가 있다고 출력합니다. 하지만, 오류 토큰은 보이지 않습니다.\n\n사실 이 동작은 SDCard마다 다르게 응답합니다. 방금 UART로 출력된 내용은 SanDisk SDCard에서 출력되었습니다. 만약 Samsung SDCard에서 동일한 코드를 실행하면 아래와 같이 출력됩니다.  \n![Samsung SDCard](/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_9.png)\n\n혹시 코드가 잘못되었나 확인하기 위해 Logic Analyzer로 확인해 봤지만, 제가 가진 SDCard에서는 오류 토큰을 받은 적이 없으며 ~100ms 후에 Timeout이 되었습니다.  \n![Logic Analyzer - Read Single Block](/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_10.png)\n\n# `CMD24` (WRITE_BLOCK)\n\n읽기와 마찬가지로 쓰기도 512바이트 블록에서 수행됩니다. `CMD24`를 사용하여 쓰기를 수행합니다. 이 명령의 형식은 아래와 같습니다.\n\n![CMD24](/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_11.png)\n\n단일 블록에 쓰는 방법은 아래와 같습니다.\n\n![Single Block Write Operation](/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_12.png)\n\n`CMD24`를 보내고 Response(`R1`)을 기다린 다음, Start Block Token(`0xFE`)를 보내고 쓸 데이터 512바이트를 보냅니다. 그리고 SDCard에서 새로운 유형의 토큰인 Data Response Token을 기다립니다. Data Response Token의 형식은 아래와 같습니다.\n\n![Data Response Token](/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_13.png)\n\nSDCard가 데이터를 수락하면 Token `xxx00101b`를 받게 됩니다. SDCard는 데이터 쓰기 작업이 완료될 때까지 Busy Token인 `0x00`을 보냅니다.\n\n방금 설명한 내용을 바탕으로 `sdWriteSingleBlock()`를 작성해 보겠습니다.\n\n```c\n#define CMD24                   24\n#define CMD24_ARG               0x00\n#define CMD24_CRC               0x00\n#define SD_MAX_WRITE_ATTEMPTS   3907\n#define SD_BLOCK_LEN            512\n#define SD_START_TOKEN          0xFE\n#define SD_ERROR_TOKEN          0x00\n\n/*\n  512바이트 단일 블록을 기록합니다\n  token = 0x00 // Busy 타임아웃\n  token = 0x05 // 데이터 수락\n  token = 0xFF // 응답 타임아웃\n*/\nuint8_t sdWriteSingleBlock(uint32_t addr, uint8_t *buf, uint8_t *token)\n{\n    uint8_t res1;\n    uint8_t readAttempts, read;\n\n    // Token을 초기화 합니다\n    *token = 0xFF;\n\n    // SDCard CS Assert\n    spiTransfer(0xFF);\n    CS_ENABLE();\n    spiTransfer(0xFF);\n\n    // CMD24 전송\n    sdCommand(CMD24, addr, CMD24_CRC);\n\n    // Response를 읽습니다\n    res1 = sdReadRes1();\n\n    // Response에 오류가 없는 경우\n    if(res1 == SD_READY)\n    {\n        // Start Token을 전송합니다\n        spiTransfer(SD_START_TOKEN);\n\n        // Buffer의 내용을 전송합니다\n        for(uint16_t i = 0; i \u003c SD_BLOCK_LEN; i++) spiTransfer(buf[i]);\n\n        // Response를 기다립니다 (Timeout = 250ms)\n        readAttempts = 0;\n        while(++readAttempts != SD_MAX_WRITE_ATTEMPTS)\n            if((read = spiTransfer(0xFF)) != 0xFF) { *token = 0xFF; break; }\n\n        // 데이터가 수락되면 실행합니다\n        if((read \u0026 0x1F) == 0x05)\n        {\n            // Token을 '데이터 수락'으로 설정\n            *token = 0x05;\n\n            // 쓰기 작업이 끝날때까지 기다립니다 (Timeout = 250ms)\n            readAttempts = 0;\n            while(spiTransfer(0xFF) == 0x00)\n                if(++readAttempts == SD_MAX_WRITE_ATTEMPTS) { *token = 0x00; break; }\n        }\n    }\n\n    // SDCard CS Deassert\n    spiTransfer(0xFF);\n    CS_DISABLE();\n    spiTransfer(0xFF);\n\n    return res1;\n}\n```\n\n읽기 작업과 마찬가지로 타임아웃 값을 설정합니다. [SDCard Physical Specification](/assets/file/2022-08-28-AVR-ATmega328P-SDCard-1/Part_1_Physical_Layer_Simplified_Specification_Ver2.00_060925.pdf)의 4.6.2.2 섹션을 보면 모든 쓰기 작업에 대해 타임아웃은 250ms로 정의해야 한다고 언급하고 있습니다. `(0.25s * 16000000 Hz) / (128 * 8 Bytes) = 3906.25`이지만, `3907`로 250ms보다 조금 크게 설정했습니다.\n\n```c\n#define SD_MAX_WRITE_ATTEMPTS   3907\n```\n\n`CMD24`(쓰기 명령)을 SDCard에 보내고 `R1` Response에 오류가 없는지 확인합니다.\n\n```c\n// CMD24 전송\nsdCommand(CMD24, addr, CMD24_CRC);\n\n// Response를 읽습니다\nres[0] = sdReadRes1();\n\n// Response에 오류가 없는 경우\nif(res[0] == SD_READY)\n{\n    /* ... */\n}\n```\n\n`R1`에 오류가 없으면 Start Token을 보낸 다음 Buffer에서 데이터 전송을 시작합니다.\n\n```c\n// Start Token을 전송합니다\nspiTransfer(SD_START_TOKEN);\n\n// Buffer의 내용을 전송합니다\nfor(uint16_t i = 0; i \u003c SD_BLOCK_LEN; i++) spiTransfer(buf[i]);\n```\n\nBuffer의 내용을 전송하는 작업이 끝나면, SDCard가 Data Response Token을 보낼 때까지 기다립니다. 데이터 수락 토큰은 `xxx00101b` 입니다.\n\n```c\n// Response를 기다립니다 (Timeout = 250ms)\nreadAttempts = 0;\nwhile(++readAttempts != SD_MAX_WRITE_ATTEMPTS)\n    if((read = spiTransfer(0xFF)) != 0xFF) { *token = 0xFF; break; }\n\n// 데이터가 수락되면 실행합니다\nif((read \u0026 0x1F) == 0x05)\n{\n    /* ... */\n}\n```\n\n마지막으로 SDCard가 데이터를 쓰는 것을 완료할 때까지 기다립니다.\n\n```c\n// 쓰기 작업이 끝날때까지 기다립니다 (Timeout = 250ms)\nreadAttempts = 0;\nwhile(spiTransfer(0xFF) == 0x00)\n    if(++readAttempts == SD_MAX_WRITE_ATTEMPTS) { *token = 0x00; break; }\n```\n\n이제 간단한 데이터를 한번 기록해 봅시다. `0x55`로 만 이루어진 버퍼를 SDCard의 `0x00000100`에 써보겠습니다.\n\n```c\n// 0x55로 버퍼를 채웁니다\nfor(uint16_t i = 0; i \u003c 512; i++) buf[i] = 0x55;\n\n// 주소 0x100 (256)에 0x55를 기록합니다\nres = sdWriteSingleBlock(0x00000100, buf, \u0026token);\n```\n\n위의 코드를 실행해 보면 아래와 같이 `0x00`으로 채워져있던 `0x00000100`에 `0x55`가 기록된 것을 볼 수 있습니다.  \n![sdWriteSingleBlock UART](/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_14.png)\n\nLogic Analyzer로 확인해 보면 `R1`으로 응답한 뒤 바로 시작 토큰을 보내고, 기록할 데이터 전송을 시작합니다.  \n![Logic Analyzer](/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_15.png)\n\n전송이 끝날 때, SDCard는 응답 토큰 `0xE5`(`11100101b`)를 보냅니다. 데이터 수락 토큰은 `xxx00101b` 형식이므로 데이터를 성공적으로 보낸 것을 확인할 수 있습니다. 그 이후에 SDCard는 Busy 상태인 것을 나타내기 위해 `0x00`을 보냅니다.  \n![Logic Analyzer](/assets/image/2022-09-03-AVR-ATmega328P-SDCard-4/AVR-ATmega328P-SDCard-4_16.png)\n\n참고로 `sdWriteSingleBlock()`을 호출한 후 확인해야 하는 4가지 경우가 있습니다. 이 부분은 각자 구현해 보면 좋을 거 같습니다.\n\n- `R1 != 0x00` → 블록 쓰기 오류 (자세한 내용은 `R1`을 분석해야 합니다)\n- `R1 == 0x00` \u0026\u0026 `token == 0x05` → 성공\n- `R1 == 0x00` \u0026\u0026 `token == 0x00` → 타임아웃\n- `R1 == 0x00` \u0026\u0026 `token == 0xFF` → `R1` 이후 응답 없음\n"},"__N_SSG":true},"page":"/article/[category]/[year]/[month]/[day]/[slug]","query":{"category":"avr","year":"2022","month":"09","day":"03","slug":"AVR-ATmega328P-SDCard-4"},"buildId":"cYbDaMF1ARyMLu5tcmUx6","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>