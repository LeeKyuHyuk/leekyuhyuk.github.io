<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta property="og:image" content="https://kyuhyuk.kr/thumbnail.png"/><title>[AVR] ATmega328P SDCard 구현 (3)</title><meta name="author" content="KyuHyuk Lee"/><meta name="generator" content="KyuHyuk Lee"/><meta name="description" content=" 이전 글 에서 CMD0 , CMD8 그리고 CMD58 을 사용하는 방법을 소개했습니다. 이제 SDCard의 초기화 과정을 거의 완료했습니다. 아래 다이어그램을 보면 다음 단계는 ACMD41 라는 것을 알 수 있습니다. ACMD41 (SD_SEND_OP_COND) ACMD41 (Send"/><meta itemProp="url" content="https://kyuhyuk.kr/article/avr/2022/09/02/AVR-ATmega328P-SDCard-3"/><meta itemProp="headline" content="[AVR] ATmega328P SDCard 구현 (3)"/><meta property="og:type" content="article"/><meta property="og:url" content="https://kyuhyuk.kr/article/avr/2022/09/02/AVR-ATmega328P-SDCard-3"/><meta property="og:title" content="[AVR] ATmega328P SDCard 구현 (3)"/><meta property="og:description" content=" 이전 글 에서 CMD0 , CMD8 그리고 CMD58 을 사용하는 방법을 소개했습니다. 이제 SDCard의 초기화 과정을 거의 완료했습니다. 아래 다이어그램을 보면 다음 단계는 ACMD41 라는 것을 알 수 있습니다. ACMD41 (SD_SEND_OP_COND) ACMD41 (Send"/><meta property="og:site_name" content="KyuHyuk Blog"/><meta property="og:locale" content="ko_KR"/><meta name="next-head-count" content="15"/><style id="stitches">--sxs{--sxs:2 c-opBYf c-bHyrwK c-uBnvQ c-hehuMV c-bjkCdF c-hAoZGi c-jfcKOQ c-ezyKJG c-iAzQif c-bvdusc c-ezRQNp c-iosjjB c-jYwCTI c-iOPkYY c-cpkrrK c-fiqONv c-iUFgVP c-cshSRb c-fxvkZv c-dIcdES}@media{.c-opBYf{display:flex;align-items:center;background:#FFFFFF;height:60px;justify-content:space-between;-webkit-box-align:center;-webkit-box-pack:justify}.c-bHyrwK{display:flex;align-items:center;justify-content:center;-webkit-box-align:center;-webkit-box-pack:center}.c-uBnvQ{width:32px;height:32px;color:#FFFFFF;background:#000000;border-radius:4px;display:flex;align-items:center;justify-content:center;margin-right:12px;font-weight:700;cursor:default;-webkit-box-align:center;-webkit-box-pack:center}.c-hehuMV{font-weight:900;font-size:18px;letter-spacing:0.5px;color:#000000;cursor:default}.c-bjkCdF{list-style:none;padding:0;margin:0;display:flex;justify-content:center;align-items:center;font-size:24px;color:rgb(134, 142, 150);transition:all 0.3s ease 0s;-webkit-box-pack:center;-webkit-box-align:center}.c-hAoZGi{font-size:28px;color:inherit;text-decoration:none;margin:8px}.c-jfcKOQ{max-width:768px;margin-top:2rem;margin-left:auto;margin-right:auto}.c-ezyKJG{min-width:72px;display:flex;flex-direction:row;justify-content:center;align-items:center;padding:6px 16px;background:#12B886;box-shadow:0px 1px 2px rgba(98, 16, 204, 0.3);border:none;border-radius:14px;vertical-align:middle;color:#FFFFFF;font-size:1rem;height:2rem;float:right}.c-iAzQif{display:inline-block;margin-top:2rem}.c-bvdusc{font-size:2rem;line-height:1.5;letter-spacing:-0.004em;margin-top:0;margin-bottom:2rem;font-weight:700;color:#212529;word-break:keep-all;transition:color 0.125s ease-in 0s;}.c-ezRQNp{font-size:1.125rem;color:#212529;transition:color 0.125s ease-in 0s;;line-height:1.7;letter-spacing:-0.004em;word-break:break-all;overflow-wrap:break-word}.c-iosjjB{background:#F8F9FA;padding:0 1rem;height:2rem;border-radius:1rem;display:inline-flex;align-items:center;margin-right:0.875rem;color:#12B886;text-decoration:none;font-weight:400;font-size:1rem}.c-jYwCTI{font-size:1rem;color:#495057}.c-iOPkYY{margin-top:3rem;background-color:rgba(51,51,51,.1);border:0;height:1px}.c-cpkrrK{width:100%;height:300px;display:flex;align-items:center;justify-content:center;flex-direction:column;-webkit-box-align:center;-webkit-box-pack:center}.c-fiqONv{color:rgb(206, 212, 218);margin-bottom:8px;font-size:22px;font-weight:700}.c-iUFgVP{width:32px;height:32px;color:#FFFFFF;background:rgb(206, 212, 218);border-radius:4px;display:flex;align-items:center;justify-content:center;margin-right:12px;font-weight:700;cursor:default;-webkit-box-align:center;-webkit-box-pack:center}.c-cshSRb{font-weight:900;font-size:18px;letter-spacing:0.5px;color:rgb(206, 212, 218);cursor:default;text-transform:uppercase}.c-fxvkZv{font-size:2.5rem;line-height:1.5;letter-spacing:-0.004em;margin-top:0;margin-bottom:2rem;font-weight:700;color:#212529;word-break:keep-all;transition:color 0.125s ease-in 0s;}.c-dIcdES{margin-top:2rem;font-size:1.125rem;color:#212529;transition:color 0.125s ease-in 0s;;line-height:1.7;letter-spacing:-0.004em;word-break:keep-all;overflow-wrap:break-word}}</style><link rel="preload" href="/_next/static/css/98b299b94b0a7962.css" as="style"/><link rel="stylesheet" href="/_next/static/css/98b299b94b0a7962.css" data-n-g=""/><link rel="preload" href="/_next/static/css/c2a527101433f11d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c2a527101433f11d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-af3068766efac2e7.js" defer=""></script><script src="/_next/static/chunks/pages/_app-1152a1d584800b30.js" defer=""></script><script src="/_next/static/chunks/413-67b20b8229b03582.js" defer=""></script><script src="/_next/static/chunks/796-a00c9a8c08a47d16.js" defer=""></script><script src="/_next/static/chunks/pages/article/%5Bcategory%5D/%5Byear%5D/%5Bmonth%5D/%5Bday%5D/%5Bslug%5D-a6ddc2a5f4e4754e.js" defer=""></script><script src="/_next/static/sFagy2B10ejf-tz-1N1o9/_buildManifest.js" defer=""></script><script src="/_next/static/sFagy2B10ejf-tz-1N1o9/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="c-opBYf"><a href="https://kyuhyuk.kr"><div class="c-bHyrwK"><div class="c-uBnvQ">Kh.</div><div class="c-hehuMV">KyuHyuk Blog</div></div></a><ul class="c-bjkCdF"><li><a href="https://github.com/LeeKyuHyuk" class="c-hAoZGi"><span role="img" aria-label="github" class="anticon anticon-github"><svg viewBox="64 64 896 896" focusable="false" data-icon="github" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0138.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"></path></svg></span></a></li><li><a href="https://linkedin.com/in/leekyuhyuk" class="c-hAoZGi"><span role="img" aria-label="linkedin" class="anticon anticon-linkedin"><svg viewBox="64 64 896 896" focusable="false" data-icon="linkedin" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zM349.3 793.7H230.6V411.9h118.7v381.8zm-59.3-434a68.8 68.8 0 1168.8-68.8c-.1 38-30.9 68.8-68.8 68.8zm503.7 434H675.1V608c0-44.3-.8-101.2-61.7-101.2-61.7 0-71.2 48.2-71.2 98v188.9H423.7V411.9h113.8v52.2h1.6c15.8-30 54.5-61.7 112.3-61.7 120.2 0 142.3 79.1 142.3 181.9v209.4z"></path></svg></span></a></li><li><a href="mailto:lee@kyuhyuk.kr" class="c-hAoZGi"><span role="img" aria-label="mail" class="anticon anticon-mail"><svg viewBox="64 64 896 896" focusable="false" data-icon="mail" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-80.8 108.9L531.7 514.4c-7.8 6.1-18.7 6.1-26.5 0L189.6 268.9A7.2 7.2 0 01194 256h648.8a7.2 7.2 0 014.4 12.9z"></path></svg></span></a></li></ul></header><main class="c-jfcKOQ"><article><h1 class="c-fxvkZv"><a href="https://kyuhyuk.kr/article/avr/2022/09/02/AVR-ATmega328P-SDCard-3">[AVR] ATmega328P SDCard 구현 (3)</a></h1><a href="https://kyuhyuk.kr/category/AVR" class="c-iosjjB">AVR</a><time dateTime="2022-09-02 23:57:51" class="c-jYwCTI">Sep 02, 2022 11:57:51 PM</time><div id="post" class="c-dIcdES"><p><a href="https://kyuhyuk.kr/article/avr/2022/09/01/AVR-ATmega328P-SDCard-2">이전 글</a>에서 <code>CMD0</code>, <code>CMD8</code> 그리고 <code>CMD58</code>을 사용하는 방법을 소개했습니다. 이제 SDCard의 초기화 과정을 거의 완료했습니다. 아래 다이어그램을 보면 다음 단계는 <code>ACMD41</code>라는 것을 알 수 있습니다.</p>
<p><img src="/assets/image/2022-08-28-AVR-ATmega328P-SDCard-1/AVR-ATmega328P-SDCard-1_5.png" alt="SDCard SPI Mode Initalization Flow"></p>
<h1><code>ACMD41</code> (SD_SEND_OP_COND)</h1>
<p><code>ACMD41</code>(Send Operating Condition)는 SDCard의 초기화 과정을 시작합니다. 여기서 주의해야 하는 점은 <code>ACMD41</code>과 같이 <code>A</code>로 시작하는 Command는 사용하기 전에 <code>CMD55</code>(APP_CMD)를 보내서 다음에 사용하려는 Command이 <code>ACMD</code>라는 것을 SDCard에게 알려야 합니다.</p>
<p>다음은 <code>CMD55</code>의 형식입니다:</p>
<p><img src="/assets/image/2022-09-02-AVR-ATmega328P-SDCard-3/AVR-ATmega328P-SDCard-3_1.png" alt="CMD55 Format"></p>
<p><code>ACMD41</code>의 형식은 아래와 같습니다:</p>
<p><img src="/assets/image/2022-09-02-AVR-ATmega328P-SDCard-3/AVR-ATmega328P-SDCard-3_2.png" alt="ACMD41 Format"></p>
<p><code>ACMD41</code>의 대부분 비트는 Reserved이지만, 고용량 카드를 지원함을 나타내기 위해 Bit 30을 1로 설정하는 부분이 있습니다. CRC는 이러한 명령에 대해 무시되므로 아무거나 설정할 수 있습니다.</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD55       55</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD55_ARG   0x00000000</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD55_CRC   0x00</span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> ACMD41      41</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ACMD41_ARG  0x40000000</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ACMD41_CRC  0x00</span>
</code></pre>
<p><code>ACMD41</code>은 <code>CMD41</code>과 마찬가지로 Command Index를 <code>41</code>을 사용합니다. <code>CMD55</code>가 먼저 전송되지 않는 경우에는 <code>CMD41</code>가 전송됩니다.</p>
<p><code>CMD55</code>와 <code>ACMD41</code>은 <code>R1</code>의 Response를 반환합니다.</p>
<pre><code class="language-c"><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">sdSendApp</span><span class="hljs-params">()</span>
{
    <span class="hljs-comment">// SDCard CS Assert</span>
    spiTransfer(<span class="hljs-number">0xFF</span>);
    CS_ENABLE();
    spiTransfer(<span class="hljs-number">0xFF</span>);

    <span class="hljs-comment">// CMD55 전송</span>
    sdCommand(CMD55, CMD55_ARG, CMD55_CRC);

    <span class="hljs-comment">// Response를 읽습니다</span>
    <span class="hljs-type">uint8_t</span> r1 = sdReadRes1();

    <span class="hljs-comment">// SDCard CS Deassert</span>
    spiTransfer(<span class="hljs-number">0xFF</span>);
    CS_DISABLE();
    spiTransfer(<span class="hljs-number">0xFF</span>);

    <span class="hljs-keyword">return</span> r1;
}

<span class="hljs-type">uint8_t</span> <span class="hljs-title function_">sdSendOpCond</span><span class="hljs-params">()</span>
{
    <span class="hljs-comment">// SDCard CS Assert</span>
    spiTransfer(<span class="hljs-number">0xFF</span>);
    CS_ENABLE();
    spiTransfer(<span class="hljs-number">0xFF</span>);

    <span class="hljs-comment">// ACMD41 전송</span>
    sdCommand(ACMD41, ACMD41_ARG, ACMD41_CRC);

    <span class="hljs-comment">// Response를 읽습니다</span>
    <span class="hljs-type">uint8_t</span> r1 = sdReadRes1();

    <span class="hljs-comment">// SDCard CS Deassert</span>
    spiTransfer(<span class="hljs-number">0xFF</span>);
    CS_DISABLE();
    spiTransfer(<span class="hljs-number">0xFF</span>);

    <span class="hljs-keyword">return</span> r1;
}
</code></pre>
<p>위에서 설명했듯이 <code>ACMD41</code>은 초기화 과정을 시작합니다. Startup Sequence에서 SDCard가 <code>R1 = 0x00</code>인 'in_idle_state'로 응답할 때까지 <code>ACMD41</code>(항상 <code>CMD55</code>를 먼저 보내고 실행)을 계속 보냅니다.</p>
<p><code>R1 = 0x00</code>을 받으면 CCS 값을 보기 위해 <code>CMD58</code>을 보내야 합니다. CCS를 통해 SDCard가 SDHC(고용량 SDCard)인지 SCXC(확장 용량 SDCard)인지 알 수 있습니다.</p>
<p><a href="https://kyuhyuk.kr/article/avr/2022/09/01/AVR-ATmega328P-SDCard-2">이전 글</a>에서 작성한 <code>main()</code>을 아래와 같이 수정합니다.</p>
<pre><code class="language-c"><span class="hljs-comment">/*
  CPU의 Frequency를 16MHz로 설정합니다
*/</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> F_CPU 16000000UL</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;util/delay.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
  <span class="hljs-type">uint8_t</span> res[<span class="hljs-number">5</span>];
  <span class="hljs-type">char</span> c;

  <span class="hljs-comment">// UART를 초기화 합니다</span>
  <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> baudRate = (F_CPU / <span class="hljs-number">16</span> / <span class="hljs-number">9600</span>) - <span class="hljs-number">1</span>;
  uartInit(baudRate);

  <span class="hljs-comment">// SPI를 초기화 합니다</span>
  spiInit();

  <span class="hljs-comment">// SDCard에 VCC가 충분히 공급될때까지 기다립니다</span>
  _delay_ms(<span class="hljs-number">10</span>);

  <span class="hljs-comment">// Power Up Sequence를 시작합니다</span>
  sdPowerUpSeq();

  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)
  {
    <span class="hljs-comment">// 메뉴를 출력합니다</span>
    uartPuts(<span class="hljs-string">&quot;MENU\r\n&quot;</span>);
    uartPuts(<span class="hljs-string">&quot;------------------\r\n&quot;</span>);
    uartPuts(<span class="hljs-string">&quot;0 - Send CMD0\r\n1 - Send CMD8\r\n2 - Send CMD58\r\n&quot;</span>);
    uartPuts(<span class="hljs-string">&quot;3 - Send CMD55\r\n4 - Send ACMD41\r\n&quot;</span>);
    uartPuts(<span class="hljs-string">&quot;------------------\r\n&quot;</span>);

    <span class="hljs-comment">// 사용자에게 명령(문자)를 입력받습니다</span>
    c = uartGet();

    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;0&#x27;</span>)
    {
      <span class="hljs-comment">// CMD0을 보내고 응답을 읽고 출력합니다</span>
      uartPuts(<span class="hljs-string">&quot;Sending CMD0...\r\n&quot;</span>);
      res[<span class="hljs-number">0</span>] = sdGoIdleState();
      uartPuts(<span class="hljs-string">&quot;Response:\r\n&quot;</span>);
      sdPrintR1(res[<span class="hljs-number">0</span>]);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;1&#x27;</span>)
    {
      <span class="hljs-comment">// CMD8을 보내고 응답을 읽고 출력합니다</span>
      uartPuts(<span class="hljs-string">&quot;Sending CMD8...\r\n&quot;</span>);
      sdSendIfCond(res);
      uartPuts(<span class="hljs-string">&quot;Response:\r\n&quot;</span>);
      sdPrintR7(res);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;2&#x27;</span>)
    {
      <span class="hljs-comment">// CMD58을 보내고 응답을 읽고 출력합니다</span>
      uartPuts(<span class="hljs-string">&quot;Sending CMD58...\r\n&quot;</span>);
      sdReadOcr(res);
      uartPuts(<span class="hljs-string">&quot;Response:\r\n&quot;</span>);
      sdPrintR3(res);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;3&#x27;</span>)
    {
      <span class="hljs-comment">// CMD55를 보내고 응답을 읽고 출력합니다</span>
      uartPuts(<span class="hljs-string">&quot;Sending CMD55...\r\n&quot;</span>);
      res[<span class="hljs-number">0</span>] = sdSendApp();
      uartPuts(<span class="hljs-string">&quot;Response:\r\n&quot;</span>);
      sdPrintR1(res[<span class="hljs-number">0</span>]);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;4&#x27;</span>)
    {
      <span class="hljs-comment">// ACMD41을 보내고 응답을 읽고 출력합니다</span>
      uartPuts(<span class="hljs-string">&quot;Sending ACMD41...\r\n&quot;</span>);
      res[<span class="hljs-number">0</span>] = sdSendOpCond();
      uartPuts(<span class="hljs-string">&quot;Response:\r\n&quot;</span>);
      sdPrintR1(res[<span class="hljs-number">0</span>]);
    }
    <span class="hljs-keyword">else</span>
    {
      uartPuts(<span class="hljs-string">&quot;Unrecognized command\r\n&quot;</span>);
    }
  }
}
</code></pre>
<p><code>CMD0</code>을 보낸 다음 <code>CMD8</code>과 <code>CMD58</code>을 보냅니다. SDCard가 Ready 되었다고 출력될 때까지 <code>CMD55</code>와 <code>ACMD41</code>을 차례대로 보냅니다.<br>
<img src="/assets/image/2022-09-02-AVR-ATmega328P-SDCard-3/AVR-ATmega328P-SDCard-3_3.png" alt="CLI 1"></p>
<p>SDCard가 Ready가 되었다면, CCS를 얻기 위해 마지막에 <code>CMD58</code>을 보냅니다.<br>
<img src="/assets/image/2022-09-02-AVR-ATmega328P-SDCard-3/AVR-ATmega328P-SDCard-3_4.png" alt="CLI 2"></p>
<p><code>ACMD41</code>을 처음 보낼 때는 IDLE 상태로 출력되었지만, 두 번째에는 Ready 상태임을 확인할 수 있습니다. 그 이후에 <code>CMD58</code>을 사용해서 OCR을 읽을 때 SDCard가 Power Up Process를 완료했으므로 CCS 비트가 유효하다고 볼 수 있습니다. 위의 경우에는 <code>1</code>로 설정되어 있는데, 이것은 SDXC 또는 SDHD를 사용하고 있음을 의미합니다.</p>
<h1>SDCard 초기화</h1>
<p>이제 SDCard를 초기화하는 <code>sdInit()</code>을 구현해 보겠습니다. SDCard 초기화를 구현하기 위해서 Power Up Diagram을 다시 봐봅시다:</p>
<p><img src="/assets/image/2022-08-28-AVR-ATmega328P-SDCard-1/AVR-ATmega328P-SDCard-1_3.png" alt="Power-up Diagram"></p>
<p>위의 다이어그램을 보면, <code>ACMD41</code>의 타임아웃은 1초입니다. 최소 1초 동안 SDCard 초기화를 계속 시도해야 합니다. 우리는 <code>ACMD41</code>을 다시 시도할 때 10ms의 Delay를 설정하고, 최대 100번을 시도하도록 구현할 것입니다.</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SD_READY    0</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SD_SUCCESS  0</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SD_ERROR    1</span>

<span class="hljs-type">uint8_t</span> <span class="hljs-title function_">sdInit</span><span class="hljs-params">()</span>
{
    <span class="hljs-type">uint8_t</span> res[<span class="hljs-number">5</span>], cmdAttempts = <span class="hljs-number">0</span>;

    sdPowerUpSeq();

    <span class="hljs-comment">/*
      CMD0을 보내서 SDCard를 IDLE로 만듭니다
      최대 10번 Retry 합니다
    */</span>
    <span class="hljs-keyword">while</span>((res[<span class="hljs-number">0</span>] = sdGoIdleState()) != <span class="hljs-number">0x01</span>)
    {
        cmdAttempts++;
        <span class="hljs-keyword">if</span>(cmdAttempts &gt; <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> SD_ERROR;
    }

    <span class="hljs-comment">// CMD8을 보냅니다</span>
    sdSendIfCond(res);
    <span class="hljs-keyword">if</span>(res[<span class="hljs-number">0</span>] != <span class="hljs-number">0x01</span>)
    {
        <span class="hljs-keyword">return</span> SD_ERROR;
    }

    <span class="hljs-comment">// Echo Pattern을 확인합니다</span>
    <span class="hljs-keyword">if</span>(res[<span class="hljs-number">4</span>] != <span class="hljs-number">0xAA</span>)
    {
        <span class="hljs-keyword">return</span> SD_ERROR;
    }

    <span class="hljs-comment">// ACMD41을 통해 SDCard 초기화를 시도합니다</span>
    cmdAttempts = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">do</span>
    {
        <span class="hljs-keyword">if</span>(cmdAttempts &gt; <span class="hljs-number">100</span>) <span class="hljs-keyword">return</span> SD_ERROR;

        <span class="hljs-comment">// ACMD41을 보내기전에 CMD55를 보냅니다</span>
        res[<span class="hljs-number">0</span>] = sdSendApp();

        <span class="hljs-comment">// Response에 Error가 없다면 ACMD41을 보냅니다</span>
        <span class="hljs-keyword">if</span>(res[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">2</span>)
        {
            res[<span class="hljs-number">0</span>] = sdSendOpCond();
        }

        <span class="hljs-comment">// 10ms동안 기다립니다</span>
        _delay_ms(<span class="hljs-number">10</span>);

        cmdAttempts++;
    }
    <span class="hljs-keyword">while</span>(res[<span class="hljs-number">0</span>] != SD_READY);

    <span class="hljs-comment">// OCR을 읽습니다</span>
    sdReadOcr(res);

    <span class="hljs-comment">// SDCard가 Ready 상태인지 확인합니다</span>
    <span class="hljs-keyword">if</span>(!(res[<span class="hljs-number">1</span>] &amp; <span class="hljs-number">0x80</span>)) <span class="hljs-keyword">return</span> SD_ERROR;

    <span class="hljs-keyword">return</span> SD_SUCCESS;
}
</code></pre>
<p>여기까지 모두 진행했다면 SPI 모드에서 SDCard를 초기화하는 것을 성공한 것입니다!</p>
</div></article></main><footer class="c-cpkrrK"><div class="c-fiqONv">© <!-- -->2023</div><div class="c-bHyrwK"><div class="c-iUFgVP">Kh.</div><div class="c-cshSRb">KyuHyuk Lee</div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"excerpt":" 이전 글 에서 CMD0 , CMD8 그리고 CMD58 을 사용하는 방법을 소개했습니다. 이제 SDCard의 초기화 과정을 거의 완료했습니다. 아래 다이어그램을 보면 다음 단계는 ACMD41 라는 것을 알 수 있습니다. ACMD41 (SD_SEND_OP_COND) ACMD41 (Send","url":"/article/avr/2022/09/02/AVR-ATmega328P-SDCard-3","frontmatter":{"title":"[AVR] ATmega328P SDCard 구현 (3)","date":"2022-09-02 23:57:51","category":"AVR"},"content":"\n[이전 글](https://kyuhyuk.kr/article/avr/2022/09/01/AVR-ATmega328P-SDCard-2)에서 `CMD0`, `CMD8` 그리고 `CMD58`을 사용하는 방법을 소개했습니다. 이제 SDCard의 초기화 과정을 거의 완료했습니다. 아래 다이어그램을 보면 다음 단계는 `ACMD41`라는 것을 알 수 있습니다.\n\n![SDCard SPI Mode Initalization Flow](/assets/image/2022-08-28-AVR-ATmega328P-SDCard-1/AVR-ATmega328P-SDCard-1_5.png)\n\n# `ACMD41` (SD_SEND_OP_COND)\n\n`ACMD41`(Send Operating Condition)는 SDCard의 초기화 과정을 시작합니다. 여기서 주의해야 하는 점은 `ACMD41`과 같이 `A`로 시작하는 Command는 사용하기 전에 `CMD55`(APP_CMD)를 보내서 다음에 사용하려는 Command이 `ACMD`라는 것을 SDCard에게 알려야 합니다.\n\n다음은 `CMD55`의 형식입니다:\n\n![CMD55 Format](/assets/image/2022-09-02-AVR-ATmega328P-SDCard-3/AVR-ATmega328P-SDCard-3_1.png)\n\n`ACMD41`의 형식은 아래와 같습니다:\n\n![ACMD41 Format](/assets/image/2022-09-02-AVR-ATmega328P-SDCard-3/AVR-ATmega328P-SDCard-3_2.png)\n\n`ACMD41`의 대부분 비트는 Reserved이지만, 고용량 카드를 지원함을 나타내기 위해 Bit 30을 1로 설정하는 부분이 있습니다. CRC는 이러한 명령에 대해 무시되므로 아무거나 설정할 수 있습니다.\n\n```c\n#define CMD55       55\n#define CMD55_ARG   0x00000000\n#define CMD55_CRC   0x00\n\n#define ACMD41      41\n#define ACMD41_ARG  0x40000000\n#define ACMD41_CRC  0x00\n```\n\n`ACMD41`은 `CMD41`과 마찬가지로 Command Index를 `41`을 사용합니다. `CMD55`가 먼저 전송되지 않는 경우에는 `CMD41`가 전송됩니다.\n\n`CMD55`와 `ACMD41`은 `R1`의 Response를 반환합니다.\n\n```c\nuint8_t sdSendApp()\n{\n    // SDCard CS Assert\n    spiTransfer(0xFF);\n    CS_ENABLE();\n    spiTransfer(0xFF);\n\n    // CMD55 전송\n    sdCommand(CMD55, CMD55_ARG, CMD55_CRC);\n\n    // Response를 읽습니다\n    uint8_t r1 = sdReadRes1();\n\n    // SDCard CS Deassert\n    spiTransfer(0xFF);\n    CS_DISABLE();\n    spiTransfer(0xFF);\n\n    return r1;\n}\n\nuint8_t sdSendOpCond()\n{\n    // SDCard CS Assert\n    spiTransfer(0xFF);\n    CS_ENABLE();\n    spiTransfer(0xFF);\n\n    // ACMD41 전송\n    sdCommand(ACMD41, ACMD41_ARG, ACMD41_CRC);\n\n    // Response를 읽습니다\n    uint8_t r1 = sdReadRes1();\n\n    // SDCard CS Deassert\n    spiTransfer(0xFF);\n    CS_DISABLE();\n    spiTransfer(0xFF);\n\n    return r1;\n}\n```\n\n위에서 설명했듯이 `ACMD41`은 초기화 과정을 시작합니다. Startup Sequence에서 SDCard가 `R1 = 0x00`인 'in_idle_state'로 응답할 때까지 `ACMD41`(항상 `CMD55`를 먼저 보내고 실행)을 계속 보냅니다.\n\n`R1 = 0x00`을 받으면 CCS 값을 보기 위해 `CMD58`을 보내야 합니다. CCS를 통해 SDCard가 SDHC(고용량 SDCard)인지 SCXC(확장 용량 SDCard)인지 알 수 있습니다.\n\n[이전 글](https://kyuhyuk.kr/article/avr/2022/09/01/AVR-ATmega328P-SDCard-2)에서 작성한 `main()`을 아래와 같이 수정합니다.\n\n```c\n/*\n  CPU의 Frequency를 16MHz로 설정합니다\n*/\n#define F_CPU 16000000UL\n#include \u003cutil/delay.h\u003e\n\nint main(void)\n{\n  uint8_t res[5];\n  char c;\n\n  // UART를 초기화 합니다\n  const unsigned int baudRate = (F_CPU / 16 / 9600) - 1;\n  uartInit(baudRate);\n\n  // SPI를 초기화 합니다\n  spiInit();\n\n  // SDCard에 VCC가 충분히 공급될때까지 기다립니다\n  _delay_ms(10);\n\n  // Power Up Sequence를 시작합니다\n  sdPowerUpSeq();\n\n  while (1)\n  {\n    // 메뉴를 출력합니다\n    uartPuts(\"MENU\\r\\n\");\n    uartPuts(\"------------------\\r\\n\");\n    uartPuts(\"0 - Send CMD0\\r\\n1 - Send CMD8\\r\\n2 - Send CMD58\\r\\n\");\n    uartPuts(\"3 - Send CMD55\\r\\n4 - Send ACMD41\\r\\n\");\n    uartPuts(\"------------------\\r\\n\");\n\n    // 사용자에게 명령(문자)를 입력받습니다\n    c = uartGet();\n\n    if (c == '0')\n    {\n      // CMD0을 보내고 응답을 읽고 출력합니다\n      uartPuts(\"Sending CMD0...\\r\\n\");\n      res[0] = sdGoIdleState();\n      uartPuts(\"Response:\\r\\n\");\n      sdPrintR1(res[0]);\n    }\n    else if (c == '1')\n    {\n      // CMD8을 보내고 응답을 읽고 출력합니다\n      uartPuts(\"Sending CMD8...\\r\\n\");\n      sdSendIfCond(res);\n      uartPuts(\"Response:\\r\\n\");\n      sdPrintR7(res);\n    }\n    else if (c == '2')\n    {\n      // CMD58을 보내고 응답을 읽고 출력합니다\n      uartPuts(\"Sending CMD58...\\r\\n\");\n      sdReadOcr(res);\n      uartPuts(\"Response:\\r\\n\");\n      sdPrintR3(res);\n    }\n    else if (c == '3')\n    {\n      // CMD55를 보내고 응답을 읽고 출력합니다\n      uartPuts(\"Sending CMD55...\\r\\n\");\n      res[0] = sdSendApp();\n      uartPuts(\"Response:\\r\\n\");\n      sdPrintR1(res[0]);\n    }\n    else if (c == '4')\n    {\n      // ACMD41을 보내고 응답을 읽고 출력합니다\n      uartPuts(\"Sending ACMD41...\\r\\n\");\n      res[0] = sdSendOpCond();\n      uartPuts(\"Response:\\r\\n\");\n      sdPrintR1(res[0]);\n    }\n    else\n    {\n      uartPuts(\"Unrecognized command\\r\\n\");\n    }\n  }\n}\n```\n\n`CMD0`을 보낸 다음 `CMD8`과 `CMD58`을 보냅니다. SDCard가 Ready 되었다고 출력될 때까지 `CMD55`와 `ACMD41`을 차례대로 보냅니다.  \n![CLI 1](/assets/image/2022-09-02-AVR-ATmega328P-SDCard-3/AVR-ATmega328P-SDCard-3_3.png)\n\nSDCard가 Ready가 되었다면, CCS를 얻기 위해 마지막에 `CMD58`을 보냅니다.  \n![CLI 2](/assets/image/2022-09-02-AVR-ATmega328P-SDCard-3/AVR-ATmega328P-SDCard-3_4.png)\n\n`ACMD41`을 처음 보낼 때는 IDLE 상태로 출력되었지만, 두 번째에는 Ready 상태임을 확인할 수 있습니다. 그 이후에 `CMD58`을 사용해서 OCR을 읽을 때 SDCard가 Power Up Process를 완료했으므로 CCS 비트가 유효하다고 볼 수 있습니다. 위의 경우에는 `1`로 설정되어 있는데, 이것은 SDXC 또는 SDHD를 사용하고 있음을 의미합니다.\n\n# SDCard 초기화\n\n이제 SDCard를 초기화하는 `sdInit()`을 구현해 보겠습니다. SDCard 초기화를 구현하기 위해서 Power Up Diagram을 다시 봐봅시다:\n\n![Power-up Diagram](/assets/image/2022-08-28-AVR-ATmega328P-SDCard-1/AVR-ATmega328P-SDCard-1_3.png)\n\n위의 다이어그램을 보면, `ACMD41`의 타임아웃은 1초입니다. 최소 1초 동안 SDCard 초기화를 계속 시도해야 합니다. 우리는 `ACMD41`을 다시 시도할 때 10ms의 Delay를 설정하고, 최대 100번을 시도하도록 구현할 것입니다.\n\n```c\n#define SD_READY    0\n#define SD_SUCCESS  0\n#define SD_ERROR    1\n\nuint8_t sdInit()\n{\n    uint8_t res[5], cmdAttempts = 0;\n\n    sdPowerUpSeq();\n\n    /*\n      CMD0을 보내서 SDCard를 IDLE로 만듭니다\n      최대 10번 Retry 합니다\n    */\n    while((res[0] = sdGoIdleState()) != 0x01)\n    {\n        cmdAttempts++;\n        if(cmdAttempts \u003e 10) return SD_ERROR;\n    }\n\n    // CMD8을 보냅니다\n    sdSendIfCond(res);\n    if(res[0] != 0x01)\n    {\n        return SD_ERROR;\n    }\n\n    // Echo Pattern을 확인합니다\n    if(res[4] != 0xAA)\n    {\n        return SD_ERROR;\n    }\n\n    // ACMD41을 통해 SDCard 초기화를 시도합니다\n    cmdAttempts = 0;\n    do\n    {\n        if(cmdAttempts \u003e 100) return SD_ERROR;\n\n        // ACMD41을 보내기전에 CMD55를 보냅니다\n        res[0] = sdSendApp();\n\n        // Response에 Error가 없다면 ACMD41을 보냅니다\n        if(res[0] \u003c 2)\n        {\n            res[0] = sdSendOpCond();\n        }\n\n        // 10ms동안 기다립니다\n        _delay_ms(10);\n\n        cmdAttempts++;\n    }\n    while(res[0] != SD_READY);\n\n    // OCR을 읽습니다\n    sdReadOcr(res);\n\n    // SDCard가 Ready 상태인지 확인합니다\n    if(!(res[1] \u0026 0x80)) return SD_ERROR;\n\n    return SD_SUCCESS;\n}\n```\n\n여기까지 모두 진행했다면 SPI 모드에서 SDCard를 초기화하는 것을 성공한 것입니다!\n"},"__N_SSG":true},"page":"/article/[category]/[year]/[month]/[day]/[slug]","query":{"category":"avr","year":"2022","month":"09","day":"02","slug":"AVR-ATmega328P-SDCard-3"},"buildId":"sFagy2B10ejf-tz-1N1o9","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>