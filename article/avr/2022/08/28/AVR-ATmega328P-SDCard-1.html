<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta property="og:image" content="https://kyuhyuk.kr/thumbnail.png"/><title>[AVR] ATmega328P SDCard 구현 (1)</title><meta name="author" content="KyuHyuk Lee"/><meta name="generator" content="KyuHyuk Lee"/><meta name="description" content=" SPI(Serial Peripheral Iterface) 모드에서 ATmega328P를 사용하여 SDCard를 초기화하는 방법을 소개합니다. SPI에 익숙하지 않은 경우에는 이 글 을 읽어보시기 바랍니다. 이 글에서 제공하는 정보의 대부분은 SDCard Physical Specific"/><meta itemProp="url" content="https://kyuhyuk.kr/article/avr/2022/08/28/AVR-ATmega328P-SDCard-1"/><meta itemProp="headline" content="[AVR] ATmega328P SDCard 구현 (1)"/><meta property="og:type" content="article"/><meta property="og:url" content="https://kyuhyuk.kr/article/avr/2022/08/28/AVR-ATmega328P-SDCard-1"/><meta property="og:title" content="[AVR] ATmega328P SDCard 구현 (1)"/><meta property="og:description" content=" SPI(Serial Peripheral Iterface) 모드에서 ATmega328P를 사용하여 SDCard를 초기화하는 방법을 소개합니다. SPI에 익숙하지 않은 경우에는 이 글 을 읽어보시기 바랍니다. 이 글에서 제공하는 정보의 대부분은 SDCard Physical Specific"/><meta property="og:site_name" content="KyuHyuk Blog"/><meta property="og:locale" content="ko_KR"/><meta name="next-head-count" content="15"/><style id="stitches">--sxs{--sxs:2 c-opBYf c-bHyrwK c-uBnvQ c-hehuMV c-bjkCdF c-hAoZGi c-jfcKOQ c-ezyKJG c-iAzQif c-bvdusc c-ezRQNp c-iosjjB c-jYwCTI c-iOPkYY c-cpkrrK c-fiqONv c-iUFgVP c-cshSRb c-fxvkZv c-dIcdES}@media{.c-opBYf{display:flex;align-items:center;background:#FFFFFF;height:60px;justify-content:space-between;-webkit-box-align:center;-webkit-box-pack:justify}.c-bHyrwK{display:flex;align-items:center;justify-content:center;-webkit-box-align:center;-webkit-box-pack:center}.c-uBnvQ{width:32px;height:32px;color:#FFFFFF;background:#000000;border-radius:4px;display:flex;align-items:center;justify-content:center;margin-right:12px;font-weight:700;cursor:default;-webkit-box-align:center;-webkit-box-pack:center}.c-hehuMV{font-weight:900;font-size:18px;letter-spacing:0.5px;color:#000000;cursor:default}.c-bjkCdF{list-style:none;padding:0;margin:0;display:flex;justify-content:center;align-items:center;font-size:24px;color:rgb(134, 142, 150);transition:all 0.3s ease 0s;-webkit-box-pack:center;-webkit-box-align:center}.c-hAoZGi{font-size:28px;color:inherit;text-decoration:none;margin:8px}.c-jfcKOQ{max-width:768px;margin-top:2rem;margin-left:auto;margin-right:auto}.c-ezyKJG{min-width:72px;display:flex;flex-direction:row;justify-content:center;align-items:center;padding:6px 16px;background:#12B886;box-shadow:0px 1px 2px rgba(98, 16, 204, 0.3);border:none;border-radius:14px;vertical-align:middle;color:#FFFFFF;font-size:1rem;height:2rem;float:right}.c-iAzQif{display:inline-block;margin-top:2rem}.c-bvdusc{font-size:2rem;line-height:1.5;letter-spacing:-0.004em;margin-top:0;margin-bottom:2rem;font-weight:700;color:#212529;word-break:keep-all;transition:color 0.125s ease-in 0s;}.c-ezRQNp{font-size:1.125rem;color:#212529;transition:color 0.125s ease-in 0s;;line-height:1.7;letter-spacing:-0.004em;word-break:break-all;overflow-wrap:break-word}.c-iosjjB{background:#F8F9FA;padding:0 1rem;height:2rem;border-radius:1rem;display:inline-flex;align-items:center;margin-right:0.875rem;color:#12B886;text-decoration:none;font-weight:400;font-size:1rem}.c-jYwCTI{font-size:1rem;color:#495057}.c-iOPkYY{margin-top:3rem;background-color:rgba(51,51,51,.1);border:0;height:1px}.c-cpkrrK{width:100%;height:300px;display:flex;align-items:center;justify-content:center;flex-direction:column;-webkit-box-align:center;-webkit-box-pack:center}.c-fiqONv{color:rgb(206, 212, 218);margin-bottom:8px;font-size:22px;font-weight:700}.c-iUFgVP{width:32px;height:32px;color:#FFFFFF;background:rgb(206, 212, 218);border-radius:4px;display:flex;align-items:center;justify-content:center;margin-right:12px;font-weight:700;cursor:default;-webkit-box-align:center;-webkit-box-pack:center}.c-cshSRb{font-weight:900;font-size:18px;letter-spacing:0.5px;color:rgb(206, 212, 218);cursor:default;text-transform:uppercase}.c-fxvkZv{font-size:2.5rem;line-height:1.5;letter-spacing:-0.004em;margin-top:0;margin-bottom:2rem;font-weight:700;color:#212529;word-break:keep-all;transition:color 0.125s ease-in 0s;}.c-dIcdES{margin-top:2rem;font-size:1.125rem;color:#212529;transition:color 0.125s ease-in 0s;;line-height:1.7;letter-spacing:-0.004em;word-break:keep-all;overflow-wrap:break-word}}</style><link rel="preload" href="/_next/static/css/98b299b94b0a7962.css" as="style"/><link rel="stylesheet" href="/_next/static/css/98b299b94b0a7962.css" data-n-g=""/><link rel="preload" href="/_next/static/css/c2a527101433f11d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c2a527101433f11d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-c354a30bda3d62a6.js" defer=""></script><script src="/_next/static/chunks/pages/_app-8265bb1a072646d3.js" defer=""></script><script src="/_next/static/chunks/776-f277552409ab147f.js" defer=""></script><script src="/_next/static/chunks/305-e325b960616dc0fd.js" defer=""></script><script src="/_next/static/chunks/pages/article/%5Bcategory%5D/%5Byear%5D/%5Bmonth%5D/%5Bday%5D/%5Bslug%5D-aa033f8eb8939164.js" defer=""></script><script src="/_next/static/FrFmlSEPIvXzRhY1fSPxA/_buildManifest.js" defer=""></script><script src="/_next/static/FrFmlSEPIvXzRhY1fSPxA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="c-opBYf"><a href="https://kyuhyuk.kr"><div class="c-bHyrwK"><div class="c-uBnvQ">Kh.</div><div class="c-hehuMV">KyuHyuk Blog</div></div></a><ul class="c-bjkCdF"><li><a href="https://github.com/LeeKyuHyuk" class="c-hAoZGi"><span role="img" aria-label="github" class="anticon anticon-github"><svg viewBox="64 64 896 896" focusable="false" data-icon="github" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0138.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"></path></svg></span></a></li><li><a href="https://linkedin.com/in/leekyuhyuk" class="c-hAoZGi"><span role="img" aria-label="linkedin" class="anticon anticon-linkedin"><svg viewBox="64 64 896 896" focusable="false" data-icon="linkedin" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zM349.3 793.7H230.6V411.9h118.7v381.8zm-59.3-434a68.8 68.8 0 1168.8-68.8c-.1 38-30.9 68.8-68.8 68.8zm503.7 434H675.1V608c0-44.3-.8-101.2-61.7-101.2-61.7 0-71.2 48.2-71.2 98v188.9H423.7V411.9h113.8v52.2h1.6c15.8-30 54.5-61.7 112.3-61.7 120.2 0 142.3 79.1 142.3 181.9v209.4z"></path></svg></span></a></li><li><a href="mailto:lee@kyuhyuk.kr" class="c-hAoZGi"><span role="img" aria-label="mail" class="anticon anticon-mail"><svg viewBox="64 64 896 896" focusable="false" data-icon="mail" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-80.8 108.9L531.7 514.4c-7.8 6.1-18.7 6.1-26.5 0L189.6 268.9A7.2 7.2 0 01194 256h648.8a7.2 7.2 0 014.4 12.9z"></path></svg></span></a></li></ul></header><main class="c-jfcKOQ"><article><h1 class="c-fxvkZv"><a href="https://kyuhyuk.kr/article/avr/2022/08/28/AVR-ATmega328P-SDCard-1">[AVR] ATmega328P SDCard 구현 (1)</a></h1><a href="https://kyuhyuk.kr/category/AVR" class="c-iosjjB">AVR</a><time dateTime="2022-08-28 16:49:27" class="c-jYwCTI">Aug 28, 2022 04:49:27 PM</time><div id="post" class="c-dIcdES"><p>SPI(Serial Peripheral Iterface) 모드에서 ATmega328P를 사용하여 SDCard를 초기화하는 방법을 소개합니다. SPI에 익숙하지 않은 경우에는 <a href="https://kyuhyuk.kr/article/avr/2022/08/28/AVR-ATmega328P-SPI">이 글</a>을 읽어보시기 바랍니다.</p>
<p>이 글에서 제공하는 정보의 대부분은 <a href="/assets/file/2022-08-28-AVR-ATmega328P-SDCard-1/Part_1_Physical_Layer_Simplified_Specification_Ver2.00_060925.pdf">SDCard Physical Specification</a>를 참고하였습니다.</p>
<h1>회로 연결</h1>
<p>아래와 같이 회로를 구성합니다. Arduino를 연결한 이유는 <code>avrdude</code>를 사용하여 ATmega328P의 Flash에 프로그래밍(Flash Write)하기 위해 연결했습니다.</p>
<p><img src="/assets/image/2022-08-28-AVR-ATmega328P-SDCard-1/AVR-ATmega328P-SDCard-1_1.png" alt="Connections"></p>
<h1>SPI 초기화</h1>
<p>SPI를 설정하려면 클럭의 극성, 위상 및 속도와 같은 몇 가지 설정이 필요합니다. 아쉽게도 버스 타이밍 다이어그램은 SDCard Physical Specification에는 없습니다. 그러나 다행이게도 <a href="/assets/file/2022-08-28-AVR-ATmega328P-SDCard-1/SecureDigitalCard_1.9.pdf">SanDisk SDCard 제품 설명서</a>에는 아래 타이밍 다이어그램이 제공됩니다.</p>
<p><img src="/assets/image/2022-08-28-AVR-ATmega328P-SDCard-1/AVR-ATmega328P-SDCard-1_2.png" alt="Timing Diagram Data Input/Output Referenced to Clock"></p>
<p>위의 그림과 같이 클럭은 LOW로 IDLE 상태를 유지하고 출력(OUTPUT)은 <code>CPOL = 0</code> 및 <code>CPHA = 0</code>에 해당하는 Leading Edge에서 샘플링됩니다. 이 작동 방식은 다른 SDCard에서도 동일하게 작동한다고 가정할 수 있습니다.</p>
<p><code>CPOL</code>과 <code>CPHA</code>는 SPI 제어 레지스터인 <code>SPCR</code>에서 기본적으로 <code>00</code>으로 설정되어 있으므로 SPI 초기화 과정에서 이것에 대해서는 아무것도 할 필요가 없습니다. 최신 SDCard는 매우 빠른 속도로 작동할 수 있지만, 일단은 디버깅을 위해 SCK를 가장 낮은 값으로 설정하고 나중에 코드가 작동하면 다시 높일 계획입니다.</p>
<p>코드에 사용되는 핀을 추상화하려면 기능적 이름을 지정하는게 좋습니다. 또한 SDCard에 대한 모든 SPI 명령은 마이크로컨트롤러가 먼저 <code>CS</code>(Chip Select)라인을 Assert(Inactive에서 Active 상태로 전환) 해야 합니다. 이것이 완료되면 CS를 HIGH 상태로 되돌려야 합니다. 이러한 간단한 명령을 간단하게 전처리기 매크로를 사용하여 구현합니다.</p>
<p>아래는 SPI 초기화 및 송신/수신 기능과 핀 정의 및 유용한 매크로가 있는 코드입니다:</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DDR_SPI         DDRB</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> PORT_SPI        PORTB</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CS              PINB2</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MOSI            PINB3</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MISO            PINB4</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SCK             PINB5</span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> CS_ENABLE()     PORT_SPI &amp;= ~(1 &lt;&lt; CS)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CS_DISABLE()    PORT_SPI |= (1 &lt;&lt; CS)</span>

<span class="hljs-type">void</span> <span class="hljs-title function_">spiInit</span><span class="hljs-params">()</span>
{
    <span class="hljs-comment">// CS와 MOSI, SCK를 출력으로 설정합니다</span>
    DDR_SPI |= (<span class="hljs-number">1</span> &lt;&lt; CS) | (<span class="hljs-number">1</span> &lt;&lt; MOSI) | (<span class="hljs-number">1</span> &lt;&lt; SCK);

    <span class="hljs-comment">// MISO를 Pull-up 레지스터로 활성화 합니다</span>
    DDR_SPI |= (<span class="hljs-number">1</span> &lt;&lt; MISO);

    <span class="hljs-comment">// SPI를 활성화하고 Master로 Clock은 fOSC/128로 설정합니다.</span>
    SPCR = (<span class="hljs-number">1</span> &lt;&lt; SPE) | (<span class="hljs-number">1</span> &lt;&lt; MSTR) | (<span class="hljs-number">1</span> &lt;&lt; SPR1) | (<span class="hljs-number">1</span> &lt;&lt; SPR0);
}

<span class="hljs-type">uint8_t</span> <span class="hljs-title function_">spiTransfer</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> data)</span>
{
    <span class="hljs-comment">// SPI로 전송할 데이터를 SPDR(SPI Data Register)에 저장</span>
    SPDR = data;

    <span class="hljs-comment">/*
      SPIF(SPI Interrupt Flag)가 Set될 때까지 기다립니다
      SPIF가 Set이 되었다면 SPI로 데이터가 전송이 완료된것입니다
    */</span>
    <span class="hljs-keyword">while</span>(!(SPSR &amp; (<span class="hljs-number">1</span> &lt;&lt; SPIF)));

    <span class="hljs-comment">// SPDR을 반환합니다</span>
    <span class="hljs-keyword">return</span> SPDR;
}
</code></pre>
<h1>Power Up Sequence</h1>
<p>SDCard Physical Specification에서 Power Up Sequence는 아래와 같습니다.</p>
<p><img src="/assets/image/2022-08-28-AVR-ATmega328P-SDCard-1/AVR-ATmega328P-SDCard-1_3.png" alt="Power-up Diagram"></p>
<p>SDCard에 명령을 보내기 전에는 최소 1msec의 Delay와 74개의 클럭 사이클을 보내야 합니다. 각 바이트에 대해 8개의 클럭 사이클이 있으므로 총 80개의 클럭 사이클에 대해 10바이트를 보낼 수 있습니다. 또한 이 작업을 할 동안에는 CS를 HIGH로 유지해야 합니다.</p>
<pre><code class="language-c"><span class="hljs-comment">/* CPU의 Frequency를 16MHz로 설정합니다 */</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> F_CPU 16000000UL</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;util/delay.h&gt;</span></span>

<span class="hljs-type">void</span> <span class="hljs-title function_">sdPowerUpSeq</span><span class="hljs-params">()</span>
{
    <span class="hljs-comment">// SDCard CS Assert</span>
    CS_ENABLE();

    <span class="hljs-comment">// SDCard에 전원이 공급되는데 최소로 필요한 1msec의 Dealy 실행</span>
    _delay_ms(<span class="hljs-number">1</span>);

    <span class="hljs-comment">/*
      동기화하기 위해 80개의 클럭사이클을 보냅니다
      SPI는 직렬 통신이기 때문에 각 클럭 사이클당 1비트의 데이터가 전송됩니다
      0xFF(11111111b)는 8비트이기 때문에 10번을 보내면
      80개의 클럭 사이클을 보내는 것과 같습니다
    */</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">uint8_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)
        spiTransfer(<span class="hljs-number">0xFF</span>);

    <span class="hljs-comment">// SDCard CS Deassert</span>
    CS_DISABLE();
    spiTransfer(<span class="hljs-number">0xFF</span>);
}
</code></pre>
<h1>SDCard Command 전송</h1>
<p>아래는 SDCard Command의 포맷입니다. 모든 Command의 길이는 6바이트이며 Command Index, Arguments와 CRC가 포함되어 있습니다. Command Index는 SDCard에 어떤 명령을 보내고 있는지 알려주는데 사용됩니다. 예를 들어 <code>CMD0</code>을 전송하는 경우에는 Command Index의 6비트를 <code>000000b</code>로 설정합니다. Arguments 필드는 일부 명령에서 사용되며 다른 명령에서는 SDCard에서 무시됩니다. Arguments가 필요하지 않을 때마다 이 필드를 모두 <code>0</code>으로 채웁니다. 마지막으로 CRC(Cyclic Redundancy Check)를 사용하여 명령 내용이 SDCard에서 올바르게 수신되었는지 확인합니다. 참고로 SPI 모드에서는 몇 가지 명령만 올바른 CRC를 필요로 합니다. 필요하지 않은 경우에는 모두 <code>0</code>으로 설정합니다.</p>
<p><img src="/assets/image/2022-08-28-AVR-ATmega328P-SDCard-1/AVR-ATmega328P-SDCard-1_4.png" alt="Command Format"></p>
<p>아래는 SDCard에 Command를 전송하는 함수입니다. 8비트의 Command Index, 32비트의 Arguments와 8비트의 CRC를 전달합니다.</p>
<pre><code class="language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">sdCommand</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> cmd, <span class="hljs-type">uint32_t</span> arg, <span class="hljs-type">uint8_t</span> crc)</span>
{
    <span class="hljs-comment">// SDCard에 Command를 전송합니다</span>
    spiTransfer(cmd | <span class="hljs-number">0x40</span>);

    <span class="hljs-comment">// Argument를 전송합니다</span>
    spiTransfer((<span class="hljs-type">uint8_t</span>)(arg &gt;&gt; <span class="hljs-number">24</span>));
    spiTransfer((<span class="hljs-type">uint8_t</span>)(arg &gt;&gt; <span class="hljs-number">16</span>));
    spiTransfer((<span class="hljs-type">uint8_t</span>)(arg &gt;&gt; <span class="hljs-number">8</span>));
    spiTransfer((<span class="hljs-type">uint8_t</span>)(arg));

    <span class="hljs-comment">// CRC를 전송합니다</span>
    spiTransfer(crc | <span class="hljs-number">0x01</span>);
}
</code></pre>
<p>Command Index를 전송하는 것으로 시작합니다. 그러나 Command Format을 보면 Command Index의 길이는 6비트입니다. 명령의 최상위 2비트는 항상 <code>01b</code>로 설정됩니다. 우리가 항상 128보다 작은 Command Index를 전달하려면 <code>cmd</code> 인수의 48번째 Bit는 항상 0이 됩니다. 그러나 47번째 Bit를 1로 설정하려면 <code>cmd</code>를 <code>0x40</code>과 OR 연산을 해야 합니다.</p>
<pre><code class="language-c">    <span class="hljs-comment">// SDCard에 Command를 전송합니다</span>
    spiTransfer(cmd | <span class="hljs-number">0x40</span>);
</code></pre>
<p>다음으로 4바이트 Argument를 8비트씩 아래로 이동하면서, 한 번에 한 바이트씩 전송합니다.</p>
<pre><code class="language-c">    <span class="hljs-comment">// Argument를 전송합니다</span>
    spiTransfer((<span class="hljs-type">uint8_t</span>)(arg &gt;&gt; <span class="hljs-number">24</span>));
    spiTransfer((<span class="hljs-type">uint8_t</span>)(arg &gt;&gt; <span class="hljs-number">16</span>));
    spiTransfer((<span class="hljs-type">uint8_t</span>)(arg &gt;&gt; <span class="hljs-number">8</span>));
    spiTransfer((<span class="hljs-type">uint8_t</span>)(arg));
</code></pre>
<p>마지막으로 CRC를 전송합니다. CRC의 길이는 7비트에 불과하고 모든 명령의 마지막 비트는 항상 <code>1</code>로 설정됩니다. 더 쉽게 구현하기 위해 <code>crc</code> 인수를 <code>0x01</code>과 OR 연산하여 최종 비트가 항상 <code>1</code>이 되도록 합니다.</p>
<pre><code class="language-c">    <span class="hljs-comment">// CRC를 전송합니다</span>
    spiTransfer(crc | <span class="hljs-number">0x01</span>);
</code></pre>
<h1>SDCard 초기화 과정</h1>
<p>SD 카드의 SPI 모드 초기화 과정은 아래 다이어그램과 같습니다:</p>
<p><img src="/assets/image/2022-08-28-AVR-ATmega328P-SDCard-1/AVR-ATmega328P-SDCard-1_5.png" alt="SDCard SPI Mode Initalization Flow"></p>
<p>이 과정의 첫 번째 단계는 <code>CMD0</code>을 보내는 것입니다. 아래는 SDCard Physical Specification의 <code>CMD0</code>에 대한 설명입니다.</p>
<p><img src="/assets/image/2022-08-28-AVR-ATmega328P-SDCard-1/AVR-ATmega328P-SDCard-1_6.png" alt="CMD0 Description"></p>
<p><code>CMD0</code>은 SDCard에 대해 Software Reset을 합니다. Argument는 'Stuff Bits'이며, 이는 SDCard에서 무시되고 응답은 R1으로 받습니다.</p>
<p>SPI 모드는 SDCard를 위한 보조 통신 모드입니다. 'SD Bus Protocol Mode'에서 전원이 켜지며, <code>CS</code>(Chip Select)가 LOW로 구동되고 <code>CMD0</code>가 전송될 때만 SDCard가 SPI로 전환됩니다. SPI 모드에서 CRC는 기본적으로 무시되지만 시작되는 SD Bus Mode에서는 CRC가 필요합니다. 따라서 첫 번째 명령의 경우 올바른 체크섬이 있어야 합니다.</p>
<p>Command에서 Command Index를 0으로 설정하여 <code>CMD0</code>을 간단하게 지정하고, Argument는 Stuff Bits이므로 <code>0x00000000</code>으로 설정합니다. 이제 이 비트에 해당하는 CRC가 필요한데, 다행이게도 SDCard Physical Specification 43페이지를 보면 <code>10010100b</code>라는 7비트의 값을 제공합니다.</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD0        0</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD0_ARG    0x00000000</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD0_CRC    0x94</span>

<span class="hljs-comment">// CMD0 전송</span>
sdCommand(CMD0, CMD0_ARG, CMD0_CRC);
</code></pre>
<p>위에서 설명했듯이 <code>CMD0</code>은 R1 응답을 반환합니다. R1의 형태는 아래와 같습니다:</p>
<p><img src="/assets/image/2022-08-28-AVR-ATmega328P-SDCard-1/AVR-ATmega328P-SDCard-1_7.png" alt="R1 Response Format"></p>
<p>R1은 7번째 Bit가 항상 <code>0</code>이고 다른 모든 비트는 오류 조건을 나타내는 단일 바이트입니다.</p>
<p>이것을 알면 <code>CMD0</code>을 보낸 후 단일 바이트 응답을 찾는 함수를 작성할 수 있습니다.</p>
<pre><code class="language-c"><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">sdReadRes1</span><span class="hljs-params">()</span>
{
    <span class="hljs-type">uint8_t</span> index = <span class="hljs-number">0</span>, res1;

    <span class="hljs-comment">// 실제 데이터가 수신될 떄까지 폴링을 유지합니다.</span>
    <span class="hljs-keyword">while</span>((res1 = spiTransfer(<span class="hljs-number">0xFF</span>)) == <span class="hljs-number">0xFF</span>)
    {
        index++;
        <span class="hljs-comment">// 8바이트 동안 수신된 데이터가 없으면 멈춥니다</span>
        <span class="hljs-keyword">if</span>(index &gt; <span class="hljs-number">8</span>) <span class="hljs-keyword">break</span>;
    }

    <span class="hljs-keyword">return</span> res1;
}
</code></pre>
<p><code>MISO</code>는 기본값이 HIGH이기 때문에, SDCard가 응답하지 않으면 단순히 <code>0xFF</code>를 읽습니다. SDCard는 명령이 전송된 후 처리하는데 시간이 걸릴 수 있으므로 데이터를 수신할 때까지 폴링을 계속합니다. 그러나 카드는 8 Cycle 이내에 응답해야 합니다. 그때까지 응답하지 않으면 응답을 중단하고 반환합니다. (이런 경우에는 <code>0xFF</code>를 반환하게 됩니다)</p>
<p>이 모든 것을 종합하면 <code>CMD0</code>(<code>GO_IDLE_STATE</code>)를 보내는 전체 시퀀스를 아래와 같이 작성할 수 있습니다:</p>
<pre><code class="language-c"><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">sdGoIdleState</span><span class="hljs-params">()</span>
{
    <span class="hljs-comment">// SDCard CS Assert</span>
    spiTransfer(<span class="hljs-number">0xFF</span>);
    CS_ENABLE();
    spiTransfer(<span class="hljs-number">0xFF</span>);

    <span class="hljs-comment">// CMD0를 전송합니다</span>
    sdCommand(CMD0, CMD0_ARG, CMD0_CRC);

    <span class="hljs-comment">// Response를 읽습니다</span>
    <span class="hljs-type">uint8_t</span> res1 = sdReadRes1();

    <span class="hljs-comment">// SDCard CS Deassert</span>
    spiTransfer(<span class="hljs-number">0xFF</span>);
    CS_DISABLE();
    spiTransfer(<span class="hljs-number">0xFF</span>);

    <span class="hljs-keyword">return</span> res1;
}
</code></pre>
<p>여기에서 <code>CS</code>를 LOW로 하기 전과 후에 8개의 클럭을 보내고, 명령을 보내기 전에 또 다른 8개의 클럭을 보냅니다. 이는 SDCard가 <code>CS</code>의 변경 사항을 인식하도록 하는 것입니다. 또한 <code>CS</code>를 HIGH로 전환하기 전후에 추가 바이트를 전송합니다. 이러한 추가적인 바이트 전송이 항상 필요한 것은 아니지만 여러 SDCard가 버스에 있다면 이러한 방법으로 문제를 피할 수 있습니다.</p>
<h1>ATmega328P에서 실행하기</h1>
<p>위에서 작성한 모든 코드를 합쳐서 ATmega328P에서 실행해 봅시다. 아래는 이 글에서 정의한 함수를 사용하는 <code>main()</code> 함수입니다. 여기에서는 단순히 Power Up Sequence를 살펴보고 SDCard를 IDLE 상태로 만듭니다.</p>
<pre><code class="language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    <span class="hljs-comment">// SPI 초기화</span>
    spiInit();

    <span class="hljs-comment">// Power Up Sequence 시작</span>
    sdPowerUpSeq();

    <span class="hljs-comment">// command card to idle</span>
    sdGoIdleState();

    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);
}
</code></pre>
<p>Logic Analyzer를 사용하여 의도한 대로 작동하는지 봐봅시다.<br>
아래와 같이 Logic Analyzer를 설정했습니다.</p>
<p><img src="/assets/image/2022-08-28-AVR-ATmega328P-SDCard-1/AVR-ATmega328P-SDCard-1_8.png" alt="Logic Analyzer Setting"></p>
<p>Logic Analyzer를 사용하면 아래와 같은 화면이 출력됩니다.</p>
<p><img src="/assets/image/2022-08-28-AVR-ATmega328P-SDCard-1/AVR-ATmega328P-SDCard-1_9.png" alt="Logic Analyzer"></p>
<p>전송된 첫 번째 바이트는 <code>0x40</code>(<code>CMD0 | 0x40</code>)이고 Argument는 모두 <code>0</code>이며 마지막 바이트는 <code>0x95</code> 입니다. 응답하기 위해 명령을 보낸 후 SDCard에 8 Clock Cycle이 전송됩니다. 일단 실행되면 <code>0x01</code>을 보내며, R1에 대한 정의를 다시 확인하면 SDCard가 IDLE 상태(오류가 없는)인 것을 확인할 수 있으며 정상적으로 Command 전달이 작동한 것을 알 수 있습니다.</p>
</div></article></main><footer class="c-cpkrrK"><div class="c-fiqONv">© <!-- -->2022</div><div class="c-bHyrwK"><div class="c-iUFgVP">Kh.</div><div class="c-cshSRb">KyuHyuk Lee</div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"excerpt":" SPI(Serial Peripheral Iterface) 모드에서 ATmega328P를 사용하여 SDCard를 초기화하는 방법을 소개합니다. SPI에 익숙하지 않은 경우에는 이 글 을 읽어보시기 바랍니다. 이 글에서 제공하는 정보의 대부분은 SDCard Physical Specific","url":"/article/avr/2022/08/28/AVR-ATmega328P-SDCard-1","frontmatter":{"title":"[AVR] ATmega328P SDCard 구현 (1)","date":"2022-08-28 16:49:27","category":"AVR"},"content":"\nSPI(Serial Peripheral Iterface) 모드에서 ATmega328P를 사용하여 SDCard를 초기화하는 방법을 소개합니다. SPI에 익숙하지 않은 경우에는 [이 글](https://kyuhyuk.kr/article/avr/2022/08/28/AVR-ATmega328P-SPI)을 읽어보시기 바랍니다.\n\n이 글에서 제공하는 정보의 대부분은 [SDCard Physical Specification](/assets/file/2022-08-28-AVR-ATmega328P-SDCard-1/Part_1_Physical_Layer_Simplified_Specification_Ver2.00_060925.pdf)를 참고하였습니다.\n\n# 회로 연결\n\n아래와 같이 회로를 구성합니다. Arduino를 연결한 이유는 `avrdude`를 사용하여 ATmega328P의 Flash에 프로그래밍(Flash Write)하기 위해 연결했습니다.\n\n![Connections](/assets/image/2022-08-28-AVR-ATmega328P-SDCard-1/AVR-ATmega328P-SDCard-1_1.png)\n\n# SPI 초기화\n\nSPI를 설정하려면 클럭의 극성, 위상 및 속도와 같은 몇 가지 설정이 필요합니다. 아쉽게도 버스 타이밍 다이어그램은 SDCard Physical Specification에는 없습니다. 그러나 다행이게도 [SanDisk SDCard 제품 설명서](/assets/file/2022-08-28-AVR-ATmega328P-SDCard-1/SecureDigitalCard_1.9.pdf)에는 아래 타이밍 다이어그램이 제공됩니다.\n\n![Timing Diagram Data Input/Output Referenced to Clock](/assets/image/2022-08-28-AVR-ATmega328P-SDCard-1/AVR-ATmega328P-SDCard-1_2.png)\n\n위의 그림과 같이 클럭은 LOW로 IDLE 상태를 유지하고 출력(OUTPUT)은 `CPOL = 0` 및 `CPHA = 0`에 해당하는 Leading Edge에서 샘플링됩니다. 이 작동 방식은 다른 SDCard에서도 동일하게 작동한다고 가정할 수 있습니다.\n\n`CPOL`과 `CPHA`는 SPI 제어 레지스터인 `SPCR`에서 기본적으로 `00`으로 설정되어 있으므로 SPI 초기화 과정에서 이것에 대해서는 아무것도 할 필요가 없습니다. 최신 SDCard는 매우 빠른 속도로 작동할 수 있지만, 일단은 디버깅을 위해 SCK를 가장 낮은 값으로 설정하고 나중에 코드가 작동하면 다시 높일 계획입니다.\n\n코드에 사용되는 핀을 추상화하려면 기능적 이름을 지정하는게 좋습니다. 또한 SDCard에 대한 모든 SPI 명령은 마이크로컨트롤러가 먼저 `CS`(Chip Select)라인을 Assert(Inactive에서 Active 상태로 전환) 해야 합니다. 이것이 완료되면 CS를 HIGH 상태로 되돌려야 합니다. 이러한 간단한 명령을 간단하게 전처리기 매크로를 사용하여 구현합니다.\n\n아래는 SPI 초기화 및 송신/수신 기능과 핀 정의 및 유용한 매크로가 있는 코드입니다:\n\n```c\n#define DDR_SPI         DDRB\n#define PORT_SPI        PORTB\n#define CS              PINB2\n#define MOSI            PINB3\n#define MISO            PINB4\n#define SCK             PINB5\n\n#define CS_ENABLE()     PORT_SPI \u0026= ~(1 \u003c\u003c CS)\n#define CS_DISABLE()    PORT_SPI |= (1 \u003c\u003c CS)\n\nvoid spiInit()\n{\n    // CS와 MOSI, SCK를 출력으로 설정합니다\n    DDR_SPI |= (1 \u003c\u003c CS) | (1 \u003c\u003c MOSI) | (1 \u003c\u003c SCK);\n\n    // MISO를 Pull-up 레지스터로 활성화 합니다\n    DDR_SPI |= (1 \u003c\u003c MISO);\n\n    // SPI를 활성화하고 Master로 Clock은 fOSC/128로 설정합니다.\n    SPCR = (1 \u003c\u003c SPE) | (1 \u003c\u003c MSTR) | (1 \u003c\u003c SPR1) | (1 \u003c\u003c SPR0);\n}\n\nuint8_t spiTransfer(uint8_t data)\n{\n    // SPI로 전송할 데이터를 SPDR(SPI Data Register)에 저장\n    SPDR = data;\n\n    /*\n      SPIF(SPI Interrupt Flag)가 Set될 때까지 기다립니다\n      SPIF가 Set이 되었다면 SPI로 데이터가 전송이 완료된것입니다\n    */\n    while(!(SPSR \u0026 (1 \u003c\u003c SPIF)));\n\n    // SPDR을 반환합니다\n    return SPDR;\n}\n```\n\n# Power Up Sequence\n\nSDCard Physical Specification에서 Power Up Sequence는 아래와 같습니다.\n\n![Power-up Diagram](/assets/image/2022-08-28-AVR-ATmega328P-SDCard-1/AVR-ATmega328P-SDCard-1_3.png)\n\nSDCard에 명령을 보내기 전에는 최소 1msec의 Delay와 74개의 클럭 사이클을 보내야 합니다. 각 바이트에 대해 8개의 클럭 사이클이 있으므로 총 80개의 클럭 사이클에 대해 10바이트를 보낼 수 있습니다. 또한 이 작업을 할 동안에는 CS를 HIGH로 유지해야 합니다.\n\n```c\n/* CPU의 Frequency를 16MHz로 설정합니다 */\n#define F_CPU 16000000UL\n#include\u003cutil/delay.h\u003e\n\nvoid sdPowerUpSeq()\n{\n    // SDCard CS Assert\n    CS_ENABLE();\n\n    // SDCard에 전원이 공급되는데 최소로 필요한 1msec의 Dealy 실행\n    _delay_ms(1);\n\n    /*\n      동기화하기 위해 80개의 클럭사이클을 보냅니다\n      SPI는 직렬 통신이기 때문에 각 클럭 사이클당 1비트의 데이터가 전송됩니다\n      0xFF(11111111b)는 8비트이기 때문에 10번을 보내면\n      80개의 클럭 사이클을 보내는 것과 같습니다\n    */\n    for(uint8_t i = 0; i \u003c 10; i++)\n        spiTransfer(0xFF);\n\n    // SDCard CS Deassert\n    CS_DISABLE();\n    spiTransfer(0xFF);\n}\n```\n\n# SDCard Command 전송\n\n아래는 SDCard Command의 포맷입니다. 모든 Command의 길이는 6바이트이며 Command Index, Arguments와 CRC가 포함되어 있습니다. Command Index는 SDCard에 어떤 명령을 보내고 있는지 알려주는데 사용됩니다. 예를 들어 `CMD0`을 전송하는 경우에는 Command Index의 6비트를 `000000b`로 설정합니다. Arguments 필드는 일부 명령에서 사용되며 다른 명령에서는 SDCard에서 무시됩니다. Arguments가 필요하지 않을 때마다 이 필드를 모두 `0`으로 채웁니다. 마지막으로 CRC(Cyclic Redundancy Check)를 사용하여 명령 내용이 SDCard에서 올바르게 수신되었는지 확인합니다. 참고로 SPI 모드에서는 몇 가지 명령만 올바른 CRC를 필요로 합니다. 필요하지 않은 경우에는 모두 `0`으로 설정합니다.\n\n![Command Format](/assets/image/2022-08-28-AVR-ATmega328P-SDCard-1/AVR-ATmega328P-SDCard-1_4.png)\n\n아래는 SDCard에 Command를 전송하는 함수입니다. 8비트의 Command Index, 32비트의 Arguments와 8비트의 CRC를 전달합니다.\n\n```c\nvoid sdCommand(uint8_t cmd, uint32_t arg, uint8_t crc)\n{\n    // SDCard에 Command를 전송합니다\n    spiTransfer(cmd | 0x40);\n\n    // Argument를 전송합니다\n    spiTransfer((uint8_t)(arg \u003e\u003e 24));\n    spiTransfer((uint8_t)(arg \u003e\u003e 16));\n    spiTransfer((uint8_t)(arg \u003e\u003e 8));\n    spiTransfer((uint8_t)(arg));\n\n    // CRC를 전송합니다\n    spiTransfer(crc | 0x01);\n}\n```\n\nCommand Index를 전송하는 것으로 시작합니다. 그러나 Command Format을 보면 Command Index의 길이는 6비트입니다. 명령의 최상위 2비트는 항상 `01b`로 설정됩니다. 우리가 항상 128보다 작은 Command Index를 전달하려면 `cmd` 인수의 48번째 Bit는 항상 0이 됩니다. 그러나 47번째 Bit를 1로 설정하려면 `cmd`를 `0x40`과 OR 연산을 해야 합니다.\n\n```c\n    // SDCard에 Command를 전송합니다\n    spiTransfer(cmd | 0x40);\n```\n\n다음으로 4바이트 Argument를 8비트씩 아래로 이동하면서, 한 번에 한 바이트씩 전송합니다.\n\n```c\n    // Argument를 전송합니다\n    spiTransfer((uint8_t)(arg \u003e\u003e 24));\n    spiTransfer((uint8_t)(arg \u003e\u003e 16));\n    spiTransfer((uint8_t)(arg \u003e\u003e 8));\n    spiTransfer((uint8_t)(arg));\n```\n\n마지막으로 CRC를 전송합니다. CRC의 길이는 7비트에 불과하고 모든 명령의 마지막 비트는 항상 `1`로 설정됩니다. 더 쉽게 구현하기 위해 `crc` 인수를 `0x01`과 OR 연산하여 최종 비트가 항상 `1`이 되도록 합니다.\n\n```c\n    // CRC를 전송합니다\n    spiTransfer(crc | 0x01);\n```\n\n# SDCard 초기화 과정\n\nSD 카드의 SPI 모드 초기화 과정은 아래 다이어그램과 같습니다:\n\n![SDCard SPI Mode Initalization Flow](/assets/image/2022-08-28-AVR-ATmega328P-SDCard-1/AVR-ATmega328P-SDCard-1_5.png)\n\n이 과정의 첫 번째 단계는 `CMD0`을 보내는 것입니다. 아래는 SDCard Physical Specification의 `CMD0`에 대한 설명입니다.\n\n![CMD0 Description](/assets/image/2022-08-28-AVR-ATmega328P-SDCard-1/AVR-ATmega328P-SDCard-1_6.png)\n\n`CMD0`은 SDCard에 대해 Software Reset을 합니다. Argument는 'Stuff Bits'이며, 이는 SDCard에서 무시되고 응답은 R1으로 받습니다.\n\nSPI 모드는 SDCard를 위한 보조 통신 모드입니다. 'SD Bus Protocol Mode'에서 전원이 켜지며, `CS`(Chip Select)가 LOW로 구동되고 `CMD0`가 전송될 때만 SDCard가 SPI로 전환됩니다. SPI 모드에서 CRC는 기본적으로 무시되지만 시작되는 SD Bus Mode에서는 CRC가 필요합니다. 따라서 첫 번째 명령의 경우 올바른 체크섬이 있어야 합니다.\n\nCommand에서 Command Index를 0으로 설정하여 `CMD0`을 간단하게 지정하고, Argument는 Stuff Bits이므로 `0x00000000`으로 설정합니다. 이제 이 비트에 해당하는 CRC가 필요한데, 다행이게도 SDCard Physical Specification 43페이지를 보면 `10010100b`라는 7비트의 값을 제공합니다.\n\n```c\n#define CMD0        0\n#define CMD0_ARG    0x00000000\n#define CMD0_CRC    0x94\n\n// CMD0 전송\nsdCommand(CMD0, CMD0_ARG, CMD0_CRC);\n```\n\n위에서 설명했듯이 `CMD0`은 R1 응답을 반환합니다. R1의 형태는 아래와 같습니다:\n\n![R1 Response Format](/assets/image/2022-08-28-AVR-ATmega328P-SDCard-1/AVR-ATmega328P-SDCard-1_7.png)\n\nR1은 7번째 Bit가 항상 `0`이고 다른 모든 비트는 오류 조건을 나타내는 단일 바이트입니다.\n\n이것을 알면 `CMD0`을 보낸 후 단일 바이트 응답을 찾는 함수를 작성할 수 있습니다.\n\n```c\nuint8_t sdReadRes1()\n{\n    uint8_t index = 0, res1;\n\n    // 실제 데이터가 수신될 떄까지 폴링을 유지합니다.\n    while((res1 = spiTransfer(0xFF)) == 0xFF)\n    {\n        index++;\n        // 8바이트 동안 수신된 데이터가 없으면 멈춥니다\n        if(index \u003e 8) break;\n    }\n\n    return res1;\n}\n```\n\n`MISO`는 기본값이 HIGH이기 때문에, SDCard가 응답하지 않으면 단순히 `0xFF`를 읽습니다. SDCard는 명령이 전송된 후 처리하는데 시간이 걸릴 수 있으므로 데이터를 수신할 때까지 폴링을 계속합니다. 그러나 카드는 8 Cycle 이내에 응답해야 합니다. 그때까지 응답하지 않으면 응답을 중단하고 반환합니다. (이런 경우에는 `0xFF`를 반환하게 됩니다)\n\n이 모든 것을 종합하면 `CMD0`(`GO_IDLE_STATE`)를 보내는 전체 시퀀스를 아래와 같이 작성할 수 있습니다:\n\n```c\nuint8_t sdGoIdleState()\n{\n    // SDCard CS Assert\n    spiTransfer(0xFF);\n    CS_ENABLE();\n    spiTransfer(0xFF);\n\n    // CMD0를 전송합니다\n    sdCommand(CMD0, CMD0_ARG, CMD0_CRC);\n\n    // Response를 읽습니다\n    uint8_t res1 = sdReadRes1();\n\n    // SDCard CS Deassert\n    spiTransfer(0xFF);\n    CS_DISABLE();\n    spiTransfer(0xFF);\n\n    return res1;\n}\n```\n\n여기에서 `CS`를 LOW로 하기 전과 후에 8개의 클럭을 보내고, 명령을 보내기 전에 또 다른 8개의 클럭을 보냅니다. 이는 SDCard가 `CS`의 변경 사항을 인식하도록 하는 것입니다. 또한 `CS`를 HIGH로 전환하기 전후에 추가 바이트를 전송합니다. 이러한 추가적인 바이트 전송이 항상 필요한 것은 아니지만 여러 SDCard가 버스에 있다면 이러한 방법으로 문제를 피할 수 있습니다.\n\n# ATmega328P에서 실행하기\n\n위에서 작성한 모든 코드를 합쳐서 ATmega328P에서 실행해 봅시다. 아래는 이 글에서 정의한 함수를 사용하는 `main()` 함수입니다. 여기에서는 단순히 Power Up Sequence를 살펴보고 SDCard를 IDLE 상태로 만듭니다.\n\n```c\nint main(void)\n{\n    // SPI 초기화\n    spiInit();\n\n    // Power Up Sequence 시작\n    sdPowerUpSeq();\n\n    // command card to idle\n    sdGoIdleState();\n\n    while(1);\n}\n```\n\nLogic Analyzer를 사용하여 의도한 대로 작동하는지 봐봅시다.  \n아래와 같이 Logic Analyzer를 설정했습니다.\n\n![Logic Analyzer Setting](/assets/image/2022-08-28-AVR-ATmega328P-SDCard-1/AVR-ATmega328P-SDCard-1_8.png)\n\nLogic Analyzer를 사용하면 아래와 같은 화면이 출력됩니다.\n\n![Logic Analyzer](/assets/image/2022-08-28-AVR-ATmega328P-SDCard-1/AVR-ATmega328P-SDCard-1_9.png)\n\n전송된 첫 번째 바이트는 `0x40`(`CMD0 | 0x40`)이고 Argument는 모두 `0`이며 마지막 바이트는 `0x95` 입니다. 응답하기 위해 명령을 보낸 후 SDCard에 8 Clock Cycle이 전송됩니다. 일단 실행되면 `0x01`을 보내며, R1에 대한 정의를 다시 확인하면 SDCard가 IDLE 상태(오류가 없는)인 것을 확인할 수 있으며 정상적으로 Command 전달이 작동한 것을 알 수 있습니다.\n"},"__N_SSG":true},"page":"/article/[category]/[year]/[month]/[day]/[slug]","query":{"category":"avr","year":"2022","month":"08","day":"28","slug":"AVR-ATmega328P-SDCard-1"},"buildId":"FrFmlSEPIvXzRhY1fSPxA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>