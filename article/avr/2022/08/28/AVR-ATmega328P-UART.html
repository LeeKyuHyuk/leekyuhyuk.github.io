<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta property="og:image" content="https://kyuhyuk.kr/thumbnail.png"/><title>[AVR] ATmega328P UART 구현</title><meta name="author" content="KyuHyuk Lee"/><meta name="generator" content="KyuHyuk Lee"/><meta name="description" content=" ATmega328P의 UART(Universal Asynchronous Receiver and Transmitter) 기능을 사용하면 PC에서 마이크로컨트롤러와 쉽게 통신할 수 있습니다. 이 글에서는 마이크로컨트롤러 프로젝트에서 UART를 활용할 수 있는 몇 가지 기본 기능을 살펴보고"/><meta itemProp="url" content="https://kyuhyuk.kr/article/avr/2022/08/28/AVR-ATmega328P-UART"/><meta itemProp="headline" content="[AVR] ATmega328P UART 구현"/><meta property="og:type" content="article"/><meta property="og:url" content="https://kyuhyuk.kr/article/avr/2022/08/28/AVR-ATmega328P-UART"/><meta property="og:title" content="[AVR] ATmega328P UART 구현"/><meta property="og:description" content=" ATmega328P의 UART(Universal Asynchronous Receiver and Transmitter) 기능을 사용하면 PC에서 마이크로컨트롤러와 쉽게 통신할 수 있습니다. 이 글에서는 마이크로컨트롤러 프로젝트에서 UART를 활용할 수 있는 몇 가지 기본 기능을 살펴보고"/><meta property="og:site_name" content="KyuHyuk Blog"/><meta property="og:locale" content="ko_KR"/><meta name="next-head-count" content="15"/><style id="stitches">--sxs{--sxs:2 c-opBYf c-bHyrwK c-uBnvQ c-hehuMV c-bjkCdF c-hAoZGi c-jfcKOQ c-ezyKJG c-iAzQif c-bvdusc c-ezRQNp c-iosjjB c-jYwCTI c-iOPkYY c-cpkrrK c-fiqONv c-iUFgVP c-cshSRb c-fxvkZv c-dIcdES}@media{.c-opBYf{display:flex;align-items:center;background:#FFFFFF;height:60px;justify-content:space-between;-webkit-box-align:center;-webkit-box-pack:justify}.c-bHyrwK{display:flex;align-items:center;justify-content:center;-webkit-box-align:center;-webkit-box-pack:center}.c-uBnvQ{width:32px;height:32px;color:#FFFFFF;background:#000000;border-radius:4px;display:flex;align-items:center;justify-content:center;margin-right:12px;font-weight:700;cursor:default;-webkit-box-align:center;-webkit-box-pack:center}.c-hehuMV{font-weight:900;font-size:18px;letter-spacing:0.5px;color:#000000;cursor:default}.c-bjkCdF{list-style:none;padding:0;margin:0;display:flex;justify-content:center;align-items:center;font-size:24px;color:rgb(134, 142, 150);transition:all 0.3s ease 0s;-webkit-box-pack:center;-webkit-box-align:center}.c-hAoZGi{font-size:28px;color:inherit;text-decoration:none;margin:8px}.c-jfcKOQ{max-width:768px;margin-top:2rem;margin-left:auto;margin-right:auto}.c-ezyKJG{min-width:72px;display:flex;flex-direction:row;justify-content:center;align-items:center;padding:6px 16px;background:#12B886;box-shadow:0px 1px 2px rgba(98, 16, 204, 0.3);border:none;border-radius:14px;vertical-align:middle;color:#FFFFFF;font-size:1rem;height:2rem;float:right}.c-iAzQif{display:inline-block;margin-top:2rem}.c-bvdusc{font-size:2rem;line-height:1.5;letter-spacing:-0.004em;margin-top:0;margin-bottom:2rem;font-weight:700;color:#212529;word-break:keep-all;transition:color 0.125s ease-in 0s;}.c-ezRQNp{font-size:1.125rem;color:#212529;transition:color 0.125s ease-in 0s;;line-height:1.7;letter-spacing:-0.004em;word-break:break-all;overflow-wrap:break-word}.c-iosjjB{background:#F8F9FA;padding:0 1rem;height:2rem;border-radius:1rem;display:inline-flex;align-items:center;margin-right:0.875rem;color:#12B886;text-decoration:none;font-weight:400;font-size:1rem}.c-jYwCTI{font-size:1rem;color:#495057}.c-iOPkYY{margin-top:3rem;background-color:rgba(51,51,51,.1);border:0;height:1px}.c-cpkrrK{width:100%;height:300px;display:flex;align-items:center;justify-content:center;flex-direction:column;-webkit-box-align:center;-webkit-box-pack:center}.c-fiqONv{color:rgb(206, 212, 218);margin-bottom:8px;font-size:22px;font-weight:700}.c-iUFgVP{width:32px;height:32px;color:#FFFFFF;background:rgb(206, 212, 218);border-radius:4px;display:flex;align-items:center;justify-content:center;margin-right:12px;font-weight:700;cursor:default;-webkit-box-align:center;-webkit-box-pack:center}.c-cshSRb{font-weight:900;font-size:18px;letter-spacing:0.5px;color:rgb(206, 212, 218);cursor:default;text-transform:uppercase}.c-fxvkZv{font-size:2.5rem;line-height:1.5;letter-spacing:-0.004em;margin-top:0;margin-bottom:2rem;font-weight:700;color:#212529;word-break:keep-all;transition:color 0.125s ease-in 0s;}.c-dIcdES{margin-top:2rem;font-size:1.125rem;color:#212529;transition:color 0.125s ease-in 0s;;line-height:1.7;letter-spacing:-0.004em;word-break:keep-all;overflow-wrap:break-word}}</style><link rel="preload" href="/_next/static/css/98b299b94b0a7962.css" as="style"/><link rel="stylesheet" href="/_next/static/css/98b299b94b0a7962.css" data-n-g=""/><link rel="preload" href="/_next/static/css/c2a527101433f11d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c2a527101433f11d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-c354a30bda3d62a6.js" defer=""></script><script src="/_next/static/chunks/pages/_app-8265bb1a072646d3.js" defer=""></script><script src="/_next/static/chunks/776-f277552409ab147f.js" defer=""></script><script src="/_next/static/chunks/305-e325b960616dc0fd.js" defer=""></script><script src="/_next/static/chunks/pages/article/%5Bcategory%5D/%5Byear%5D/%5Bmonth%5D/%5Bday%5D/%5Bslug%5D-aa033f8eb8939164.js" defer=""></script><script src="/_next/static/scdaJ3xe6OSbCbEhPmPOm/_buildManifest.js" defer=""></script><script src="/_next/static/scdaJ3xe6OSbCbEhPmPOm/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="c-opBYf"><a href="https://kyuhyuk.kr"><div class="c-bHyrwK"><div class="c-uBnvQ">Kh.</div><div class="c-hehuMV">KyuHyuk Blog</div></div></a><ul class="c-bjkCdF"><li><a href="https://github.com/LeeKyuHyuk" class="c-hAoZGi"><span role="img" aria-label="github" class="anticon anticon-github"><svg viewBox="64 64 896 896" focusable="false" data-icon="github" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0138.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"></path></svg></span></a></li><li><a href="https://linkedin.com/in/leekyuhyuk" class="c-hAoZGi"><span role="img" aria-label="linkedin" class="anticon anticon-linkedin"><svg viewBox="64 64 896 896" focusable="false" data-icon="linkedin" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zM349.3 793.7H230.6V411.9h118.7v381.8zm-59.3-434a68.8 68.8 0 1168.8-68.8c-.1 38-30.9 68.8-68.8 68.8zm503.7 434H675.1V608c0-44.3-.8-101.2-61.7-101.2-61.7 0-71.2 48.2-71.2 98v188.9H423.7V411.9h113.8v52.2h1.6c15.8-30 54.5-61.7 112.3-61.7 120.2 0 142.3 79.1 142.3 181.9v209.4z"></path></svg></span></a></li><li><a href="mailto:lee@kyuhyuk.kr" class="c-hAoZGi"><span role="img" aria-label="mail" class="anticon anticon-mail"><svg viewBox="64 64 896 896" focusable="false" data-icon="mail" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-80.8 108.9L531.7 514.4c-7.8 6.1-18.7 6.1-26.5 0L189.6 268.9A7.2 7.2 0 01194 256h648.8a7.2 7.2 0 014.4 12.9z"></path></svg></span></a></li></ul></header><main class="c-jfcKOQ"><article><h1 class="c-fxvkZv"><a href="https://kyuhyuk.kr/article/avr/2022/08/28/AVR-ATmega328P-UART">[AVR] ATmega328P UART 구현</a></h1><a href="https://kyuhyuk.kr/category/AVR" class="c-iosjjB">AVR</a><time dateTime="2022-08-28 10:35:33" class="c-jYwCTI">Aug 28, 2022 10:35:33 AM</time><div id="post" class="c-dIcdES"><p>ATmega328P의 UART(Universal Asynchronous Receiver and Transmitter) 기능을 사용하면 PC에서 마이크로컨트롤러와 쉽게 통신할 수 있습니다.</p>
<p>이 글에서는 마이크로컨트롤러 프로젝트에서 UART를 활용할 수 있는 몇 가지 기본 기능을 살펴보고 구현해 보겠습니다.</p>
<h1>회로 연결</h1>
<p>아래와 같이 회로를 구성합니다. Arduino를 연결한 이유는 <code>avrdude</code>를 사용하여 ATmega328P의 Flash에 프로그래밍(Flash Write)하기 위해 연결했습니다.</p>
<p><img src="/assets/image/2022-08-28-AVR-ATmega328P-UART/AVR-ATmega328P-UART_1.png" alt="Connections"></p>
<h1>UART 초기화</h1>
<p>UART를 초기화하기 위해 구성해야 하는 몇 가지 항목이 있습니다. 가장 먼저 결정해야 할 것은 전송 속도(Buadrate)입니다. UART의 경우 전송 속도는 전송될 초당 비트 수 입니다. 다음과 같이 여러 표준 속도가 있습니다:</p>
<ul>
<li>1200</li>
<li>2400</li>
<li>4800</li>
<li>9600</li>
<li>19200</li>
<li>38400</li>
<li>57600</li>
<li>115200</li>
</ul>
<p>속도가 큰 문제가 되지 않는 대부분의 마이크로컨트롤러 프로젝트의 경우에는 <code>9600</code>이 주로 사용됩니다. 초당 1200개의 문자를 전송하는 것과 같습니다. (16MHz 클럭의 ATmega328P는 초당 <code>1Mbps - 125000</code>개의 문자를 전송할 수도 있습니다)</p>
<h1>전송 속도 설정하기</h1>
<p>전송 속도 설정은 <code>UBRR0H</code>와 <code>UBRR0L</code> 레지스터에 기록하여 설정합니다. 이 레지스터에 기록되는 값은 아래 수식의 값입니다.</p>
<p><img src="/assets/image/2022-08-28-AVR-ATmega328P-UART/AVR-ATmega328P-UART_2.png" alt="Buadrate Calc"></p>
<p>위의 수식에서 <code>fOSC</code>는 클럭 속도입니다. 프로젝트에서 16MHz의 외부 발진기를 사용하고 원하는 전송 속도가 9600이라고 가정하면 <code>UBRRn</code>의 값은 <code>(16000000/(16*9600)) - 1 = 103.167</code>이 됩니다. <code>103.167</code>은 정수가 아니므로 반올림해서 <code>103</code>이 됩니다.</p>
<p>전송 속도 레지스터(<code>UBRR</code>)은 각각 8비트이므로 <code>103</code>을 하위 바이트와 상위 바이트로 분리해야 합니다. <code>255</code>보다 작기 때문에 상위 바이트가 <code>0</code>이고 하위 바이트가 <code>103</code>인 것은 분명하지만, 상위 바이트와 하위 바이트를 구분해서 코드를 작성하는 방법은 아래와 같습니다:</p>
<pre><code class="language-c">    <span class="hljs-comment">// 하위 바이트를 UBRR0L에 기록</span>
    UBRR0L = (<span class="hljs-type">uint8_t</span>)(<span class="hljs-number">103</span> &amp; <span class="hljs-number">0xFF</span>);

    <span class="hljs-comment">// 상위 바이트를 UBRR0H에 기록</span>
    UBRR0H = (<span class="hljs-type">uint8_t</span>)(<span class="hljs-number">103</span> &gt;&gt; <span class="hljs-number">8</span>)
</code></pre>
<h1>UART 송신기와 수신기 활성화하기</h1>
<p><code>UCSR</code> 레지스터를 설정하여 송신 및 수신 기능을 활성화해야 합니다. 이 작업을 하지 않으면 마이크로컨트롤러의 UART RX/TX 핀은 표준 I/O핀으로 작동합니다. <code>UCSR0B</code> 레지스터의 <code>RXEN0</code>와 <code>TXEN0</code>의 비트를 <code>1</code>로 설정합니다.</p>
<pre><code class="language-c">    <span class="hljs-comment">// UART 송신기와 수신기 활성화</span>
    UCSR0B |= (<span class="hljs-number">1</span> &lt;&lt; RXEN0) | (<span class="hljs-number">1</span> &lt;&lt; TXEN0)
</code></pre>
<h1>프레임 포맷</h1>
<p>마지막으로 데이터 비트 수, 정지 비트 수 및 패리티 비트 사용을 포함하는 프레임 포맷을 설정해야 하지만, 기본적으로 시스템은 8개의 데이터 비트에 패리티 비트는 없고 1개의 정지 비트(8N1이라고 불립니다)의 값으로 초기화됩니다. 이 설정은 일반적인 설정이며 대부분 터미널의 기본값이므로 여기서는 변경하지 않습니다.</p>
<h1>초기화 함수 작성하기</h1>
<p>아래와 같이 위의 내용을 바탕으로 UART를 초기화하는 함수를 작성합니다:</p>
<pre><code class="language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">uartInit</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> ubrr)</span>
{
    <span class="hljs-comment">// UBRR에 전송 속도(Buadrate)를 설정</span>
    UBRR0L = (<span class="hljs-type">uint8_t</span>)(ubrr &amp; <span class="hljs-number">0xFF</span>);
    UBRR0H = (<span class="hljs-type">uint8_t</span>)(ubrr &gt;&gt; <span class="hljs-number">8</span>);

    <span class="hljs-comment">// UART 송신기와 수신기 활성화</span>
    UCSR0B |= (<span class="hljs-number">1</span> &lt;&lt; RXEN0) | (<span class="hljs-number">1</span> &lt;&lt; TXEN0);
}
</code></pre>
<p>이 초기화 함수는 UART 관련 함수를 사용하기 전에 꼭 호출해야 합니다. 만약 호출하지 않는다면 UART는 작동하지 않습니다.</p>
<h1>단일 문자 전송</h1>
<p>UART에서 모든 전송 기능은 단일 문자를 UART를 통해 보내는 것으로 시작됩니다.</p>
<pre><code class="language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">uartPut</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> data)</span>
{
    <span class="hljs-comment">// 전송 버퍼가 비어 있을 때까지 기다립니다</span>
    <span class="hljs-keyword">while</span>(!(UCSR0A &amp; (<span class="hljs-number">1</span> &lt;&lt; UDRE0)));

    <span class="hljs-comment">// 데이터를 UDR(전송 레지스터)에 입력</span>
    UDR0 = data;
}
</code></pre>
<p>데이터를 전송하려면 전송 버퍼가 비어 있는지 확인해야 합니다. 데이터시트에 따르면 <code>UDREn</code>이 <code>1</code>이면 버퍼가 비어있는 것을 의미하며 데이터를 전송할 준비가 된 것이라고 설명하고 있습니다. <code>UDRE0</code>은 USART 제어 및 상태 레지스터인 <code>UCSR0A</code> 있으므로, <code>UCSR0A</code>를 <code>(1 &lt;&lt; UDRE0)</code>으로 마스킹 해서 값을 얻을 수 있습니다.</p>
<p><code>UDRE0</code>가 <code>1</code>이 되면 버퍼가 비어있는 것으로 버퍼가 비어있을 때 전송하려는 문자를 <code>UDR0</code> 레지스터에 입력만 하면 나머지는 하드웨어가 알아서 처리하게 됩니다.</p>
<h1>문자열 전송</h1>
<p>단일 문자 전송 함수가 있으면 문자열을 보내는 함수를 작성하는 것은 매우 간단합니다.</p>
<pre><code class="language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">uartPuts</span><span class="hljs-params">(<span class="hljs-type">char</span>* s)</span>
{
    <span class="hljs-comment">// 문자열의 끝을 알리는 NULL이 나올때까지 단일 문자를 전송합니다</span>
    <span class="hljs-keyword">while</span>(*s &gt; <span class="hljs-number">0</span>) uartPut(*s++);
}
</code></pre>
<p>위의 함수는 문자열을 입력받아서 <code>NULL</code>이 나올 때까지 각 문자를 하나씩 전송합니다.</p>
<h1>16진수 값 전송</h1>
<p>터미널에서 읽을 수 있는 형식으로 16진수의 값을 전송하려면 먼저 ACSII로 변환해야 합니다.</p>
<pre><code class="language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">uartPutHex8</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> val)</span>
{
    <span class="hljs-comment">// 입력 값에서 상위 및 하위 니블 추출</span>
    <span class="hljs-type">uint8_t</span> upperNibble = (val &amp; <span class="hljs-number">0xF0</span>) &gt;&gt; <span class="hljs-number">4</span>;
    <span class="hljs-type">uint8_t</span> lowerNibble = val &amp; <span class="hljs-number">0x0F</span>;

    <span class="hljs-comment">// 니블을 ASCII 16진수로 변환</span>
    upperNibble += upperNibble &gt; <span class="hljs-number">9</span> ? <span class="hljs-string">&#x27;A&#x27;</span> - <span class="hljs-number">10</span> : <span class="hljs-string">&#x27;0&#x27;</span>;
    lowerNibble += lowerNibble &gt; <span class="hljs-number">9</span> ? <span class="hljs-string">&#x27;A&#x27;</span> - <span class="hljs-number">10</span> : <span class="hljs-string">&#x27;0&#x27;</span>;

    <span class="hljs-comment">// 문자를 출력</span>
    uartPut(upperNibble);
    uartPut(lowerNibble);
}
</code></pre>
<p><code>uartPutHex8()</code>을 사용하면 더 큰 16진수 값을 출력하도록 쉽게 확장할 수 있습니다. 예를 들어 16비트의 값을 16진수의 값으로 전송하는 함수는 다음과 같습니다:</p>
<pre><code class="language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">uartPutHex16</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> val)</span>
{
    <span class="hljs-comment">// 상위 8비트를 전송</span>
    uartPutHex8((<span class="hljs-type">uint8_t</span>)(val &gt;&gt; <span class="hljs-number">8</span>));

    <span class="hljs-comment">// 하위 8비트를 전송</span>
    uartPutHex8((<span class="hljs-type">uint8_t</span>)(val &amp; <span class="hljs-number">0x00FF</span>));
}
</code></pre>
<h1>10진수 값 전송</h1>
<p>10진수 값을 전송하는 것은 바이트를 상위 및 하위 니블로 분할하고 직접 변환할 수 없기 때문에 위에서 구현한 16진수의 값을 전송하는 것보다 조금 더 까다롭습니다. 특히 ATmega328P에는 하드웨어 분할기가 없기 때문에 나누기에 대한 비용이 많이 듭니다. 대신 나누기 연산을 빼기로 대체하여 속도를 높일 수 있습니다.</p>
<pre><code class="language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">uartPutU8</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> val)</span>
{
    <span class="hljs-type">uint8_t</span> dig1 = <span class="hljs-string">&#x27;0&#x27;</span>, dig2 = <span class="hljs-string">&#x27;0&#x27;</span>;

    <span class="hljs-comment">// 100 단위의 값을 계산합니다</span>
    <span class="hljs-keyword">while</span>(val &gt;= <span class="hljs-number">100</span>)
    {
        val -= <span class="hljs-number">100</span>;
        dig1++;
    }

    <span class="hljs-comment">// 10 단위의 값을 계산합니다</span>
    <span class="hljs-keyword">while</span>(val &gt;= <span class="hljs-number">10</span>)
    {
        val -= <span class="hljs-number">10</span>;
        dig2++;
    }

    <span class="hljs-comment">// 첫 번째 숫자를 출력 (0이면 출력하지 않습니다)</span>
    <span class="hljs-keyword">if</span>(dig1 != <span class="hljs-string">&#x27;0&#x27;</span>) uartPut(dig1);

    <span class="hljs-comment">// 두 번째 숫자를 출력 (0이면 출력하지 않습니다)</span>
    <span class="hljs-keyword">if</span>((dig1 != <span class="hljs-string">&#x27;0&#x27;</span>) || (dig2 != <span class="hljs-string">&#x27;0&#x27;</span>)) uartPut(dig2);

    <span class="hljs-comment">// 마지막 숫자를 출력</span>
    uartPut(val + <span class="hljs-string">&#x27;0&#x27;</span>);
}
</code></pre>
<p>위의 <code>uartPutU8()</code>은 부호가 없는 값을 출력합니다. 만약 부호가 있는 값을 출력해야 하면 어떻게 해야 할까요? 방법은 간단합니다. <code>MSB</code>가 1로 설정되어 있나 확인해서 <code>MSB</code>가 1이면 음수 기호를 출력하고 <code>uartPutU8()</code>을 호출합니다.</p>
<pre><code class="language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">uartPutS8</span><span class="hljs-params">(<span class="hljs-type">int8_t</span> val)</span>
{
    <span class="hljs-comment">// 값이 음수인지 확인합니다</span>
    <span class="hljs-keyword">if</span>(val &amp; <span class="hljs-number">0x80</span>)
    {
        <span class="hljs-comment">// 음수 기호를 출력합니다</span>
        uartPut(<span class="hljs-string">&#x27;-&#x27;</span>);

        <span class="hljs-comment">// 부호 없는 값을 가져옵니다</span>
        val = ~(val - <span class="hljs-number">1</span>);
    }

    <span class="hljs-comment">// 부호 없는 값을 출력합니다</span>
    uartPutU8((<span class="hljs-type">uint8_t</span>)val);
}
</code></pre>
<p>이 개념을 더 큰 자료형으로 확장하는 것은 간단합니다. 예를 들어 16비트의 값은 아래와 같이 확장할 수 있습니다:</p>
<pre><code class="language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">uartPutU16</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> val)</span>
{
    <span class="hljs-type">uint8_t</span> dig1 = <span class="hljs-string">&#x27;0&#x27;</span>, dig2 = <span class="hljs-string">&#x27;0&#x27;</span>, dig3 = <span class="hljs-string">&#x27;0&#x27;</span>, dig4 = <span class="hljs-string">&#x27;0&#x27;</span>;

    <span class="hljs-comment">// 10000 단위의 값을 계산합니다</span>
    <span class="hljs-keyword">while</span>(val &gt;= <span class="hljs-number">10000</span>)
    {
        val -= <span class="hljs-number">10000</span>;
        dig1++;
    }

    <span class="hljs-comment">// 1000 단위의 값을 계산합니다</span>
    <span class="hljs-keyword">while</span>(val &gt;= <span class="hljs-number">1000</span>)
    {
        val -= <span class="hljs-number">1000</span>;
        dig2++;
    }

    <span class="hljs-comment">// 100 단위의 값을 계산합니다</span>
    <span class="hljs-keyword">while</span>(val &gt;= <span class="hljs-number">100</span>)
    {
        val -= <span class="hljs-number">100</span>;
        dig3++;
    }

    <span class="hljs-comment">// 10 단위의 값을 계산합니다</span>
    <span class="hljs-keyword">while</span>(val &gt;= <span class="hljs-number">10</span>)
    {
        val -= <span class="hljs-number">10</span>;
        dig4++;
    }

    <span class="hljs-comment">// 이전 값이 출력되었는지 저장하는 변수입니다</span>
    <span class="hljs-type">uint8_t</span> prevPrinted = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// 첫 번째 숫자를 출력 (0이면 출력하지 않습니다)</span>
    <span class="hljs-keyword">if</span>(dig1 != <span class="hljs-string">&#x27;0&#x27;</span>) {uartPut(dig1); prevPrinted = <span class="hljs-number">1</span>;}

    <span class="hljs-comment">// 두 번째 숫자를 출력 (0이면 출력하지 않습니다)</span>
    <span class="hljs-keyword">if</span>(prevPrinted || (dig2 != <span class="hljs-string">&#x27;0&#x27;</span>)) {uartPut(dig2); prevPrinted = <span class="hljs-number">1</span>;}

    <span class="hljs-comment">// 세 번째 숫자를 출력 (0이면 출력하지 않습니다)</span>
    <span class="hljs-keyword">if</span>(prevPrinted || (dig3 != <span class="hljs-string">&#x27;0&#x27;</span>)) {uartPut(dig3); prevPrinted = <span class="hljs-number">1</span>;}

    <span class="hljs-comment">// 네 번째 숫자를 출력 (0이면 출력하지 않습니다)</span>
    <span class="hljs-keyword">if</span>(prevPrinted || (dig4 != <span class="hljs-string">&#x27;0&#x27;</span>)) {uartPut(dig4); prevPrinted = <span class="hljs-number">1</span>;}

    <span class="hljs-comment">// 마지막 숫자를 출력</span>
    uartPut(val + <span class="hljs-string">&#x27;0&#x27;</span>);
}
</code></pre>
<pre><code class="language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">uartPutS16</span><span class="hljs-params">(<span class="hljs-type">int16_t</span> val)</span>
{
    <span class="hljs-comment">// check for negative number</span>
    <span class="hljs-keyword">if</span>(val &amp; <span class="hljs-number">0x8000</span>)
    {
        <span class="hljs-comment">// print minus sign</span>
        uartPut(<span class="hljs-string">&#x27;-&#x27;</span>);

        <span class="hljs-comment">// convert to unsigned magnitude</span>
        val = ~(val - <span class="hljs-number">1</span>);
    }

    <span class="hljs-comment">// print unsigned magnitude</span>
    uartPutU16((<span class="hljs-type">uint16_t</span>) val);
}
</code></pre>
<h1>UART를 통해 수신하기</h1>
<p>UART를 통해 단일 문자를 수신하는 건 위에서 구현한 <code>uartPut()</code>와 비슷합니다. 문자를 수신할 때는 <code>RXC0</code> 비트가 Set 될 때까지 <code>UCSR0A</code> 레지스터를 폴링 하면 됩니다. 그리고 <code>UDR0</code>에서 수신한 문자를 반환할 수 있습니다.</p>
<pre><code class="language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">uartGet</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    <span class="hljs-comment">// 데이터 수신을 기다립니다</span>
    <span class="hljs-keyword">while</span>(!(UCSR0A &amp; (<span class="hljs-number">1</span> &lt;&lt; RXC0)));

    <span class="hljs-comment">// 데이터를 반환합니다</span>
    <span class="hljs-keyword">return</span> UDR0;
}
</code></pre>
<p>캐리지 리턴(<code>\r</code>)로 끝나는 데이터의 전체 라인을 수신하기 위해 <code>uartGetLine()</code>을 구현해 봅시다.</p>
<pre><code class="language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">uartGetLine</span><span class="hljs-params">(<span class="hljs-type">char</span>* buf, <span class="hljs-type">uint8_t</span> n)</span>
{
    <span class="hljs-type">uint8_t</span> bufIdx = <span class="hljs-number">0</span>;
    <span class="hljs-type">char</span> c;

    <span class="hljs-comment">// 수신된 문자가 캐리지 리턴(\r)이 나올때까지 수신합니다</span>
    <span class="hljs-keyword">do</span>
    {
        <span class="hljs-comment">// 단일 문자를 수신합니다</span>
        c = uartGet();

        <span class="hljs-comment">// 수신한 단일 문자를 출력합니다</span>
        uartPut(c);

        <span class="hljs-comment">// 버퍼에 단일 문자를 저장합니다</span>
        buf[bufIdx++] = c;
    }
    <span class="hljs-keyword">while</span>((bufIdx &lt; n) &amp;&amp; (c != <span class="hljs-string">&#x27;\r&#x27;</span>));

    <span class="hljs-comment">// 문자열 버퍼의 마지막에 NULL을 입력해서 문자열의 끝을 지정합니다</span>
    buf[bufIdx] = <span class="hljs-number">0</span>;
}
</code></pre>
<p>앞에서 구현한 함수와 달리 여기서는 실제로 버퍼를 할당하여 문자를 저장하고, 수신 함수에 전달합니다. 예를 들면 아래와 같습니다:</p>
<pre><code class="language-c">    <span class="hljs-comment">// Buffer를 할당합니다.</span>
    <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> bufSize = <span class="hljs-number">20</span>;
    <span class="hljs-type">char</span> buf[bufSize];

    <span class="hljs-comment">// UART를 통해 데이터의 전체라인을 수신합니다</span>
    uartGetLine(buf, bufSize);

    <span class="hljs-comment">// 수신한 데이터를 출력합니다</span>
    uartPuts(<span class="hljs-string">&quot;You entered: &quot;</span>);
    uartPuts(buf);
    uartPut(<span class="hljs-string">&#x27;\n&#x27;</span>);
</code></pre>
<h1>ATmega328P에서 실행하기</h1>
<p>프로젝트에 아래의 파일을 생성합니다.</p>
<p><strong>MakeFile :</strong></p>
<pre><code class="language-makefile">CC = avr-gcc
CFLAGS = -Wall -Os -mmcu=atmega328p
OBJCOPY = avr-objcopy

OBJ = main.o uart.o

<span class="hljs-section">all: atmega328p-uart.hex</span>

<span class="hljs-section">%.o: %.c</span>
	<span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> -c <span class="hljs-variable">$&lt;</span>

<span class="hljs-section">atmega328p-uart.elf: <span class="hljs-variable">$(OBJ)</span></span>
	<span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> -o atmega328p-uart.elf <span class="hljs-variable">$(OBJ)</span>

<span class="hljs-section">atmega328p-uart.hex: atmega328p-uart.elf</span>
	<span class="hljs-variable">$(OBJCOPY)</span> atmega328p-uart.elf -O ihex atmega328p-uart.hex

<span class="hljs-section">clean:</span>
	rm -f *.o *.elf *.hex
</code></pre>
<p><strong>uart.h :</strong></p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span>

<span class="hljs-type">void</span> <span class="hljs-title function_">uartInit</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> ubrr)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">uartPut</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> data)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">uartPuts</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">uartPutHex8</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> val)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">uartPutHex16</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> val)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">uartPutU8</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> val)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">uartPutS8</span><span class="hljs-params">(<span class="hljs-type">int8_t</span> val)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">uartPutU16</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> val)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">uartPutS16</span><span class="hljs-params">(<span class="hljs-type">int16_t</span> val)</span>;
<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-title function_">uartGet</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">uartGetLine</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">uint8_t</span> n)</span>;
</code></pre>
<p><strong>uart.c :</strong></p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;avr/io.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;uart.h&quot;</span></span>

<span class="hljs-type">void</span> <span class="hljs-title function_">uartInit</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> ubrr)</span>
{
    <span class="hljs-comment">// UBRR에 전송 속도(Buadrate)를 설정</span>
    UBRR0L = (<span class="hljs-type">uint8_t</span>)(ubrr &amp; <span class="hljs-number">0xFF</span>);
    UBRR0H = (<span class="hljs-type">uint8_t</span>)(ubrr &gt;&gt; <span class="hljs-number">8</span>);

    <span class="hljs-comment">// UART 송신기와 수신기 활성화</span>
    UCSR0B |= (<span class="hljs-number">1</span> &lt;&lt; RXEN0) | (<span class="hljs-number">1</span> &lt;&lt; TXEN0);
    uartPuts(<span class="hljs-string">&quot;\n\r&quot;</span>);
    uartPuts(<span class="hljs-string">&quot;[INFO] UART initialized!\n\r&quot;</span>);
}

<span class="hljs-type">void</span> <span class="hljs-title function_">uartPut</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> data)</span>
{
    <span class="hljs-comment">// 전송 버퍼가 비어 있을 때까지 기다립니다</span>
    <span class="hljs-keyword">while</span> (!(UCSR0A &amp; (<span class="hljs-number">1</span> &lt;&lt; UDRE0)))
        ;

    <span class="hljs-comment">// 데이터를 UDR(전송 레지스터)에 입력</span>
    UDR0 = data;
}

<span class="hljs-type">void</span> <span class="hljs-title function_">uartPuts</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span>
{
    <span class="hljs-comment">// 문자열의 끝을 알리는 NULL이 나올때까지 단일 문자를 전송합니다</span>
    <span class="hljs-keyword">while</span> (*s &gt; <span class="hljs-number">0</span>)
        uartPut(*s++);
}

<span class="hljs-type">void</span> <span class="hljs-title function_">uartPutHex8</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> val)</span>
{
    <span class="hljs-comment">// 입력 값에서 상위 및 하위 니블 추출</span>
    <span class="hljs-type">uint8_t</span> upperNibble = (val &amp; <span class="hljs-number">0xF0</span>) &gt;&gt; <span class="hljs-number">4</span>;
    <span class="hljs-type">uint8_t</span> lowerNibble = val &amp; <span class="hljs-number">0x0F</span>;

    <span class="hljs-comment">// 니블을 ASCII 16진수로 변환</span>
    upperNibble += upperNibble &gt; <span class="hljs-number">9</span> ? <span class="hljs-string">&#x27;A&#x27;</span> - <span class="hljs-number">10</span> : <span class="hljs-string">&#x27;0&#x27;</span>;
    lowerNibble += lowerNibble &gt; <span class="hljs-number">9</span> ? <span class="hljs-string">&#x27;A&#x27;</span> - <span class="hljs-number">10</span> : <span class="hljs-string">&#x27;0&#x27;</span>;

    <span class="hljs-comment">// 문자를 출력</span>
    uartPut(upperNibble);
    uartPut(lowerNibble);
}

<span class="hljs-type">void</span> <span class="hljs-title function_">uartPutHex16</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> val)</span>
{
    <span class="hljs-comment">// 상위 8비트를 전송</span>
    uartPutHex8((<span class="hljs-type">uint8_t</span>)(val &gt;&gt; <span class="hljs-number">8</span>));

    <span class="hljs-comment">// 하위 8비트를 전송</span>
    uartPutHex8((<span class="hljs-type">uint8_t</span>)(val &amp; <span class="hljs-number">0x00FF</span>));
}

<span class="hljs-type">void</span> <span class="hljs-title function_">uartPutU8</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> val)</span>
{
    <span class="hljs-type">uint8_t</span> dig1 = <span class="hljs-string">&#x27;0&#x27;</span>, dig2 = <span class="hljs-string">&#x27;0&#x27;</span>;

    <span class="hljs-comment">// 100 단위의 값을 계산합니다</span>
    <span class="hljs-keyword">while</span> (val &gt;= <span class="hljs-number">100</span>)
    {
        val -= <span class="hljs-number">100</span>;
        dig1++;
    }

    <span class="hljs-comment">// 10 단위의 값을 계산합니다</span>
    <span class="hljs-keyword">while</span> (val &gt;= <span class="hljs-number">10</span>)
    {
        val -= <span class="hljs-number">10</span>;
        dig2++;
    }

    <span class="hljs-comment">// 첫 번째 숫자를 출력 (0이면 출력하지 않습니다)</span>
    <span class="hljs-keyword">if</span> (dig1 != <span class="hljs-string">&#x27;0&#x27;</span>)
        uartPut(dig1);

    <span class="hljs-comment">// 두 번째 숫자를 출력 (0이면 출력하지 않습니다)</span>
    <span class="hljs-keyword">if</span> ((dig1 != <span class="hljs-string">&#x27;0&#x27;</span>) || (dig2 != <span class="hljs-string">&#x27;0&#x27;</span>))
        uartPut(dig2);

    <span class="hljs-comment">// 마지막 숫자를 출력</span>
    uartPut(val + <span class="hljs-string">&#x27;0&#x27;</span>);
}

<span class="hljs-type">void</span> <span class="hljs-title function_">uartPutS8</span><span class="hljs-params">(<span class="hljs-type">int8_t</span> val)</span>
{
    <span class="hljs-comment">// 값이 음수인지 확인합니다</span>
    <span class="hljs-keyword">if</span> (val &amp; <span class="hljs-number">0x80</span>)
    {
        <span class="hljs-comment">// 음수 기호를 출력합니다</span>
        uartPut(<span class="hljs-string">&#x27;-&#x27;</span>);

        <span class="hljs-comment">// 부호 없는 값을 가져옵니다</span>
        val = ~(val - <span class="hljs-number">1</span>);
    }

    <span class="hljs-comment">// 부호 없는 값을 출력합니다</span>
    uartPutU8((<span class="hljs-type">uint8_t</span>)val);
}

<span class="hljs-type">void</span> <span class="hljs-title function_">uartPutU16</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> val)</span>
{
    <span class="hljs-type">uint8_t</span> dig1 = <span class="hljs-string">&#x27;0&#x27;</span>, dig2 = <span class="hljs-string">&#x27;0&#x27;</span>, dig3 = <span class="hljs-string">&#x27;0&#x27;</span>, dig4 = <span class="hljs-string">&#x27;0&#x27;</span>;

    <span class="hljs-comment">// 10000 단위의 값을 계산합니다</span>
    <span class="hljs-keyword">while</span> (val &gt;= <span class="hljs-number">10000</span>)
    {
        val -= <span class="hljs-number">10000</span>;
        dig1++;
    }

    <span class="hljs-comment">// 1000 단위의 값을 계산합니다</span>
    <span class="hljs-keyword">while</span> (val &gt;= <span class="hljs-number">1000</span>)
    {
        val -= <span class="hljs-number">1000</span>;
        dig2++;
    }

    <span class="hljs-comment">// 100 단위의 값을 계산합니다</span>
    <span class="hljs-keyword">while</span> (val &gt;= <span class="hljs-number">100</span>)
    {
        val -= <span class="hljs-number">100</span>;
        dig3++;
    }

    <span class="hljs-comment">// 10 단위의 값을 계산합니다</span>
    <span class="hljs-keyword">while</span> (val &gt;= <span class="hljs-number">10</span>)
    {
        val -= <span class="hljs-number">10</span>;
        dig4++;
    }

    <span class="hljs-comment">// 이전 값이 출력되었는지 저장하는 변수입니다</span>
    <span class="hljs-type">uint8_t</span> prevPrinted = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// 첫 번째 숫자를 출력 (0이면 출력하지 않습니다)</span>
    <span class="hljs-keyword">if</span> (dig1 != <span class="hljs-string">&#x27;0&#x27;</span>)
    {
        uartPut(dig1);
        prevPrinted = <span class="hljs-number">1</span>;
    }

    <span class="hljs-comment">// 두 번째 숫자를 출력 (0이면 출력하지 않습니다)</span>
    <span class="hljs-keyword">if</span> (prevPrinted || (dig2 != <span class="hljs-string">&#x27;0&#x27;</span>))
    {
        uartPut(dig2);
        prevPrinted = <span class="hljs-number">1</span>;
    }

    <span class="hljs-comment">// 세 번째 숫자를 출력 (0이면 출력하지 않습니다)</span>
    <span class="hljs-keyword">if</span> (prevPrinted || (dig3 != <span class="hljs-string">&#x27;0&#x27;</span>))
    {
        uartPut(dig3);
        prevPrinted = <span class="hljs-number">1</span>;
    }

    <span class="hljs-comment">// 네 번째 숫자를 출력 (0이면 출력하지 않습니다)</span>
    <span class="hljs-keyword">if</span> (prevPrinted || (dig4 != <span class="hljs-string">&#x27;0&#x27;</span>))
    {
        uartPut(dig4);
        prevPrinted = <span class="hljs-number">1</span>;
    }

    <span class="hljs-comment">// 마지막 숫자를 출력</span>
    uartPut(val + <span class="hljs-string">&#x27;0&#x27;</span>);
}

<span class="hljs-type">void</span> <span class="hljs-title function_">uartPutS16</span><span class="hljs-params">(<span class="hljs-type">int16_t</span> val)</span>
{
    <span class="hljs-comment">// check for negative number</span>
    <span class="hljs-keyword">if</span> (val &amp; <span class="hljs-number">0x8000</span>)
    {
        <span class="hljs-comment">// print minus sign</span>
        uartPut(<span class="hljs-string">&#x27;-&#x27;</span>);

        <span class="hljs-comment">// convert to unsigned magnitude</span>
        val = ~(val - <span class="hljs-number">1</span>);
    }

    <span class="hljs-comment">// print unsigned magnitude</span>
    uartPutU16((<span class="hljs-type">uint16_t</span>)val);
}

<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-title function_">uartGet</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    <span class="hljs-comment">// 데이터 수신을 기다립니다</span>
    <span class="hljs-keyword">while</span> (!(UCSR0A &amp; (<span class="hljs-number">1</span> &lt;&lt; RXC0)))
        ;

    <span class="hljs-comment">// 데이터를 반환합니다</span>
    <span class="hljs-keyword">return</span> UDR0;
}

<span class="hljs-type">void</span> <span class="hljs-title function_">uartGetLine</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">uint8_t</span> n)</span>
{
    <span class="hljs-type">uint8_t</span> bufIdx = <span class="hljs-number">0</span>;
    <span class="hljs-type">char</span> c;

    <span class="hljs-comment">// 수신된 문자가 캐리지 리턴(\r)이 나올때까지 수신합니다</span>
    <span class="hljs-keyword">do</span>
    {
        <span class="hljs-comment">// 단일 문자를 수신합니다</span>
        c = uartGet();

        <span class="hljs-comment">// 수신한 단일 문자를 출력합니다</span>
        uartPut(c);

        <span class="hljs-comment">// 버퍼에 단일 문자를 저장합니다</span>
        buf[bufIdx++] = c;
    } <span class="hljs-keyword">while</span> ((bufIdx &lt; n) &amp;&amp; (c != <span class="hljs-string">&#x27;\r&#x27;</span>));

    <span class="hljs-comment">// 문자열 버퍼의 마지막에 NULL을 입력해서 문자열의 끝을 지정합니다</span>
    buf[bufIdx] = <span class="hljs-number">0</span>;
}
</code></pre>
<p><strong>main.c :</strong></p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;avr/interrupt.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;uart.h&quot;</span></span>
<span class="hljs-comment">/*
  CPU의 Frequency를 16MHz로 설정합니다
*/</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> F_CPU 16000000UL</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;util/delay.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
  <span class="hljs-comment">// Buffer를 할당합니다.</span>
  <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> bufSize = <span class="hljs-number">20</span>;
  <span class="hljs-type">char</span> buf[bufSize];

  <span class="hljs-comment">// UART 전송속도를 설정합니다</span>
  <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> baudRate = (F_CPU / <span class="hljs-number">16</span> / <span class="hljs-number">9600</span>) - <span class="hljs-number">1</span>;

  _delay_ms(<span class="hljs-number">100</span>); <span class="hljs-comment">// VCC 안정화를 위해 100ms 동안 대기합니다</span>

  cli(); <span class="hljs-comment">// 모든 인터럽트를 비활성화 합니다</span>

  <span class="hljs-comment">// UART를 초기화 합니다</span>
  uartInit(baudRate);

  <span class="hljs-comment">// UART를 통해 데이터의 전체라인을 수신합니다</span>
  uartPuts(<span class="hljs-string">&quot;Please enter any text : &quot;</span>);
  uartGetLine(buf, bufSize);

  <span class="hljs-comment">// 수신한 데이터를 출력합니다</span>
  uartPuts(<span class="hljs-string">&quot;\n\r&quot;</span>);
  uartPuts(<span class="hljs-string">&quot;You entered : &quot;</span>);
  uartPuts(buf);
  uartPuts(<span class="hljs-string">&quot;\n\r&quot;</span>);

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>이제 빌드하고 ATmega328P의 Flash Write 해봅시다.</p>
<p>브레드보드에 연결된 Arduino에 ArduinoISP 예제를 넣습니다.<br>
<img src="/assets/image/2022-08-28-AVR-ATmega328P-UART/AVR-ATmega328P-UART_3.png" alt="ArduinoISP"></p>
<p>그리고 아래의 명령어를 실행하여 ATmega328P UART 프로젝트를 빌드하고 ATmega328P에 기록합니다.</p>
<blockquote>
<p><code>/dev/tty.usbmodem2112201</code> 부분은 Arduino Board를 입력합니다. ArduinoISP가 프로그래밍되어 있는 Arduino Board는 데이터를 받아 브레드보드에 있는 ATmega328P에 기록합니다</p>
</blockquote>
<pre><code class="language-sh">make
avrdude -c stk500v1 -b 19200 -F -p m328p -P /dev/tty.usbmodem2112201 -Uflash:w:atmega328p-uart.hex:i
</code></pre>
<p><img src="/assets/image/2022-08-28-AVR-ATmega328P-UART/AVR-ATmega328P-UART_4.png" alt="Build and Flash"></p>
<p><code>minicom</code>로 ATmega328P에 연결된 UART에 접속해서 정상적으로 동작하는지 확인해 봅니다.<br>
입력한 값이 그대로 출력된다면 정상 작동하는 것입니다.<br>
<img src="/assets/image/2022-08-28-AVR-ATmega328P-UART/AVR-ATmega328P-UART_5.png" alt="minicom"></p>
</div></article></main><footer class="c-cpkrrK"><div class="c-fiqONv">© <!-- -->2022</div><div class="c-bHyrwK"><div class="c-iUFgVP">Kh.</div><div class="c-cshSRb">KyuHyuk Lee</div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"excerpt":" ATmega328P의 UART(Universal Asynchronous Receiver and Transmitter) 기능을 사용하면 PC에서 마이크로컨트롤러와 쉽게 통신할 수 있습니다. 이 글에서는 마이크로컨트롤러 프로젝트에서 UART를 활용할 수 있는 몇 가지 기본 기능을 살펴보고","url":"/article/avr/2022/08/28/AVR-ATmega328P-UART","frontmatter":{"title":"[AVR] ATmega328P UART 구현","date":"2022-08-28 10:35:33","category":"AVR"},"content":"\nATmega328P의 UART(Universal Asynchronous Receiver and Transmitter) 기능을 사용하면 PC에서 마이크로컨트롤러와 쉽게 통신할 수 있습니다.\n\n이 글에서는 마이크로컨트롤러 프로젝트에서 UART를 활용할 수 있는 몇 가지 기본 기능을 살펴보고 구현해 보겠습니다.\n\n# 회로 연결\n\n아래와 같이 회로를 구성합니다. Arduino를 연결한 이유는 `avrdude`를 사용하여 ATmega328P의 Flash에 프로그래밍(Flash Write)하기 위해 연결했습니다.\n\n![Connections](/assets/image/2022-08-28-AVR-ATmega328P-UART/AVR-ATmega328P-UART_1.png)\n\n# UART 초기화\n\nUART를 초기화하기 위해 구성해야 하는 몇 가지 항목이 있습니다. 가장 먼저 결정해야 할 것은 전송 속도(Buadrate)입니다. UART의 경우 전송 속도는 전송될 초당 비트 수 입니다. 다음과 같이 여러 표준 속도가 있습니다:\n\n- 1200\n- 2400\n- 4800\n- 9600\n- 19200\n- 38400\n- 57600\n- 115200\n\n속도가 큰 문제가 되지 않는 대부분의 마이크로컨트롤러 프로젝트의 경우에는 `9600`이 주로 사용됩니다. 초당 1200개의 문자를 전송하는 것과 같습니다. (16MHz 클럭의 ATmega328P는 초당 `1Mbps - 125000`개의 문자를 전송할 수도 있습니다)\n\n# 전송 속도 설정하기\n\n전송 속도 설정은 `UBRR0H`와 `UBRR0L` 레지스터에 기록하여 설정합니다. 이 레지스터에 기록되는 값은 아래 수식의 값입니다.\n\n![Buadrate Calc](/assets/image/2022-08-28-AVR-ATmega328P-UART/AVR-ATmega328P-UART_2.png)\n\n위의 수식에서 `fOSC`는 클럭 속도입니다. 프로젝트에서 16MHz의 외부 발진기를 사용하고 원하는 전송 속도가 9600이라고 가정하면 `UBRRn`의 값은 `(16000000/(16*9600)) - 1 = 103.167`이 됩니다. `103.167`은 정수가 아니므로 반올림해서 `103`이 됩니다.\n\n전송 속도 레지스터(`UBRR`)은 각각 8비트이므로 `103`을 하위 바이트와 상위 바이트로 분리해야 합니다. `255`보다 작기 때문에 상위 바이트가 `0`이고 하위 바이트가 `103`인 것은 분명하지만, 상위 바이트와 하위 바이트를 구분해서 코드를 작성하는 방법은 아래와 같습니다:\n\n```c\n    // 하위 바이트를 UBRR0L에 기록\n    UBRR0L = (uint8_t)(103 \u0026 0xFF);\n\n    // 상위 바이트를 UBRR0H에 기록\n    UBRR0H = (uint8_t)(103 \u003e\u003e 8)\n```\n\n# UART 송신기와 수신기 활성화하기\n\n`UCSR` 레지스터를 설정하여 송신 및 수신 기능을 활성화해야 합니다. 이 작업을 하지 않으면 마이크로컨트롤러의 UART RX/TX 핀은 표준 I/O핀으로 작동합니다. `UCSR0B` 레지스터의 `RXEN0`와 `TXEN0`의 비트를 `1`로 설정합니다.\n\n```c\n    // UART 송신기와 수신기 활성화\n    UCSR0B |= (1 \u003c\u003c RXEN0) | (1 \u003c\u003c TXEN0)\n```\n\n# 프레임 포맷\n\n마지막으로 데이터 비트 수, 정지 비트 수 및 패리티 비트 사용을 포함하는 프레임 포맷을 설정해야 하지만, 기본적으로 시스템은 8개의 데이터 비트에 패리티 비트는 없고 1개의 정지 비트(8N1이라고 불립니다)의 값으로 초기화됩니다. 이 설정은 일반적인 설정이며 대부분 터미널의 기본값이므로 여기서는 변경하지 않습니다.\n\n# 초기화 함수 작성하기\n\n아래와 같이 위의 내용을 바탕으로 UART를 초기화하는 함수를 작성합니다:\n\n```c\nvoid uartInit(uint16_t ubrr)\n{\n    // UBRR에 전송 속도(Buadrate)를 설정\n    UBRR0L = (uint8_t)(ubrr \u0026 0xFF);\n    UBRR0H = (uint8_t)(ubrr \u003e\u003e 8);\n\n    // UART 송신기와 수신기 활성화\n    UCSR0B |= (1 \u003c\u003c RXEN0) | (1 \u003c\u003c TXEN0);\n}\n```\n\n이 초기화 함수는 UART 관련 함수를 사용하기 전에 꼭 호출해야 합니다. 만약 호출하지 않는다면 UART는 작동하지 않습니다.\n\n# 단일 문자 전송\n\nUART에서 모든 전송 기능은 단일 문자를 UART를 통해 보내는 것으로 시작됩니다.\n\n```c\nvoid uartPut(unsigned char data)\n{\n    // 전송 버퍼가 비어 있을 때까지 기다립니다\n    while(!(UCSR0A \u0026 (1 \u003c\u003c UDRE0)));\n\n    // 데이터를 UDR(전송 레지스터)에 입력\n    UDR0 = data;\n}\n```\n\n데이터를 전송하려면 전송 버퍼가 비어 있는지 확인해야 합니다. 데이터시트에 따르면 `UDREn`이 `1`이면 버퍼가 비어있는 것을 의미하며 데이터를 전송할 준비가 된 것이라고 설명하고 있습니다. `UDRE0`은 USART 제어 및 상태 레지스터인 `UCSR0A` 있으므로, `UCSR0A`를 `(1 \u003c\u003c UDRE0)`으로 마스킹 해서 값을 얻을 수 있습니다.\n\n`UDRE0`가 `1`이 되면 버퍼가 비어있는 것으로 버퍼가 비어있을 때 전송하려는 문자를 `UDR0` 레지스터에 입력만 하면 나머지는 하드웨어가 알아서 처리하게 됩니다.\n\n# 문자열 전송\n\n단일 문자 전송 함수가 있으면 문자열을 보내는 함수를 작성하는 것은 매우 간단합니다.\n\n```c\nvoid uartPuts(char* s)\n{\n    // 문자열의 끝을 알리는 NULL이 나올때까지 단일 문자를 전송합니다\n    while(*s \u003e 0) uartPut(*s++);\n}\n```\n\n위의 함수는 문자열을 입력받아서 `NULL`이 나올 때까지 각 문자를 하나씩 전송합니다.\n\n# 16진수 값 전송\n\n터미널에서 읽을 수 있는 형식으로 16진수의 값을 전송하려면 먼저 ACSII로 변환해야 합니다.\n\n```c\nvoid uartPutHex8(uint8_t val)\n{\n    // 입력 값에서 상위 및 하위 니블 추출\n    uint8_t upperNibble = (val \u0026 0xF0) \u003e\u003e 4;\n    uint8_t lowerNibble = val \u0026 0x0F;\n\n    // 니블을 ASCII 16진수로 변환\n    upperNibble += upperNibble \u003e 9 ? 'A' - 10 : '0';\n    lowerNibble += lowerNibble \u003e 9 ? 'A' - 10 : '0';\n\n    // 문자를 출력\n    uartPut(upperNibble);\n    uartPut(lowerNibble);\n}\n```\n\n`uartPutHex8()`을 사용하면 더 큰 16진수 값을 출력하도록 쉽게 확장할 수 있습니다. 예를 들어 16비트의 값을 16진수의 값으로 전송하는 함수는 다음과 같습니다:\n\n```c\nvoid uartPutHex16(uint16_t val)\n{\n    // 상위 8비트를 전송\n    uartPutHex8((uint8_t)(val \u003e\u003e 8));\n\n    // 하위 8비트를 전송\n    uartPutHex8((uint8_t)(val \u0026 0x00FF));\n}\n```\n\n# 10진수 값 전송\n\n10진수 값을 전송하는 것은 바이트를 상위 및 하위 니블로 분할하고 직접 변환할 수 없기 때문에 위에서 구현한 16진수의 값을 전송하는 것보다 조금 더 까다롭습니다. 특히 ATmega328P에는 하드웨어 분할기가 없기 때문에 나누기에 대한 비용이 많이 듭니다. 대신 나누기 연산을 빼기로 대체하여 속도를 높일 수 있습니다.\n\n```c\nvoid uartPutU8(uint8_t val)\n{\n    uint8_t dig1 = '0', dig2 = '0';\n\n    // 100 단위의 값을 계산합니다\n    while(val \u003e= 100)\n    {\n        val -= 100;\n        dig1++;\n    }\n\n    // 10 단위의 값을 계산합니다\n    while(val \u003e= 10)\n    {\n        val -= 10;\n        dig2++;\n    }\n\n    // 첫 번째 숫자를 출력 (0이면 출력하지 않습니다)\n    if(dig1 != '0') uartPut(dig1);\n\n    // 두 번째 숫자를 출력 (0이면 출력하지 않습니다)\n    if((dig1 != '0') || (dig2 != '0')) uartPut(dig2);\n\n    // 마지막 숫자를 출력\n    uartPut(val + '0');\n}\n```\n\n위의 `uartPutU8()`은 부호가 없는 값을 출력합니다. 만약 부호가 있는 값을 출력해야 하면 어떻게 해야 할까요? 방법은 간단합니다. `MSB`가 1로 설정되어 있나 확인해서 `MSB`가 1이면 음수 기호를 출력하고 `uartPutU8()`을 호출합니다.\n\n```c\nvoid uartPutS8(int8_t val)\n{\n    // 값이 음수인지 확인합니다\n    if(val \u0026 0x80)\n    {\n        // 음수 기호를 출력합니다\n        uartPut('-');\n\n        // 부호 없는 값을 가져옵니다\n        val = ~(val - 1);\n    }\n\n    // 부호 없는 값을 출력합니다\n    uartPutU8((uint8_t)val);\n}\n```\n\n이 개념을 더 큰 자료형으로 확장하는 것은 간단합니다. 예를 들어 16비트의 값은 아래와 같이 확장할 수 있습니다:\n\n```c\nvoid uartPutU16(uint16_t val)\n{\n    uint8_t dig1 = '0', dig2 = '0', dig3 = '0', dig4 = '0';\n\n    // 10000 단위의 값을 계산합니다\n    while(val \u003e= 10000)\n    {\n        val -= 10000;\n        dig1++;\n    }\n\n    // 1000 단위의 값을 계산합니다\n    while(val \u003e= 1000)\n    {\n        val -= 1000;\n        dig2++;\n    }\n\n    // 100 단위의 값을 계산합니다\n    while(val \u003e= 100)\n    {\n        val -= 100;\n        dig3++;\n    }\n\n    // 10 단위의 값을 계산합니다\n    while(val \u003e= 10)\n    {\n        val -= 10;\n        dig4++;\n    }\n\n    // 이전 값이 출력되었는지 저장하는 변수입니다\n    uint8_t prevPrinted = 0;\n\n    // 첫 번째 숫자를 출력 (0이면 출력하지 않습니다)\n    if(dig1 != '0') {uartPut(dig1); prevPrinted = 1;}\n\n    // 두 번째 숫자를 출력 (0이면 출력하지 않습니다)\n    if(prevPrinted || (dig2 != '0')) {uartPut(dig2); prevPrinted = 1;}\n\n    // 세 번째 숫자를 출력 (0이면 출력하지 않습니다)\n    if(prevPrinted || (dig3 != '0')) {uartPut(dig3); prevPrinted = 1;}\n\n    // 네 번째 숫자를 출력 (0이면 출력하지 않습니다)\n    if(prevPrinted || (dig4 != '0')) {uartPut(dig4); prevPrinted = 1;}\n\n    // 마지막 숫자를 출력\n    uartPut(val + '0');\n}\n```\n\n```c\nvoid uartPutS16(int16_t val)\n{\n    // check for negative number\n    if(val \u0026 0x8000)\n    {\n        // print minus sign\n        uartPut('-');\n\n        // convert to unsigned magnitude\n        val = ~(val - 1);\n    }\n\n    // print unsigned magnitude\n    uartPutU16((uint16_t) val);\n}\n```\n\n# UART를 통해 수신하기\n\nUART를 통해 단일 문자를 수신하는 건 위에서 구현한 `uartPut()`와 비슷합니다. 문자를 수신할 때는 `RXC0` 비트가 Set 될 때까지 `UCSR0A` 레지스터를 폴링 하면 됩니다. 그리고 `UDR0`에서 수신한 문자를 반환할 수 있습니다.\n\n```c\nvoid uartGet(void)\n{\n    // 데이터 수신을 기다립니다\n    while(!(UCSR0A \u0026 (1 \u003c\u003c RXC0)));\n\n    // 데이터를 반환합니다\n    return UDR0;\n}\n```\n\n캐리지 리턴(`\\r`)로 끝나는 데이터의 전체 라인을 수신하기 위해 `uartGetLine()`을 구현해 봅시다.\n\n```c\nvoid uartGetLine(char* buf, uint8_t n)\n{\n    uint8_t bufIdx = 0;\n    char c;\n\n    // 수신된 문자가 캐리지 리턴(\\r)이 나올때까지 수신합니다\n    do\n    {\n        // 단일 문자를 수신합니다\n        c = uartGet();\n\n        // 수신한 단일 문자를 출력합니다\n        uartPut(c);\n\n        // 버퍼에 단일 문자를 저장합니다\n        buf[bufIdx++] = c;\n    }\n    while((bufIdx \u003c n) \u0026\u0026 (c != '\\r'));\n\n    // 문자열 버퍼의 마지막에 NULL을 입력해서 문자열의 끝을 지정합니다\n    buf[bufIdx] = 0;\n}\n```\n\n앞에서 구현한 함수와 달리 여기서는 실제로 버퍼를 할당하여 문자를 저장하고, 수신 함수에 전달합니다. 예를 들면 아래와 같습니다:\n\n```c\n    // Buffer를 할당합니다.\n    const uint8_t bufSize = 20;\n    char buf[bufSize];\n\n    // UART를 통해 데이터의 전체라인을 수신합니다\n    uartGetLine(buf, bufSize);\n\n    // 수신한 데이터를 출력합니다\n    uartPuts(\"You entered: \");\n    uartPuts(buf);\n    uartPut('\\n');\n```\n\n# ATmega328P에서 실행하기\n\n프로젝트에 아래의 파일을 생성합니다.\n\n**MakeFile :**\n\n```makefile\nCC = avr-gcc\nCFLAGS = -Wall -Os -mmcu=atmega328p\nOBJCOPY = avr-objcopy\n\nOBJ = main.o uart.o\n\nall: atmega328p-uart.hex\n\n%.o: %.c\n\t$(CC) $(CFLAGS) -c $\u003c\n\natmega328p-uart.elf: $(OBJ)\n\t$(CC) $(CFLAGS) -o atmega328p-uart.elf $(OBJ)\n\natmega328p-uart.hex: atmega328p-uart.elf\n\t$(OBJCOPY) atmega328p-uart.elf -O ihex atmega328p-uart.hex\n\nclean:\n\trm -f *.o *.elf *.hex\n```\n\n**uart.h :**\n\n```c\n#include \u003cstdint.h\u003e\n\nvoid uartInit(uint16_t ubrr);\nvoid uartPut(unsigned char data);\nvoid uartPuts(char *s);\nvoid uartPutHex8(uint8_t val);\nvoid uartPutHex16(uint16_t val);\nvoid uartPutU8(uint8_t val);\nvoid uartPutS8(int8_t val);\nvoid uartPutU16(uint16_t val);\nvoid uartPutS16(int16_t val);\nunsigned char uartGet(void);\nvoid uartGetLine(char *buf, uint8_t n);\n```\n\n**uart.c :**\n\n```c\n#include \u003cavr/io.h\u003e\n#include \"uart.h\"\n\nvoid uartInit(uint16_t ubrr)\n{\n    // UBRR에 전송 속도(Buadrate)를 설정\n    UBRR0L = (uint8_t)(ubrr \u0026 0xFF);\n    UBRR0H = (uint8_t)(ubrr \u003e\u003e 8);\n\n    // UART 송신기와 수신기 활성화\n    UCSR0B |= (1 \u003c\u003c RXEN0) | (1 \u003c\u003c TXEN0);\n    uartPuts(\"\\n\\r\");\n    uartPuts(\"[INFO] UART initialized!\\n\\r\");\n}\n\nvoid uartPut(unsigned char data)\n{\n    // 전송 버퍼가 비어 있을 때까지 기다립니다\n    while (!(UCSR0A \u0026 (1 \u003c\u003c UDRE0)))\n        ;\n\n    // 데이터를 UDR(전송 레지스터)에 입력\n    UDR0 = data;\n}\n\nvoid uartPuts(char *s)\n{\n    // 문자열의 끝을 알리는 NULL이 나올때까지 단일 문자를 전송합니다\n    while (*s \u003e 0)\n        uartPut(*s++);\n}\n\nvoid uartPutHex8(uint8_t val)\n{\n    // 입력 값에서 상위 및 하위 니블 추출\n    uint8_t upperNibble = (val \u0026 0xF0) \u003e\u003e 4;\n    uint8_t lowerNibble = val \u0026 0x0F;\n\n    // 니블을 ASCII 16진수로 변환\n    upperNibble += upperNibble \u003e 9 ? 'A' - 10 : '0';\n    lowerNibble += lowerNibble \u003e 9 ? 'A' - 10 : '0';\n\n    // 문자를 출력\n    uartPut(upperNibble);\n    uartPut(lowerNibble);\n}\n\nvoid uartPutHex16(uint16_t val)\n{\n    // 상위 8비트를 전송\n    uartPutHex8((uint8_t)(val \u003e\u003e 8));\n\n    // 하위 8비트를 전송\n    uartPutHex8((uint8_t)(val \u0026 0x00FF));\n}\n\nvoid uartPutU8(uint8_t val)\n{\n    uint8_t dig1 = '0', dig2 = '0';\n\n    // 100 단위의 값을 계산합니다\n    while (val \u003e= 100)\n    {\n        val -= 100;\n        dig1++;\n    }\n\n    // 10 단위의 값을 계산합니다\n    while (val \u003e= 10)\n    {\n        val -= 10;\n        dig2++;\n    }\n\n    // 첫 번째 숫자를 출력 (0이면 출력하지 않습니다)\n    if (dig1 != '0')\n        uartPut(dig1);\n\n    // 두 번째 숫자를 출력 (0이면 출력하지 않습니다)\n    if ((dig1 != '0') || (dig2 != '0'))\n        uartPut(dig2);\n\n    // 마지막 숫자를 출력\n    uartPut(val + '0');\n}\n\nvoid uartPutS8(int8_t val)\n{\n    // 값이 음수인지 확인합니다\n    if (val \u0026 0x80)\n    {\n        // 음수 기호를 출력합니다\n        uartPut('-');\n\n        // 부호 없는 값을 가져옵니다\n        val = ~(val - 1);\n    }\n\n    // 부호 없는 값을 출력합니다\n    uartPutU8((uint8_t)val);\n}\n\nvoid uartPutU16(uint16_t val)\n{\n    uint8_t dig1 = '0', dig2 = '0', dig3 = '0', dig4 = '0';\n\n    // 10000 단위의 값을 계산합니다\n    while (val \u003e= 10000)\n    {\n        val -= 10000;\n        dig1++;\n    }\n\n    // 1000 단위의 값을 계산합니다\n    while (val \u003e= 1000)\n    {\n        val -= 1000;\n        dig2++;\n    }\n\n    // 100 단위의 값을 계산합니다\n    while (val \u003e= 100)\n    {\n        val -= 100;\n        dig3++;\n    }\n\n    // 10 단위의 값을 계산합니다\n    while (val \u003e= 10)\n    {\n        val -= 10;\n        dig4++;\n    }\n\n    // 이전 값이 출력되었는지 저장하는 변수입니다\n    uint8_t prevPrinted = 0;\n\n    // 첫 번째 숫자를 출력 (0이면 출력하지 않습니다)\n    if (dig1 != '0')\n    {\n        uartPut(dig1);\n        prevPrinted = 1;\n    }\n\n    // 두 번째 숫자를 출력 (0이면 출력하지 않습니다)\n    if (prevPrinted || (dig2 != '0'))\n    {\n        uartPut(dig2);\n        prevPrinted = 1;\n    }\n\n    // 세 번째 숫자를 출력 (0이면 출력하지 않습니다)\n    if (prevPrinted || (dig3 != '0'))\n    {\n        uartPut(dig3);\n        prevPrinted = 1;\n    }\n\n    // 네 번째 숫자를 출력 (0이면 출력하지 않습니다)\n    if (prevPrinted || (dig4 != '0'))\n    {\n        uartPut(dig4);\n        prevPrinted = 1;\n    }\n\n    // 마지막 숫자를 출력\n    uartPut(val + '0');\n}\n\nvoid uartPutS16(int16_t val)\n{\n    // check for negative number\n    if (val \u0026 0x8000)\n    {\n        // print minus sign\n        uartPut('-');\n\n        // convert to unsigned magnitude\n        val = ~(val - 1);\n    }\n\n    // print unsigned magnitude\n    uartPutU16((uint16_t)val);\n}\n\nunsigned char uartGet(void)\n{\n    // 데이터 수신을 기다립니다\n    while (!(UCSR0A \u0026 (1 \u003c\u003c RXC0)))\n        ;\n\n    // 데이터를 반환합니다\n    return UDR0;\n}\n\nvoid uartGetLine(char *buf, uint8_t n)\n{\n    uint8_t bufIdx = 0;\n    char c;\n\n    // 수신된 문자가 캐리지 리턴(\\r)이 나올때까지 수신합니다\n    do\n    {\n        // 단일 문자를 수신합니다\n        c = uartGet();\n\n        // 수신한 단일 문자를 출력합니다\n        uartPut(c);\n\n        // 버퍼에 단일 문자를 저장합니다\n        buf[bufIdx++] = c;\n    } while ((bufIdx \u003c n) \u0026\u0026 (c != '\\r'));\n\n    // 문자열 버퍼의 마지막에 NULL을 입력해서 문자열의 끝을 지정합니다\n    buf[bufIdx] = 0;\n}\n```\n\n**main.c :**\n\n```c\n#include \u003cavr/interrupt.h\u003e\n#include \"uart.h\"\n/*\n  CPU의 Frequency를 16MHz로 설정합니다\n*/\n#define F_CPU 16000000UL\n#include \u003cutil/delay.h\u003e\n\nint main(void)\n{\n  // Buffer를 할당합니다.\n  const uint8_t bufSize = 20;\n  char buf[bufSize];\n\n  // UART 전송속도를 설정합니다\n  const unsigned int baudRate = (F_CPU / 16 / 9600) - 1;\n\n  _delay_ms(100); // VCC 안정화를 위해 100ms 동안 대기합니다\n\n  cli(); // 모든 인터럽트를 비활성화 합니다\n\n  // UART를 초기화 합니다\n  uartInit(baudRate);\n\n  // UART를 통해 데이터의 전체라인을 수신합니다\n  uartPuts(\"Please enter any text : \");\n  uartGetLine(buf, bufSize);\n\n  // 수신한 데이터를 출력합니다\n  uartPuts(\"\\n\\r\");\n  uartPuts(\"You entered : \");\n  uartPuts(buf);\n  uartPuts(\"\\n\\r\");\n\n  return 0;\n}\n```\n\n이제 빌드하고 ATmega328P의 Flash Write 해봅시다.\n\n브레드보드에 연결된 Arduino에 ArduinoISP 예제를 넣습니다.  \n![ArduinoISP](/assets/image/2022-08-28-AVR-ATmega328P-UART/AVR-ATmega328P-UART_3.png)\n\n그리고 아래의 명령어를 실행하여 ATmega328P UART 프로젝트를 빌드하고 ATmega328P에 기록합니다.\n\n\u003e `/dev/tty.usbmodem2112201` 부분은 Arduino Board를 입력합니다. ArduinoISP가 프로그래밍되어 있는 Arduino Board는 데이터를 받아 브레드보드에 있는 ATmega328P에 기록합니다\n\n```sh\nmake\navrdude -c stk500v1 -b 19200 -F -p m328p -P /dev/tty.usbmodem2112201 -Uflash:w:atmega328p-uart.hex:i\n```\n\n![Build and Flash](/assets/image/2022-08-28-AVR-ATmega328P-UART/AVR-ATmega328P-UART_4.png)\n\n`minicom`로 ATmega328P에 연결된 UART에 접속해서 정상적으로 동작하는지 확인해 봅니다.  \n입력한 값이 그대로 출력된다면 정상 작동하는 것입니다.  \n![minicom](/assets/image/2022-08-28-AVR-ATmega328P-UART/AVR-ATmega328P-UART_5.png)\n"},"__N_SSG":true},"page":"/article/[category]/[year]/[month]/[day]/[slug]","query":{"category":"avr","year":"2022","month":"08","day":"28","slug":"AVR-ATmega328P-UART"},"buildId":"scdaJ3xe6OSbCbEhPmPOm","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>