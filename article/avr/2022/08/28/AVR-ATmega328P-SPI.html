<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta property="og:image" content="https://kyuhyuk.kr/thumbnail.png"/><title>[AVR] ATmega328P SPI 구현</title><meta name="author" content="KyuHyuk Lee"/><meta name="generator" content="KyuHyuk Lee"/><meta name="description" content=" SPI(Serial Peripheral Interface)는 마이크로컨트롤러에 매우 유용한 데이터 전송 프로토콜입니다. UART와 달리 SPI는 동기식(Synchronous)입니다. 데이터 전송이 두 통신 장치 간의 공유 클럭 신호에 동기화됩니다. 하드웨어 수준에서 구현을 크게 단순화"/><meta itemProp="url" content="https://kyuhyuk.kr/article/avr/2022/08/28/AVR-ATmega328P-SPI"/><meta itemProp="headline" content="[AVR] ATmega328P SPI 구현"/><meta property="og:type" content="article"/><meta property="og:url" content="https://kyuhyuk.kr/article/avr/2022/08/28/AVR-ATmega328P-SPI"/><meta property="og:title" content="[AVR] ATmega328P SPI 구현"/><meta property="og:description" content=" SPI(Serial Peripheral Interface)는 마이크로컨트롤러에 매우 유용한 데이터 전송 프로토콜입니다. UART와 달리 SPI는 동기식(Synchronous)입니다. 데이터 전송이 두 통신 장치 간의 공유 클럭 신호에 동기화됩니다. 하드웨어 수준에서 구현을 크게 단순화"/><meta property="og:site_name" content="KyuHyuk Blog"/><meta property="og:locale" content="ko_KR"/><meta name="next-head-count" content="15"/><style id="stitches">--sxs{--sxs:2 c-opBYf c-bHyrwK c-uBnvQ c-hehuMV c-bjkCdF c-hAoZGi c-jfcKOQ c-ezyKJG c-iAzQif c-bvdusc c-ezRQNp c-iosjjB c-jYwCTI c-iOPkYY c-cpkrrK c-fiqONv c-iUFgVP c-cshSRb c-fxvkZv c-dIcdES}@media{.c-opBYf{display:flex;align-items:center;background:#FFFFFF;height:60px;justify-content:space-between;-webkit-box-align:center;-webkit-box-pack:justify}.c-bHyrwK{display:flex;align-items:center;justify-content:center;-webkit-box-align:center;-webkit-box-pack:center}.c-uBnvQ{width:32px;height:32px;color:#FFFFFF;background:#000000;border-radius:4px;display:flex;align-items:center;justify-content:center;margin-right:12px;font-weight:700;cursor:default;-webkit-box-align:center;-webkit-box-pack:center}.c-hehuMV{font-weight:900;font-size:18px;letter-spacing:0.5px;color:#000000;cursor:default}.c-bjkCdF{list-style:none;padding:0;margin:0;display:flex;justify-content:center;align-items:center;font-size:24px;color:rgb(134, 142, 150);transition:all 0.3s ease 0s;-webkit-box-pack:center;-webkit-box-align:center}.c-hAoZGi{font-size:28px;color:inherit;text-decoration:none;margin:8px}.c-jfcKOQ{max-width:768px;margin-top:2rem;margin-left:auto;margin-right:auto}.c-ezyKJG{min-width:72px;display:flex;flex-direction:row;justify-content:center;align-items:center;padding:6px 16px;background:#12B886;box-shadow:0px 1px 2px rgba(98, 16, 204, 0.3);border:none;border-radius:14px;vertical-align:middle;color:#FFFFFF;font-size:1rem;height:2rem;float:right}.c-iAzQif{display:inline-block;margin-top:2rem}.c-bvdusc{font-size:2rem;line-height:1.5;letter-spacing:-0.004em;margin-top:0;margin-bottom:2rem;font-weight:700;color:#212529;word-break:keep-all;transition:color 0.125s ease-in 0s;}.c-ezRQNp{font-size:1.125rem;color:#212529;transition:color 0.125s ease-in 0s;;line-height:1.7;letter-spacing:-0.004em;word-break:break-all;overflow-wrap:break-word}.c-iosjjB{background:#F8F9FA;padding:0 1rem;height:2rem;border-radius:1rem;display:inline-flex;align-items:center;margin-right:0.875rem;color:#12B886;text-decoration:none;font-weight:400;font-size:1rem}.c-jYwCTI{font-size:1rem;color:#495057}.c-iOPkYY{margin-top:3rem;background-color:rgba(51,51,51,.1);border:0;height:1px}.c-cpkrrK{width:100%;height:300px;display:flex;align-items:center;justify-content:center;flex-direction:column;-webkit-box-align:center;-webkit-box-pack:center}.c-fiqONv{color:rgb(206, 212, 218);margin-bottom:8px;font-size:22px;font-weight:700}.c-iUFgVP{width:32px;height:32px;color:#FFFFFF;background:rgb(206, 212, 218);border-radius:4px;display:flex;align-items:center;justify-content:center;margin-right:12px;font-weight:700;cursor:default;-webkit-box-align:center;-webkit-box-pack:center}.c-cshSRb{font-weight:900;font-size:18px;letter-spacing:0.5px;color:rgb(206, 212, 218);cursor:default;text-transform:uppercase}.c-fxvkZv{font-size:2.5rem;line-height:1.5;letter-spacing:-0.004em;margin-top:0;margin-bottom:2rem;font-weight:700;color:#212529;word-break:keep-all;transition:color 0.125s ease-in 0s;}.c-dIcdES{margin-top:2rem;font-size:1.125rem;color:#212529;transition:color 0.125s ease-in 0s;;line-height:1.7;letter-spacing:-0.004em;word-break:keep-all;overflow-wrap:break-word}}</style><link rel="preload" href="/_next/static/css/98b299b94b0a7962.css" as="style"/><link rel="stylesheet" href="/_next/static/css/98b299b94b0a7962.css" data-n-g=""/><link rel="preload" href="/_next/static/css/c2a527101433f11d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c2a527101433f11d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-c354a30bda3d62a6.js" defer=""></script><script src="/_next/static/chunks/pages/_app-8265bb1a072646d3.js" defer=""></script><script src="/_next/static/chunks/776-f277552409ab147f.js" defer=""></script><script src="/_next/static/chunks/305-e325b960616dc0fd.js" defer=""></script><script src="/_next/static/chunks/pages/article/%5Bcategory%5D/%5Byear%5D/%5Bmonth%5D/%5Bday%5D/%5Bslug%5D-aa033f8eb8939164.js" defer=""></script><script src="/_next/static/FrFmlSEPIvXzRhY1fSPxA/_buildManifest.js" defer=""></script><script src="/_next/static/FrFmlSEPIvXzRhY1fSPxA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="c-opBYf"><a href="https://kyuhyuk.kr"><div class="c-bHyrwK"><div class="c-uBnvQ">Kh.</div><div class="c-hehuMV">KyuHyuk Blog</div></div></a><ul class="c-bjkCdF"><li><a href="https://github.com/LeeKyuHyuk" class="c-hAoZGi"><span role="img" aria-label="github" class="anticon anticon-github"><svg viewBox="64 64 896 896" focusable="false" data-icon="github" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0138.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"></path></svg></span></a></li><li><a href="https://linkedin.com/in/leekyuhyuk" class="c-hAoZGi"><span role="img" aria-label="linkedin" class="anticon anticon-linkedin"><svg viewBox="64 64 896 896" focusable="false" data-icon="linkedin" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zM349.3 793.7H230.6V411.9h118.7v381.8zm-59.3-434a68.8 68.8 0 1168.8-68.8c-.1 38-30.9 68.8-68.8 68.8zm503.7 434H675.1V608c0-44.3-.8-101.2-61.7-101.2-61.7 0-71.2 48.2-71.2 98v188.9H423.7V411.9h113.8v52.2h1.6c15.8-30 54.5-61.7 112.3-61.7 120.2 0 142.3 79.1 142.3 181.9v209.4z"></path></svg></span></a></li><li><a href="mailto:lee@kyuhyuk.kr" class="c-hAoZGi"><span role="img" aria-label="mail" class="anticon anticon-mail"><svg viewBox="64 64 896 896" focusable="false" data-icon="mail" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-80.8 108.9L531.7 514.4c-7.8 6.1-18.7 6.1-26.5 0L189.6 268.9A7.2 7.2 0 01194 256h648.8a7.2 7.2 0 014.4 12.9z"></path></svg></span></a></li></ul></header><main class="c-jfcKOQ"><article><h1 class="c-fxvkZv"><a href="https://kyuhyuk.kr/article/avr/2022/08/28/AVR-ATmega328P-SPI">[AVR] ATmega328P SPI 구현</a></h1><a href="https://kyuhyuk.kr/category/AVR" class="c-iosjjB">AVR</a><time dateTime="2022-08-28 15:21:12" class="c-jYwCTI">Aug 28, 2022 03:21:12 PM</time><div id="post" class="c-dIcdES"><p>SPI(Serial Peripheral Interface)는 마이크로컨트롤러에 매우 유용한 데이터 전송 프로토콜입니다.</p>
<p>UART와 달리 SPI는 동기식(Synchronous)입니다. 데이터 전송이 두 통신 장치 간의 공유 클럭 신호에 동기화됩니다. 하드웨어 수준에서 구현을 크게 단순화해서 시프트(Shift) 레지스터만 필요로 하고 장치 간의 전송 속도도 미리 합의할 필요가 없습니다.</p>
<p>SPI는 하나의 장치가 마스터로 작동하고 다른 장치가 슬레이브로 작동해야 합니다. 마스터는 SPI 버스의 모든 상호 작용을 제어하고, 슬레이브는 마스터가 지시할 때만 데이터를 보내거나 받습니다. 마스터는 슬레이브 선택(SS: Slave Select)이라고 하는 라인을 통해 각 슬레이브를 제어합니다. 이 라인은 수신하거나 전송해야한다는것을 슬레이브에게 알려주기 위해 LOW로 작동됩니다. SPI에 대한 일반적인 레이아웃은 아래와 같습니다.</p>
<p><img src="/assets/image/2022-08-28-AVR-ATmega328P-SPI/2022-08-28-AVR-ATmega328P-SPI_1.png" alt="SPI Layout"></p>
<p>SPI는 모든 장치가 동일한 버스를 공유할 수 있고 서로의 통신을 방해할 염려가 없다는 장점이 있지만, 마스터가 버스의 각 슬레이브에 대해 전용 핀을 가져야 하므로 많은 수의 장치가 있는 경우에는 실용적이지 않을 수 있습니다.</p>
<h1>SPI Master 초기화</h1>
<p>이 예제에서는 ATmeaga328P를 마스터로 지정해서 SPI를 초기화해보겠습니다. 하나의 장치가 있고 <code>PINB2</code>를 CS(Chip Select)로 사용하고 있다고 가정합니다.</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SPI_DDR DDRB</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CS      PINB2</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MOSI    PINB3</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MISO    PINB4</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SCK     PINB5</span>

<span class="hljs-type">void</span> <span class="hljs-title function_">spiInit</span><span class="hljs-params">()</span>
{
    <span class="hljs-comment">// CS와 MOSI, SCK를 출력으로 설정합니다</span>
    SPI_DDR |= (<span class="hljs-number">1</span> &lt;&lt; CS) | (<span class="hljs-number">1</span> &lt;&lt; MOSI) | (<span class="hljs-number">1</span> &lt;&lt; SCK);

    <span class="hljs-comment">// SPI를 활성화하고 Master로 Clock은 fOSC/128로 설정합니다.</span>
    SPCR = (<span class="hljs-number">1</span> &lt;&lt; SPE) | (<span class="hljs-number">1</span> &lt;&lt; MSTR) | (<span class="hljs-number">1</span> &lt;&lt; SPR1) | (<span class="hljs-number">1</span> &lt;&lt; SPR0);
}
</code></pre>
<p>ATmega328P의 <code>MOSI</code>, <code>MISO</code> 및 클럭 라인은 <code>PINB3</code>, <code>PINB4</code>와 <code>PINB5</code>입니다. 핀 이름이 아닌 기능으로 보기 위해 <code>define</code> 문을 사용했습니다. 마스터로 동작하기 때문에 <code>CS</code>, <code>MOSI</code>, <code>SCK</code>를 출력(Output)으로 설정합니다. <code>MISO</code>는 기본값이 입력(Input)으로 설정되어 있습니다.</p>
<pre><code class="language-c">    <span class="hljs-comment">// CS와 MOSI, SCK를 출력으로 설정합니다</span>
    SPI_DDR |= (<span class="hljs-number">1</span> &lt;&lt; CS) | (<span class="hljs-number">1</span> &lt;&lt; MOSI) | (<span class="hljs-number">1</span> &lt;&lt; SCK);
</code></pre>
<p>다음으로 <code>SPCR</code>(SPI 제어 레지스터)에서 SPI를 활성화합니다. <code>SPE</code>에 <code>1</code>을 쓰면 됩니다. <code>MSTR</code>에 <code>1</code>을 기입하여 마스터로 작동하고 있음도 설정합니다. 마지막으로 클럭 속도를 설정해야 합니다. 기본값으로 fOSC/4로 설정됩니다. 그러나 몇몇 장치에서는 너무 높은 클럭일 수 있습니다. 인터페이스하는 장치의 최대 클럭 속도가 얼마인지 확실하지 않은 경우 클럭을 가능한 가장 느린 속도로 설정하는게 좋습니다. 그래서 이 예제에서는 fOSC/128의 클럭을 제공하도록 설정합니다. <code>SPR1</code>과 <code>SPR0</code>에 각각 <code>1</code>을 기입합니다.</p>
<pre><code class="language-c">    <span class="hljs-comment">// SPI를 활성화하고 Master로 Clock은 fOSC/128로 설정합니다.</span>
    SPCR = (<span class="hljs-number">1</span> &lt;&lt; SPE) | (<span class="hljs-number">1</span> &lt;&lt; MSTR) | (<span class="hljs-number">1</span> &lt;&lt; SPR1) | (<span class="hljs-number">1</span> &lt;&lt; SPR0);
</code></pre>
<h1>SPI 데이터 전송</h1>
<p>SPI 마스터에서 바이트를 전송하는 것은 매우 간단합니다. 아래와 같이 함수를 구현합니다.</p>
<pre><code class="language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">spiTransmitByte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> data)</span>
{
    <span class="hljs-comment">// SPI로 전송할 데이터를 SPDR(SPI Data Register)에 저장</span>
    SPDR = data;

    <span class="hljs-comment">/*
      SPIF(SPI Interrupt Flag)가 Set될 때까지 기다립니다
      SPIF가 Set이 되었다면 SPI로 데이터가 전송이 완료된것입니다
    */</span>
    <span class="hljs-keyword">while</span>(!(SPSR &amp; (<span class="hljs-number">1</span> &lt;&lt; SPIF)));
}
</code></pre>
<p>먼저 SPI 데이터 레지스터 <code>SPDR</code>에 전송해야 하는 데이터를 저장합니다.</p>
<pre><code class="language-c">    <span class="hljs-comment">// SPI로 전송할 데이터를 SPDR(SPI Data Register)에 저장</span>
    SPDR = data;
</code></pre>
<p>그리고 <code>SPIF</code> 플래그가 Clear 되기를 기다리면서 SPI 상태 레지스터인 <code>SPSR</code>을 폴링 합니다.</p>
<pre><code class="language-c">    <span class="hljs-comment">/*
      SPIF(SPI Interrupt Flag)가 Set될 때까지 기다립니다
      SPIF가 Set이 되었다면 SPI로 데이터가 전송이 완료된것입니다
    */</span>
    <span class="hljs-keyword">while</span>(!(SPSR &amp; (<span class="hljs-number">1</span> &lt;&lt; SPIF)));
</code></pre>
<p>SPI를 통해 장치로 전송할 때 데이터가 전송되기 전에 전송하려는 장치의 슬레이브 선택 라인이 LOW로 구동되어 한다는 점은 항상 명심해야 합니다.</p>
<pre><code class="language-c">    <span class="hljs-comment">// SS(Slave Select)를 LOW로 설정</span>
    SPI_DDR &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; SS);

    <span class="hljs-comment">// 슬레이브로 데이터 전송</span>
    spiTransmitByte(<span class="hljs-number">0x55</span>);

    <span class="hljs-comment">// SS(Slave Select)를 HIGH로 설정</span>
    SPI_DDR |= (<span class="hljs-number">1</span> &lt;&lt; SS);
</code></pre>
<h1>SPI 데이터 수신</h1>
<p>SPI를 통해 데이터를 수신하는 것은 데이터 전송과 비슷합니다.</p>
<pre><code class="language-c"><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">spiReceive</span><span class="hljs-params">()</span>
{
    <span class="hljs-comment">/*
      SPI에서 데이터를 전송하면 항상 0xFF를 전송하고 SPI 데이터 레지스터를
      반환합니다. 슬레이브가 데이터를 다시 전송하기 위해 클럭을 생성하기
      때문에 0xFF를 전송하는데, 이것을 사용하여 SPDR에 0xFF를 Dummy Byte로
      전송하면 SPI 수신을 받을 수 있습니다
    */</span>
    SPDR = <span class="hljs-number">0xFF</span>;

    <span class="hljs-comment">/*
      SPIF(SPI Interrupt Flag)가 Set될 때까지 기다립니다
      SPIF가 Set이 되었다면 SPI로 데이터가 전송이 완료된것입니다
    */</span>
    <span class="hljs-keyword">while</span>(!(SPSR &amp; (<span class="hljs-number">1</span> &lt;&lt; SPIF)));

    <span class="hljs-comment">// SPI로 수신한 데이터(SPDR)을 반환합니다</span>
    <span class="hljs-keyword">return</span> SPDR;
}
</code></pre>
<p>SPI에서 데이터를 전송하면 항상 <code>0xFF</code>를 전송하고 SPI 데이터 레지스터를 반환합니다. 슬레이브가 데이터를 다시 전송하기 위해 클럭을 생성하기 때문에 <code>0xFF</code>를 전송하는데, 이것을 사용하여 <code>SPDR</code>에 <code>0xFF</code>를 Dummy Byte로 전송하면 SPI 수신을 받을 수 있습니다.</p>
<p>만약, 항상 입력 바이트를 사용하여 전송하고 항상 SPI 데이터 레지스터를 반환하도록 함수를 작성하고 싶다면, 아래와 같이 작성할 수 있습니다.</p>
<pre><code class="language-c"><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">spiTxRx</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> data)</span>
{
    <span class="hljs-comment">// SPI로 전송할 데이터를 SPDR(SPI Data Register)에 저장</span>
    SPDR = data;

    <span class="hljs-comment">/*
      SPIF(SPI Interrupt Flag)가 Set될 때까지 기다립니다
      SPIF가 Set이 되었다면 SPI로 데이터가 전송이 완료된것입니다
    */</span>
    <span class="hljs-keyword">while</span>(!(SPSR &amp; (<span class="hljs-number">1</span> &lt;&lt; SPIF)));

    <span class="hljs-comment">// SPI로 수신한 데이터(SPDR)을 반환합니다</span>
    <span class="hljs-keyword">return</span> SPDR;
}
</code></pre>
<p>위의 코드를 사용하면 송신 수신 시퀀스는 아래와 같습니다:</p>
<pre><code class="language-c">    <span class="hljs-comment">// SS(Slave Select)를 LOW로 설정</span>
    SPI_DDR &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; SS);

    <span class="hljs-comment">// 데이터를 슬레이브로 전송합니다 (응답은 무시)</span>
    spiTransmitByte(<span class="hljs-number">0x55</span>);

    <span class="hljs-comment">// 슬레이브로 부터 데이터를 수신합니다</span>
    <span class="hljs-type">uint8_t</span> ret = spiTxRx(<span class="hljs-number">0xFF</span>);

    <span class="hljs-comment">// SS(Slave Select)를 HIGH로 설정</span>
    SPI_DDR |= (<span class="hljs-number">1</span> &lt;&lt; SS);
</code></pre>
</div></article></main><footer class="c-cpkrrK"><div class="c-fiqONv">© <!-- -->2022</div><div class="c-bHyrwK"><div class="c-iUFgVP">Kh.</div><div class="c-cshSRb">KyuHyuk Lee</div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"excerpt":" SPI(Serial Peripheral Interface)는 마이크로컨트롤러에 매우 유용한 데이터 전송 프로토콜입니다. UART와 달리 SPI는 동기식(Synchronous)입니다. 데이터 전송이 두 통신 장치 간의 공유 클럭 신호에 동기화됩니다. 하드웨어 수준에서 구현을 크게 단순화","url":"/article/avr/2022/08/28/AVR-ATmega328P-SPI","frontmatter":{"title":"[AVR] ATmega328P SPI 구현","date":"2022-08-28 15:21:12","category":"AVR"},"content":"\nSPI(Serial Peripheral Interface)는 마이크로컨트롤러에 매우 유용한 데이터 전송 프로토콜입니다.\n\nUART와 달리 SPI는 동기식(Synchronous)입니다. 데이터 전송이 두 통신 장치 간의 공유 클럭 신호에 동기화됩니다. 하드웨어 수준에서 구현을 크게 단순화해서 시프트(Shift) 레지스터만 필요로 하고 장치 간의 전송 속도도 미리 합의할 필요가 없습니다.\n\nSPI는 하나의 장치가 마스터로 작동하고 다른 장치가 슬레이브로 작동해야 합니다. 마스터는 SPI 버스의 모든 상호 작용을 제어하고, 슬레이브는 마스터가 지시할 때만 데이터를 보내거나 받습니다. 마스터는 슬레이브 선택(SS: Slave Select)이라고 하는 라인을 통해 각 슬레이브를 제어합니다. 이 라인은 수신하거나 전송해야한다는것을 슬레이브에게 알려주기 위해 LOW로 작동됩니다. SPI에 대한 일반적인 레이아웃은 아래와 같습니다.\n\n![SPI Layout](/assets/image/2022-08-28-AVR-ATmega328P-SPI/2022-08-28-AVR-ATmega328P-SPI_1.png)\n\nSPI는 모든 장치가 동일한 버스를 공유할 수 있고 서로의 통신을 방해할 염려가 없다는 장점이 있지만, 마스터가 버스의 각 슬레이브에 대해 전용 핀을 가져야 하므로 많은 수의 장치가 있는 경우에는 실용적이지 않을 수 있습니다.\n\n# SPI Master 초기화\n\n이 예제에서는 ATmeaga328P를 마스터로 지정해서 SPI를 초기화해보겠습니다. 하나의 장치가 있고 `PINB2`를 CS(Chip Select)로 사용하고 있다고 가정합니다.\n\n```c\n#define SPI_DDR DDRB\n#define CS      PINB2\n#define MOSI    PINB3\n#define MISO    PINB4\n#define SCK     PINB5\n\nvoid spiInit()\n{\n    // CS와 MOSI, SCK를 출력으로 설정합니다\n    SPI_DDR |= (1 \u003c\u003c CS) | (1 \u003c\u003c MOSI) | (1 \u003c\u003c SCK);\n\n    // SPI를 활성화하고 Master로 Clock은 fOSC/128로 설정합니다.\n    SPCR = (1 \u003c\u003c SPE) | (1 \u003c\u003c MSTR) | (1 \u003c\u003c SPR1) | (1 \u003c\u003c SPR0);\n}\n```\n\nATmega328P의 `MOSI`, `MISO` 및 클럭 라인은 `PINB3`, `PINB4`와 `PINB5`입니다. 핀 이름이 아닌 기능으로 보기 위해 `define` 문을 사용했습니다. 마스터로 동작하기 때문에 `CS`, `MOSI`, `SCK`를 출력(Output)으로 설정합니다. `MISO`는 기본값이 입력(Input)으로 설정되어 있습니다.\n\n```c\n    // CS와 MOSI, SCK를 출력으로 설정합니다\n    SPI_DDR |= (1 \u003c\u003c CS) | (1 \u003c\u003c MOSI) | (1 \u003c\u003c SCK);\n```\n\n다음으로 `SPCR`(SPI 제어 레지스터)에서 SPI를 활성화합니다. `SPE`에 `1`을 쓰면 됩니다. `MSTR`에 `1`을 기입하여 마스터로 작동하고 있음도 설정합니다. 마지막으로 클럭 속도를 설정해야 합니다. 기본값으로 fOSC/4로 설정됩니다. 그러나 몇몇 장치에서는 너무 높은 클럭일 수 있습니다. 인터페이스하는 장치의 최대 클럭 속도가 얼마인지 확실하지 않은 경우 클럭을 가능한 가장 느린 속도로 설정하는게 좋습니다. 그래서 이 예제에서는 fOSC/128의 클럭을 제공하도록 설정합니다. `SPR1`과 `SPR0`에 각각 `1`을 기입합니다.\n\n```c\n    // SPI를 활성화하고 Master로 Clock은 fOSC/128로 설정합니다.\n    SPCR = (1 \u003c\u003c SPE) | (1 \u003c\u003c MSTR) | (1 \u003c\u003c SPR1) | (1 \u003c\u003c SPR0);\n```\n\n# SPI 데이터 전송\n\nSPI 마스터에서 바이트를 전송하는 것은 매우 간단합니다. 아래와 같이 함수를 구현합니다.\n\n```c\nvoid spiTransmitByte(uint8_t data)\n{\n    // SPI로 전송할 데이터를 SPDR(SPI Data Register)에 저장\n    SPDR = data;\n\n    /*\n      SPIF(SPI Interrupt Flag)가 Set될 때까지 기다립니다\n      SPIF가 Set이 되었다면 SPI로 데이터가 전송이 완료된것입니다\n    */\n    while(!(SPSR \u0026 (1 \u003c\u003c SPIF)));\n}\n```\n\n먼저 SPI 데이터 레지스터 `SPDR`에 전송해야 하는 데이터를 저장합니다.\n\n```c\n    // SPI로 전송할 데이터를 SPDR(SPI Data Register)에 저장\n    SPDR = data;\n```\n\n그리고 `SPIF` 플래그가 Clear 되기를 기다리면서 SPI 상태 레지스터인 `SPSR`을 폴링 합니다.\n\n```c\n    /*\n      SPIF(SPI Interrupt Flag)가 Set될 때까지 기다립니다\n      SPIF가 Set이 되었다면 SPI로 데이터가 전송이 완료된것입니다\n    */\n    while(!(SPSR \u0026 (1 \u003c\u003c SPIF)));\n```\n\nSPI를 통해 장치로 전송할 때 데이터가 전송되기 전에 전송하려는 장치의 슬레이브 선택 라인이 LOW로 구동되어 한다는 점은 항상 명심해야 합니다.\n\n```c\n    // SS(Slave Select)를 LOW로 설정\n    SPI_DDR \u0026= ~(1 \u003c\u003c SS);\n\n    // 슬레이브로 데이터 전송\n    spiTransmitByte(0x55);\n\n    // SS(Slave Select)를 HIGH로 설정\n    SPI_DDR |= (1 \u003c\u003c SS);\n```\n\n# SPI 데이터 수신\n\nSPI를 통해 데이터를 수신하는 것은 데이터 전송과 비슷합니다.\n\n```c\nuint8_t spiReceive()\n{\n    /*\n      SPI에서 데이터를 전송하면 항상 0xFF를 전송하고 SPI 데이터 레지스터를\n      반환합니다. 슬레이브가 데이터를 다시 전송하기 위해 클럭을 생성하기\n      때문에 0xFF를 전송하는데, 이것을 사용하여 SPDR에 0xFF를 Dummy Byte로\n      전송하면 SPI 수신을 받을 수 있습니다\n    */\n    SPDR = 0xFF;\n\n    /*\n      SPIF(SPI Interrupt Flag)가 Set될 때까지 기다립니다\n      SPIF가 Set이 되었다면 SPI로 데이터가 전송이 완료된것입니다\n    */\n    while(!(SPSR \u0026 (1 \u003c\u003c SPIF)));\n\n    // SPI로 수신한 데이터(SPDR)을 반환합니다\n    return SPDR;\n}\n```\n\nSPI에서 데이터를 전송하면 항상 `0xFF`를 전송하고 SPI 데이터 레지스터를 반환합니다. 슬레이브가 데이터를 다시 전송하기 위해 클럭을 생성하기 때문에 `0xFF`를 전송하는데, 이것을 사용하여 `SPDR`에 `0xFF`를 Dummy Byte로 전송하면 SPI 수신을 받을 수 있습니다.\n\n만약, 항상 입력 바이트를 사용하여 전송하고 항상 SPI 데이터 레지스터를 반환하도록 함수를 작성하고 싶다면, 아래와 같이 작성할 수 있습니다.\n\n```c\nuint8_t spiTxRx(uint8_t data)\n{\n    // SPI로 전송할 데이터를 SPDR(SPI Data Register)에 저장\n    SPDR = data;\n\n    /*\n      SPIF(SPI Interrupt Flag)가 Set될 때까지 기다립니다\n      SPIF가 Set이 되었다면 SPI로 데이터가 전송이 완료된것입니다\n    */\n    while(!(SPSR \u0026 (1 \u003c\u003c SPIF)));\n\n    // SPI로 수신한 데이터(SPDR)을 반환합니다\n    return SPDR;\n}\n```\n\n위의 코드를 사용하면 송신 수신 시퀀스는 아래와 같습니다:\n\n```c\n    // SS(Slave Select)를 LOW로 설정\n    SPI_DDR \u0026= ~(1 \u003c\u003c SS);\n\n    // 데이터를 슬레이브로 전송합니다 (응답은 무시)\n    spiTransmitByte(0x55);\n\n    // 슬레이브로 부터 데이터를 수신합니다\n    uint8_t ret = spiTxRx(0xFF);\n\n    // SS(Slave Select)를 HIGH로 설정\n    SPI_DDR |= (1 \u003c\u003c SS);\n```\n"},"__N_SSG":true},"page":"/article/[category]/[year]/[month]/[day]/[slug]","query":{"category":"avr","year":"2022","month":"08","day":"28","slug":"AVR-ATmega328P-SPI"},"buildId":"FrFmlSEPIvXzRhY1fSPxA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>