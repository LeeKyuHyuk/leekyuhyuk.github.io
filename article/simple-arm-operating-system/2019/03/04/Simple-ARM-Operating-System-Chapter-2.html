<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta property="og:image" content="https://kyuhyuk.kr/thumbnail.png"/><title>Chapter 2: ARM Assembly 기초</title><meta name="author" content="KyuHyuk Lee"/><meta name="generator" content="KyuHyuk Lee"/><meta name="description" content=" 작업에 들어가기 전에 ARM Assembly에 대해 배워보도록 합시다. ARM CPU의 기본 구성 R0 ~ R14 총 15개의 범용 레지스터를 가지고 있습니다. 범용 레지스터 R13 는 특수 레지스터 SP 로 사용됩니다. SP 는 C언어 사용시 스택의 주소를 저장하는 레지스터입니다. "/><meta itemProp="url" content="https://kyuhyuk.kr/article/simple-arm-operating-system/2019/03/04/Simple-ARM-Operating-System-Chapter-2"/><meta itemProp="headline" content="Chapter 2: ARM Assembly 기초"/><meta property="og:type" content="article"/><meta property="og:url" content="https://kyuhyuk.kr/article/simple-arm-operating-system/2019/03/04/Simple-ARM-Operating-System-Chapter-2"/><meta property="og:title" content="Chapter 2: ARM Assembly 기초"/><meta property="og:description" content=" 작업에 들어가기 전에 ARM Assembly에 대해 배워보도록 합시다. ARM CPU의 기본 구성 R0 ~ R14 총 15개의 범용 레지스터를 가지고 있습니다. 범용 레지스터 R13 는 특수 레지스터 SP 로 사용됩니다. SP 는 C언어 사용시 스택의 주소를 저장하는 레지스터입니다. "/><meta property="og:site_name" content="KyuHyuk Blog"/><meta property="og:locale" content="ko_KR"/><meta name="next-head-count" content="15"/><style id="stitches">--sxs{--sxs:2 c-opBYf c-bHyrwK c-uBnvQ c-hehuMV c-bjkCdF c-hAoZGi c-jfcKOQ c-ezyKJG c-iAzQif c-bvdusc c-ezRQNp c-iosjjB c-jYwCTI c-iOPkYY c-cpkrrK c-fiqONv c-iUFgVP c-cshSRb c-fxvkZv c-dIcdES}@media{.c-opBYf{display:flex;align-items:center;background:#FFFFFF;height:60px;justify-content:space-between;-webkit-box-align:center;-webkit-box-pack:justify}.c-bHyrwK{display:flex;align-items:center;justify-content:center;-webkit-box-align:center;-webkit-box-pack:center}.c-uBnvQ{width:32px;height:32px;color:#FFFFFF;background:#000000;border-radius:4px;display:flex;align-items:center;justify-content:center;margin-right:12px;font-weight:700;cursor:default;-webkit-box-align:center;-webkit-box-pack:center}.c-hehuMV{font-weight:900;font-size:18px;letter-spacing:0.5px;color:#000000;cursor:default}.c-bjkCdF{list-style:none;padding:0;margin:0;display:flex;justify-content:center;align-items:center;font-size:24px;color:rgb(134, 142, 150);transition:all 0.3s ease 0s;-webkit-box-pack:center;-webkit-box-align:center}.c-hAoZGi{font-size:28px;color:inherit;text-decoration:none;margin:8px}.c-jfcKOQ{max-width:768px;margin-top:2rem;margin-left:auto;margin-right:auto}.c-ezyKJG{min-width:72px;display:flex;flex-direction:row;justify-content:center;align-items:center;padding:6px 16px;background:#12B886;box-shadow:0px 1px 2px rgba(98, 16, 204, 0.3);border:none;border-radius:14px;vertical-align:middle;color:#FFFFFF;font-size:1rem;height:2rem;float:right}.c-iAzQif{display:inline-block;margin-top:2rem}.c-bvdusc{font-size:2rem;line-height:1.5;letter-spacing:-0.004em;margin-top:0;margin-bottom:2rem;font-weight:700;color:#212529;word-break:keep-all;transition:color 0.125s ease-in 0s;}.c-ezRQNp{font-size:1.125rem;color:#212529;transition:color 0.125s ease-in 0s;;line-height:1.7;letter-spacing:-0.004em;word-break:break-all;overflow-wrap:break-word}.c-iosjjB{background:#F8F9FA;padding:0 1rem;height:2rem;border-radius:1rem;display:inline-flex;align-items:center;margin-right:0.875rem;color:#12B886;text-decoration:none;font-weight:400;font-size:1rem}.c-jYwCTI{font-size:1rem;color:#495057}.c-iOPkYY{margin-top:3rem;background-color:rgba(51,51,51,.1);border:0;height:1px}.c-cpkrrK{width:100%;height:300px;display:flex;align-items:center;justify-content:center;flex-direction:column;-webkit-box-align:center;-webkit-box-pack:center}.c-fiqONv{color:rgb(206, 212, 218);margin-bottom:8px;font-size:22px;font-weight:700}.c-iUFgVP{width:32px;height:32px;color:#FFFFFF;background:rgb(206, 212, 218);border-radius:4px;display:flex;align-items:center;justify-content:center;margin-right:12px;font-weight:700;cursor:default;-webkit-box-align:center;-webkit-box-pack:center}.c-cshSRb{font-weight:900;font-size:18px;letter-spacing:0.5px;color:rgb(206, 212, 218);cursor:default;text-transform:uppercase}.c-fxvkZv{font-size:2.5rem;line-height:1.5;letter-spacing:-0.004em;margin-top:0;margin-bottom:2rem;font-weight:700;color:#212529;word-break:keep-all;transition:color 0.125s ease-in 0s;}.c-dIcdES{margin-top:2rem;font-size:1.125rem;color:#212529;transition:color 0.125s ease-in 0s;;line-height:1.7;letter-spacing:-0.004em;word-break:keep-all;overflow-wrap:break-word}}</style><link rel="preload" href="/_next/static/css/98b299b94b0a7962.css" as="style"/><link rel="stylesheet" href="/_next/static/css/98b299b94b0a7962.css" data-n-g=""/><link rel="preload" href="/_next/static/css/c2a527101433f11d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c2a527101433f11d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-c354a30bda3d62a6.js" defer=""></script><script src="/_next/static/chunks/pages/_app-8265bb1a072646d3.js" defer=""></script><script src="/_next/static/chunks/776-f277552409ab147f.js" defer=""></script><script src="/_next/static/chunks/305-e325b960616dc0fd.js" defer=""></script><script src="/_next/static/chunks/pages/article/%5Bcategory%5D/%5Byear%5D/%5Bmonth%5D/%5Bday%5D/%5Bslug%5D-aa033f8eb8939164.js" defer=""></script><script src="/_next/static/46Dhy2L_ENuWomFHDRk1g/_buildManifest.js" defer=""></script><script src="/_next/static/46Dhy2L_ENuWomFHDRk1g/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="c-opBYf"><a href="https://kyuhyuk.kr"><div class="c-bHyrwK"><div class="c-uBnvQ">Kh.</div><div class="c-hehuMV">KyuHyuk Blog</div></div></a><ul class="c-bjkCdF"><li><a href="https://github.com/LeeKyuHyuk" class="c-hAoZGi"><span role="img" aria-label="github" class="anticon anticon-github"><svg viewBox="64 64 896 896" focusable="false" data-icon="github" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0138.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"></path></svg></span></a></li><li><a href="https://linkedin.com/in/leekyuhyuk" class="c-hAoZGi"><span role="img" aria-label="linkedin" class="anticon anticon-linkedin"><svg viewBox="64 64 896 896" focusable="false" data-icon="linkedin" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zM349.3 793.7H230.6V411.9h118.7v381.8zm-59.3-434a68.8 68.8 0 1168.8-68.8c-.1 38-30.9 68.8-68.8 68.8zm503.7 434H675.1V608c0-44.3-.8-101.2-61.7-101.2-61.7 0-71.2 48.2-71.2 98v188.9H423.7V411.9h113.8v52.2h1.6c15.8-30 54.5-61.7 112.3-61.7 120.2 0 142.3 79.1 142.3 181.9v209.4z"></path></svg></span></a></li><li><a href="mailto:lee@kyuhyuk.kr" class="c-hAoZGi"><span role="img" aria-label="mail" class="anticon anticon-mail"><svg viewBox="64 64 896 896" focusable="false" data-icon="mail" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-80.8 108.9L531.7 514.4c-7.8 6.1-18.7 6.1-26.5 0L189.6 268.9A7.2 7.2 0 01194 256h648.8a7.2 7.2 0 014.4 12.9z"></path></svg></span></a></li></ul></header><main class="c-jfcKOQ"><article><h1 class="c-fxvkZv"><a href="https://kyuhyuk.kr/article/simple-arm-operating-system/2019/03/04/Simple-ARM-Operating-System-Chapter-2">Chapter 2: ARM Assembly 기초</a></h1><a href="https://kyuhyuk.kr/category/Simple-ARM-Operating-System" class="c-iosjjB">Simple ARM Operating System</a><time dateTime="2019-03-04 23:07:02" class="c-jYwCTI">Mar 04, 2019 11:07:02 PM</time><div id="post" class="c-dIcdES"><p>작업에 들어가기 전에 ARM Assembly에 대해 배워보도록 합시다.</p>
<ul>
<li>ARM CPU의 기본 구성
<ul>
<li><code>R0</code>~<code>R14</code> 총 15개의 범용 레지스터를 가지고 있습니다.</li>
<li>범용 레지스터 <code>R13</code>는 특수 레지스터 <code>SP</code>로 사용됩니다.
<ul>
<li><code>SP</code>는 C언어 사용시 스택의 주소를 저장하는 레지스터입니다.</li>
</ul>
</li>
<li>범용 레지스터 <code>R14</code>는 특수 레지스터 <code>LR</code>로 사용됩니다.
<ul>
<li><code>LR</code>은 함수 호출 시 되돌아갈 함수의 주소가 저장되는 레지스터입니다.</li>
</ul>
</li>
<li>범용 레지스터 <code>R15</code>는 특수 레지스터 <code>PC</code>로 사용됩니다.
<ul>
<li><code>PC</code>는 다음 실행할 프로그램의 주소를 가지고 있는 레지스터입니다.</li>
</ul>
</li>
<li><code>CPSR</code>이라는 상태 레지스터를 가지고 있습니다.<br>
<img src="/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-2/2019-03-04-Simple-ARM-Operating-System-Chapter-2_1.jpg" alt="Operand"></li>
<li><code>Rs</code>, <code>Rd</code>는 반드시 레지스터(<code>R0</code>~<code>R15</code>)이어야 합니다.
<ul>
<li><code>OP1</code>은 항상 레지스터 입니다.</li>
</ul>
</li>
<li><strong><code>OP2</code>는 레지스터 일수도 있고, 레지스터가 아닐수도 있습니다.</strong></li>
<li><a href="#ldr-str-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95"><code>Rs</code>, <code>Rd</code>, <code>OP2</code>의 대상으로 직접 외부 메모리를 접근할수 없습니다.</a></li>
</ul>
</li>
</ul>
<hr>
<h3>Load, Store</h3>
<h4><code>MOV</code> 명령</h4>
<ul>
<li>ARM에서 레지스터의 데이터 이동은 <code>MOV</code> 명령을 사용합니다.
<ul>
<li>예) <code>MOV R0, R1</code> : <code>R1</code>의 내용을 <code>R0</code>으로 복사</li>
<li>예) <code>MOV R0, #1</code> : 상수 <code>1</code>을 <code>R0</code>으로 복사</li>
</ul>
</li>
<li>메모리→레지스터 : <code>LDR</code> (Load to Register)</li>
<li>레지스터→메모리 : <code>STR</code> (Store to Memory)</li>
</ul>
<h4>상수 값을 레지스터에 저장</h4>
<ul>
<li><code>LDR</code> 명령 사용 방법
<ul>
<li><code>LDR Rn, =Value</code></li>
<li><strong><code>LDR</code>을 사용하여 상수의 값을 레지스터에 저장할때 <code>=Value</code>에서 <code>=</code>를 빼먹지 않게 주의합니다.</strong>
<ul>
<li>다른 명령어에서는 상수 입력에 <code>#</code>이 들어가지만 <code>LDR</code>만 <code>=</code>이 들어가니 주의합시다.</li>
</ul>
</li>
<li>레지스터간 데이터 복사는 <code>MOV</code>를 사용합니다.</li>
<li><code>Rn</code> : <code>R0</code> ~ <code>R15</code> (대소문자 구분 없음)</li>
<li><code>=Value</code> : 상수 값 (최대 4바이트)
<ul>
<li>10진수 :
<ul>
<li><strong>예)</strong> <code>41</code>, <code>-27</code></li>
</ul>
</li>
<li>16진수 :
<ul>
<li><strong>예)</strong> <code>0x1234</code>, <code>-0x1EF</code></li>
</ul>
</li>
<li>예) <code>LDR R0, =100</code>, <code>LDR R13, =0x1234</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4>상수 표현</h4>
<ul>
<li><code>OP2</code>의 상수는 8비트의 값고 짝수 비트 ROR(Rotate Right)로 표현되어야 합니다.
<ul>
<li>32비트 명령 안에서 상수 값을 함께 저장하다보니 범위 제한이 발생하기 때문입니다.</li>
<li><code>0</code>~<code>255</code> 범위의 상수는 무조건 사용이 가능합니다.</li>
</ul>
</li>
</ul>
<h4>사용된 상수가 <code>MOV</code> 명령에서 사용 가능한지 불가능한지 판단해보자</h4>
<ul>
<li>
<p><code>MOV R0, #0x7F00</code> : <strong>가능</strong> <img src="/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-2/2019-03-04-Simple-ARM-Operating-System-Chapter-2_2.png" alt="Example1"></p>
</li>
<li>
<p><code>MOV R0, #0x30C0</code> : <strong>가능</strong> <img src="/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-2/2019-03-04-Simple-ARM-Operating-System-Chapter-2_3.png" alt="Example2"></p>
</li>
<li>
<p><code>MOV R3, #0x14E</code> : <strong>불가능</strong> <img src="/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-2/2019-03-04-Simple-ARM-Operating-System-Chapter-2_4.png" alt="Example3"></p>
</li>
<li>
<p><code>LDR</code>을 사용하면, <strong>범위 제한 없는 32비트 값으로 표현 가능</strong></p>
<ul>
<li>실제 상수 값은 메모리에 존재하며 레지스터 참조로 변환됩니다.</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>MOV</code>보다 <code>LDR</code>이 느리지만, <code>LDR</code>은 32비트 데이터를 사용할 수 있습니다.</p>
</blockquote>
<h4>레지스터 간접참조 <code>LDR</code>, <code>STR</code></h4>
<ul>
<li>레지스터 간접 참조 :
<ul>
<li><code>LDR Rd, [Rs]</code>
<ul>
<li><code>Rs</code> 레지스터 값을 메모리 주소로 하여 <code>Rd</code>에 저장</li>
<li><code>Rs</code>, <code>Rd</code> : <code>R0</code> ~ <code>R15</code></li>
</ul>
</li>
<li><code>STR Rs, [Rd]</code>
<ul>
<li><code>Rd</code> 레지스터 값을 메모리 주소로 하여 <code>Rs</code>를 저장</li>
<li><code>Rs</code>, <code>Rd</code> : <code>R0</code> ~ <code>R15</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5>예)</h5>
<pre><code class="language-assembly">  LDR R0, =0x1000   @ R0에 상수 0x1000 저장
  LDR R1, =80       @ R1에 상수 80 저장
  STR R1, [R0]      @ R0의 값인 0x1000를 메모리 주소로 참조하여
                    @ 0x1000에 상수 80을 저장
</code></pre>
<h4><code>LDR</code>, <code>STR</code> 쉽게 이해하는 방법</h4>
<p><img src="/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-2/2019-03-04-Simple-ARM-Operating-System-Chapter-2_5.png" alt="LDR STR Tip!"></p>
<h3>Label</h3>
<pre><code class="language-assembly">START:  MOV R0, #10       @ R0 레지스터에 상수 10을 저장
        STR R0, [R1]      @ R1에 저장되어 있는 주소에 R0 값을 저장
        LDR PC, =START    @ START의 주소를 PC(Program counter)에 저장
</code></pre>
<ul>
<li>Label은 모두 주소 값(해당 Label 위치의 주소)입니다.</li>
<li>위의 코드는 <code>START</code>의 주소 값을 PC(Program counter)에 저장하여 무한 루프를 하게 됩니다.</li>
</ul>
<h3><code>LDR</code>, <code>STR</code> Post Indexing</h3>
<h4>Post Indexing 사용 방법:</h4>
<pre><code class="language-assembly">  LDR R0, [R1], #4            @ R1 주소에 있는 값을 R0에 넣고, R1에 4를 더합니다.
  STR R0, [R2], #-4           @ R0의 값을 R2의 주소에 넣고, R2에 4를 뺍니다.
</code></pre>
<pre><code class="language-assembly">  LDR R0, [R1], R3            @ R1 주소에 있는 값을 R0에 넣고, R1에 R3의 값을 더합니다.
  STR R0, [R2], -R3           @ R0의 값을 R2의 주소에 넣고, R2에 R3의 값을 뺍니다.
</code></pre>
<pre><code class="language-assembly">  LDR R0, [R1], R3, LSL #2    @ R1 주소에 있는 값을 R0에 넣고,
                              @ R1에 R3, LSL #2한 값을 더합니다.
  STR R0, [R2], -R3, ASR #2   @ R2 주소에 있는 값을 R0에 넣고,
                              @ R2에 R3, ASR #2한 값을 뺍니다.
</code></pre>
<h5>예)</h5>
<pre><code class="language-assembly">  LDR R1, 0x1000              @ R1에 상수 0x1000을 넣습니다.
                              @ R1 : 0x1000

  LDR R0, [R1], #4            @ R0에 0x1000를 참조한 값(R1의 메모리 참조주소)을 넣고,
                              @ R1에 4를 더합니다.
                              @ R1 : 0x1004

  LDR R2, [R1], #4            @ R2에 0x1004를 참조한 값(R1의 메모리 참조주소)을 넣고,
                              @ R1에 4를 더합니다.
                              @ R1 : 0x1008
</code></pre>
<h3><code>LDR</code>, <code>STR</code> Pre Indexing</h3>
<h4>Pre Indexing 사용 방법:</h4>
<pre><code class="language-assembly">  LDR R0, [R1], #4            @ R1에 4를 더한것을 참조하여 R0에 넣습니다.
  STR R0, [R2], #-4           @ R0의 값을 R2에 4를 뺀 주소에 넣습니다.
</code></pre>
<pre><code class="language-assembly">  LDR R0, [R1], R3            @ R1에 R3의 값을 더한것을 참조하여 R0에 넣습니다.
  STR R0, [R2], -R3           @ R0의 값을 R2에 R3의 값을 뺀 주소에 넣습니다.
</code></pre>
<pre><code class="language-assembly">  LDR R0, [R1], R3, LSL #2    @ R1에 R3, LSL #2한 값을 더한뒤,
                              @ 주소에 있는 값을 R0에 넣습니다.
  STR R0, [R2], -R3, ASR #2   @ R2에 R3, ASR #2한 값을 뺀뒤,
                              @ R0의 값을 변경된 주소로 넣습니다.
</code></pre>
<h5>예)</h5>
<pre><code class="language-assembly">  LDR R1, 0x1000              @ R1에 상수 0x1000을 넣습니다.
                              @ R1 : 0x1000

  LDR R0, [R1, #4]            @ R1에 4를 더한 주소의 참조한 값(0x1004)을 R0에 넣습니다.
                              @ R1 : 0x1000

  LDR R2, [R1, #4]            @ R1에 4를 더한 주소의 참조한 값(0x1004)을 R2에 넣습니다.
                              @ R1 : 0x1000
</code></pre>
<blockquote>
<p>Pre Indexing에서는 <strong>값이 업데이트 되지 않습니다!</strong> 만약 값을 업데이트하고 싶다면 아래의 <code>!</code>(Auto Update) 옵션을 사용해야합니다.</p>
</blockquote>
<h4>'<code>!</code>(Auto Update) suffix' 사용 예시)</h4>
<pre><code class="language-assembly">  LDR R1, 0x1000              @ R1에 상수 0x1000을 넣습니다.
                              @ R1 : 0x1000

  LDR R0, [R1, #4]!           @ R1에 4를 더한 주소의 참조한 값(0x1004)을 R0에 넣습니다.
                              @ ! suffix가 있으므로, 자동으로 값이 업데이트 됩니다.
                              @ R1 : 0x1004

  LDR R2, [R1, #4]            @ R1에 4를 더한 주소의 참조한 값(0x1008)을 R2에 넣습니다.
                              @ ! suffix가 없으므로, 자동으로 값이 업데이트 되지 않습니다.
                              @ R1 : 0x1004
</code></pre>
<h4><code>LSL</code>, <code>LSR</code> Shift</h4>
<ul>
<li><code>LSL #n</code> : 최후에 밀려난 비트가 <code>CPSR</code>(상태레지스터)의 C(Carry) flag에 저장
<ul>
<li>Logical Shift Left</li>
<li><code>LSL</code> : <code>signed/unsigned</code> 곱하기 2</li>
</ul>
</li>
<li><code>LSR #n</code> : 최후에 밀려난 비트가 <code>CPSR</code>(상태레지스터)의 C(Carry) flag에 저장
<ul>
<li>Logical Shift Right</li>
<li><code>LSR</code> : <code>unsigned</code> 나누기 2</li>
</ul>
</li>
</ul>
<h4><code>ASR</code> Shift</h4>
<ul>
<li><code>ASR #n</code> : MSB(부호)를 유지하고, 밀려난 비트가 <code>CPSR</code>(상태레지스터)의 C(Carry) flag에 저장
<ul>
<li>레지스터를 우측으로 지정한 비트 수 만큼 <strong>부호를 유지하며</strong> Shift합니다.</li>
<li><code>ASR</code>은 <code>signed int</code>의 나누기 2 동작을 수행합니다.</li>
</ul>
</li>
</ul>
<hr>
<h3>비트제어 명령어</h3>
<ul>
<li>
<p><code>ORR</code> : 원하는 비트만 1로 설정합니다.</p>
<ul>
<li>예) <code>ORR R0, R0, #0x1F</code> , <code>ORR R0, R1, R2, LSL #2</code></li>
</ul>
</li>
<li>
<p><code>EOR</code> : 원하는 비트만 반전 시킵니다.</p>
<ul>
<li>예) <code>EOR R0, R0, #0x1F</code> , <code>EOR R0, R1, R2, LSL #2</code></li>
</ul>
</li>
<li>
<p><code>AND</code> : 원하는 비트만 0으로 설정합니다.</p>
<ul>
<li><strong>0인 비트에 0으로 설정합니다.</strong></li>
<li>예) <code>AND R0, R0, #0x1F</code> , <code>AND R0, R1, R2, LSL #2</code></li>
</ul>
</li>
<li>
<p><code>BIC</code> : 원하는 비트만 0으로 설정합니다.</p>
<ul>
<li><strong>1인 비트에 0으로 설정합니다.</strong></li>
<li><code>AND</code>보다 편리한 장점이 있습니다.</li>
<li>예) <code>BIC R0, R0, #0x1F</code> , <code>BIC R0, R1, R2, LSL #2</code></li>
</ul>
</li>
</ul>
<h4>다양한 비트연산</h4>
<ul>
<li><strong>[문제]</strong> <code>0x1000</code>의 4~7번 비트를 <code>1010</code>으로 변경하는 어셈블리 코드를 작성하세요.</li>
</ul>
<p><img src="/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-2/2019-03-04-Simple-ARM-Operating-System-Chapter-2_6.png" alt="Example4"></p>
<pre><code class="language-assembly">  LDR R0, =0x1000           @ R0에 상수 0x1000을 넣습니다.
  LDR R1, [R0]              @ R1에 R0을 참조한 값을 넣습니다.
  BIC R1, R1, 0xF &lt;&lt; 4      @ '1111'을 4번 Left Shift하면 '11110000'가 됩니다.
                            @ BIC로 R1의 4~7 비트를 0으로 설정합니다.
  ORR R1, R1, 0xA &lt;&lt; 4      @ '1010'을 4번 Left Shift하면 '10100000'가 됩니다.
                            @ ORR로 R1의 5, 7번 비트를 1로 설정합니다.
  STR R1, [R0]              @ R1의 데이터를 R0에 저장되어있는 메모리주소에 저장합니다.
</code></pre>
<hr>
<h3>분기 명령어</h3>
<ul>
<li><code>B</code> 명령 사용 예시:
<ol>
<li><code>B add</code> : Global Label</li>
<li><code>B 1f</code> : Local Label</li>
<li><code>B . </code> : 무한 루프 (<code>.</code>은 제자리를 말합니다.)</li>
</ol>
</li>
<li><code>B R0</code>와 같이 <code>B</code> 명령은 분기 주소로 레지스터를 쓸수 없습니다.</li>
</ul>
<hr>
<h3>비교 연산 명령어</h3>
<ul>
<li><code>CMP</code> : <code>CMP Rs, OP2</code>
<ul>
<li><code>Rn - OP2</code> 연산을 하여 <code>CPSR</code>(상태레지스터)의 Flag만 변경합니다.</li>
</ul>
</li>
<li><code>CMN</code> : <code>CMN Rs, OP2</code>
<ul>
<li><code>Rn + OP2</code> 연산을 하여 <code>CPSR</code>(상태레지스터)의 Flag만 변경합니다.</li>
<li>컴파일러단에서 주로 사용되니, 되도록이면 <code>CMP</code>를 사용하자.</li>
</ul>
</li>
<li><code>TST</code> : <code>TST Rs, OP2</code>
<ul>
<li><code>Rn &amp; OP2</code> 연산을 하여 <code>CPSR</code>(상태레지스터)의 Flag만 변경합니다.</li>
<li><strong>특정비트를 확인하기 위해 사용됩니다.</strong></li>
<li>비교 비트가 <strong>1이면, Z clear, 0이면 Z set</strong></li>
</ul>
</li>
<li><code>TEQ</code> : <code>TEQ Rs, OP2</code>
<ul>
<li><code>Rn ^ OP2</code> 연산을 하여 <code>CPSR</code>(상태레지스터)의 Flag만 변경합니다.</li>
<li><strong>두 데이터의 비트가 완전 똑같은지 확인하기 위해 사용됩니다</strong></li>
<li>비트 패턴이 <strong>동일하면, Zero set</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>비교연산은 레지스터에 변화가 없으며, Flag만 변합니다.</p>
</blockquote>
<ul>
<li>
<p><strong>[문제]</strong> <code>R0</code>의 7번 비트가 <code>1</code>이면 <code>R1</code> 레지스터에 2를 기록하고, <code>0</code>이면 <code>R1</code> 레지스터에 3을 기록하는 프로그램을 작성하시오.</p>
</li>
<li>
<p><code>AND</code>를 사용하여 해결:</p>
</li>
</ul>
<pre><code class="language-assembly">  AND R0, R0, #1 &lt;&lt; 7
  CMP R0, #0
  MOVEQ R1, #3
  MOVNE R1, #2
</code></pre>
<ul>
<li><code>TST</code>를 사용하여 해결:</li>
</ul>
<pre><code class="language-assembly">  TST R0, #1 &lt;&lt; 7
  MOVEQ R1, #3
  MOVNE R1, #2
</code></pre>
<hr>
<h3><code>CPSR</code>(상태레지스터)과 Flag</h3>
<p><img src="/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-2/2019-03-04-Simple-ARM-Operating-System-Chapter-2_7.jpg" alt="CPSR : https://www.wikinote.org/Main/Savitribai-Phule-Pune-University/ENTC/AP-TE/Unit-1/Registers-CPSR-SPSR"></p>
<p>비교 연산을 할때는 NZCV만 사용한다</p>
<ul>
<li>N (Negative) : 연산결과가 음수인 경우</li>
<li>Z (Zero) : 연산결과가 0인 경우</li>
<li>C (Carry) : 덧셈 Carry에 Set, 뺄셈 Borrow에 Clear, Rotate시 밀린 비트 저장</li>
<li>V (oVerflow) : <code>signed</code> 덧셈, 뺄셈 연산 결과로 값의 초과가 발생한 경우</li>
</ul>
<blockquote>
<p>Carry는 덧셈을 했을때 범위를 초과해서 자리 올림이 발생했을때를 말하는것입니다. Overflow와는 다릅니다.</p>
</blockquote>
<hr>
<h3>상태 플래그와 조건</h3>
<pre><code class="language-assembly">  CMP R0, R1
  B□□ LOOP
</code></pre>
<p>□ 부분에 아래의 16가지 조건식이 들어가게 됩니다.</p>
<table>
<thead>
<tr>
<th>약어</th>
<th>뜻</th>
<th>Flag 상태</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>EQ</code></strong></td>
<td><strong>Eq</strong>ual / Equals zero (False)</td>
<td>Z set</td>
</tr>
<tr>
<td><strong><code>NE</code></strong></td>
<td><strong>N</strong>ot <strong>E</strong>qual (True)</td>
<td>Z clear</td>
</tr>
<tr>
<td><strong><code>CS</code></strong>/<code>HS</code></td>
<td>Carry Set / Unsigned higher or same</td>
<td><strong>C set</strong></td>
</tr>
<tr>
<td><strong><code>CC</code></strong>/<code>LO</code></td>
<td>Carry Clear / Unsigned Lower</td>
<td><strong>C clear</strong></td>
</tr>
<tr>
<td><strong><code>MI</code></strong></td>
<td><strong>Mi</strong>nus / Negative</td>
<td>N set</td>
</tr>
<tr>
<td><strong><code>PL</code></strong></td>
<td><strong>Pl</strong>us / Positive or zero</td>
<td>N clear</td>
</tr>
<tr>
<td><strong><code>VS</code></strong></td>
<td>Overflow</td>
<td><strong>V s</strong>et</td>
</tr>
<tr>
<td><strong><code>VC</code></strong></td>
<td>No Overflow</td>
<td><strong>V c</strong>lear</td>
</tr>
<tr>
<td><strong><code>HI</code></strong></td>
<td><code>Unsigned</code> <strong>hi</strong>gher</td>
<td>C set and Z clear</td>
</tr>
<tr>
<td><strong><code>LS</code></strong></td>
<td><code>Unsigned</code> <strong>l</strong>ower or <strong>s</strong>ame</td>
<td>C clear and Z set</td>
</tr>
<tr>
<td><strong><code>GE</code></strong></td>
<td><code>Signed</code> <strong>g</strong>reater then or <strong>e</strong>qual</td>
<td>N equals V</td>
</tr>
<tr>
<td><strong><code>LT</code></strong></td>
<td><code>Signed</code> <strong>l</strong>ess <strong>t</strong>han</td>
<td>N is not equals V</td>
</tr>
<tr>
<td><strong><code>GT</code></strong></td>
<td><code>Signed</code> <strong>g</strong>reater <strong>t</strong>han</td>
<td>Z clear and N equals V</td>
</tr>
<tr>
<td><strong><code>LE</code></strong></td>
<td><code>Signed</code> <strong>l</strong>ess than or <strong>e</strong>qual</td>
<td>Z set or N is not equal to V</td>
</tr>
<tr>
<td><strong><code>AL</code></strong></td>
<td><strong>Al</strong>ways</td>
<td>Any state</td>
</tr>
<tr>
<td><strong><code>NV</code></strong></td>
<td><strong>N</strong>e<strong>v</strong>er</td>
<td>None</td>
</tr>
</tbody>
</table>
<ul>
<li>주소 연산을 할때는 <code>HI</code>, <code>LO</code>, <code>HS</code>, <code>LS</code>와 같은 <code>Unsigned</code> 비교를 사용합니다.</li>
</ul>
<hr>
<h3>산술 명령어</h3>
<ul>
<li>
<p><strong>ADD</strong> : <code>ADD Rd, Rs, OP2</code></p>
<ul>
<li><code>Rd := Rs + OP2</code></li>
</ul>
</li>
<li>
<p><strong>ADC</strong> : <code>ADC Rd, Rs, OP2</code></p>
<ul>
<li><code>Rd := Rs + OP2 + Carry</code></li>
</ul>
</li>
<li>
<p><strong>SUB</strong> : <code>SUB Rd, Rs, OP2</code></p>
<ul>
<li><code>Rd := Rs - OP2</code></li>
</ul>
</li>
<li>
<p><strong>SBC</strong> : <code>SBC Rd, Rs, OP2</code></p>
<ul>
<li><code>Rd := Rs - OP2 - !Carry</code></li>
</ul>
</li>
<li>
<p><strong>RSB</strong> : <code>RSB Rd, Rs, OP2</code></p>
<ul>
<li><code>Rd := OP2 - Rs</code></li>
</ul>
</li>
<li>
<p><strong>RSC</strong> : <code>RSC Rd, Rs, OP2</code></p>
<ul>
<li><code>Rd := OP2 - Rs - !Carry</code></li>
</ul>
</li>
<li>
<p><code>RSB</code>, <code>RSC</code>에 있는 R은 Reverse라고 생각합시다.</p>
</li>
</ul>
<h4>일정 횟수를 반복하는 프로그램</h4>
<ol>
<li><code>for(i=0; i&lt;10; i++)</code> 방식</li>
</ol>
<pre><code class="language-assembly">  MOV R0, #0
1:
  @ 이곳에 코드 작성

  ADD R0, R0, #1
  CMP R0, #10
  BLT 1b
</code></pre>
<ol start="2">
<li><code>for(i=10; i&gt;0; i--)</code> 방식</li>
</ol>
<pre><code class="language-assembly">  MOV R0, #10
1:
  @ 이곳에 코드 작성

  SUB R0, R0, #1
  CMP R0, #0
  BGT 1b
</code></pre>
<p>위의 두 방법도 좋지만, Down Count 방식에 S-Suffix를 사용하는게 더 효율적입니다.</p>
<pre><code class="language-assembly">  MOV R0, #10
1:
  @ 이곳에 코드 작성

  SUBS R0, R0, #1
  BGT 1b
</code></pre>
<hr>
<h3>서브루틴 호출</h3>
<ul>
<li><code>BL label</code> : Branch and Link
<ul>
<li><code>BL</code> : 서브루틴 호출 명령</li>
<li><code>label</code> : 서브루틴의 상대주소 값</li>
<li><code>B</code>와 달리 복귀한 주소(따음 명령 주소) 값을 <code>R14</code>에 저장합니다.<br>
<img src="/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-2/2019-03-04-Simple-ARM-Operating-System-Chapter-2_8.png" alt="Subroutine"></li>
<li><code>BL</code>은 분기 주소로 레지스터를 사용하지 못합니다.</li>
</ul>
</li>
</ul>
<h4>서브루틴 호출과 복귀</h4>
<ul>
<li>
<p><strong>서브루틴 호출</strong> (<code>BL label</code>):</p>
<ol>
<li>복귀할 주소를 <code>LR</code>(<code>R14</code>)에 저장합니다.</li>
<li>서브루틴의 주소를 <code>PC</code>(<code>R15</code>)에 저장합니다.</li>
</ol>
</li>
<li>
<p><strong>서브루틴 복귀</strong> (<code>BX LR</code>):</p>
<ul>
<li><code>LR</code>(<code>R14</code>)의 값을 <code>PC</code>(<code>R15</code>)에 저장하여 복귀합니다.</li>
</ul>
</li>
<li>
<p>왜 함수라고 하지 않고 서브루틴이라고 부를까?</p>
<ul>
<li>함수는 다른 값들에 영향을 주지 않지만, 서브루틴은 다른 값들에 영향을 줄수 있습니다.</li>
</ul>
</li>
</ul>
<hr>
<h3>특수용도 레지스터</h3>
<table>
<thead>
<tr>
<th>레지스터</th>
<th>설명</th>
<th>용도</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SP</code> / <code>R13</code></td>
<td>Stack Pointer</td>
<td>C언어 사용시 스택의 주소를 저장</td>
</tr>
<tr>
<td><code>LR</code> / <code>R14</code></td>
<td>Link Register</td>
<td>함수 호출 시 되돌아갈 함수의 주소가 저장</td>
</tr>
<tr>
<td><code>PC</code> / <code>R15</code></td>
<td>Program Counter</td>
<td>프로그램 수행 시 읽어오는 명령의 주소를 저장</td>
</tr>
<tr>
<td>CPSR</td>
<td>Current Program Status Register</td>
<td>연산결과, IRQ, FIQ금지, 동작모드 등을 저장</td>
</tr>
</tbody>
</table>
<ul>
<li><code>SP</code>, <code>LR</code>은 일반 레지스터로 사용해도 무방합니다.</li>
</ul>
</div></article></main><footer class="c-cpkrrK"><div class="c-fiqONv">© <!-- -->2022</div><div class="c-bHyrwK"><div class="c-iUFgVP">Kh.</div><div class="c-cshSRb">KyuHyuk Lee</div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"excerpt":" 작업에 들어가기 전에 ARM Assembly에 대해 배워보도록 합시다. ARM CPU의 기본 구성 R0 ~ R14 총 15개의 범용 레지스터를 가지고 있습니다. 범용 레지스터 R13 는 특수 레지스터 SP 로 사용됩니다. SP 는 C언어 사용시 스택의 주소를 저장하는 레지스터입니다. ","url":"/article/simple-arm-operating-system/2019/03/04/Simple-ARM-Operating-System-Chapter-2","frontmatter":{"title":"Chapter 2: ARM Assembly 기초","date":"2019-03-04 23:07:02","category":"Simple-ARM-Operating-System"},"content":"\n작업에 들어가기 전에 ARM Assembly에 대해 배워보도록 합시다.\n\n- ARM CPU의 기본 구성\n  - `R0`~`R14` 총 15개의 범용 레지스터를 가지고 있습니다.\n  - 범용 레지스터 `R13`는 특수 레지스터 `SP`로 사용됩니다.\n    - `SP`는 C언어 사용시 스택의 주소를 저장하는 레지스터입니다.\n  - 범용 레지스터 `R14`는 특수 레지스터 `LR`로 사용됩니다.\n    - `LR`은 함수 호출 시 되돌아갈 함수의 주소가 저장되는 레지스터입니다.\n  - 범용 레지스터 `R15`는 특수 레지스터 `PC`로 사용됩니다.\n    - `PC`는 다음 실행할 프로그램의 주소를 가지고 있는 레지스터입니다.\n  - `CPSR`이라는 상태 레지스터를 가지고 있습니다.  \n    ![Operand](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-2/2019-03-04-Simple-ARM-Operating-System-Chapter-2_1.jpg)\n  - `Rs`, `Rd`는 반드시 레지스터(`R0`~`R15`)이어야 합니다.\n    - `OP1`은 항상 레지스터 입니다.\n  - **`OP2`는 레지스터 일수도 있고, 레지스터가 아닐수도 있습니다.**\n  - [`Rs`, `Rd`, `OP2`의 대상으로 직접 외부 메모리를 접근할수 없습니다.](#ldr-str-쉽게-이해하는-방법)\n\n---\n\n### Load, Store\n\n#### `MOV` 명령\n\n- ARM에서 레지스터의 데이터 이동은 `MOV` 명령을 사용합니다.\n  - 예) `MOV R0, R1` : `R1`의 내용을 `R0`으로 복사\n  - 예) `MOV R0, #1` : 상수 `1`을 `R0`으로 복사\n- 메모리→레지스터 : `LDR` (Load to Register)\n- 레지스터→메모리 : `STR` (Store to Memory)\n\n#### 상수 값을 레지스터에 저장\n\n- `LDR` 명령 사용 방법\n  - `LDR Rn, =Value`\n  - **`LDR`을 사용하여 상수의 값을 레지스터에 저장할때 `=Value`에서 `=`를 빼먹지 않게 주의합니다.**\n    - 다른 명령어에서는 상수 입력에 `#`이 들어가지만 `LDR`만 `=`이 들어가니 주의합시다.\n  - 레지스터간 데이터 복사는 `MOV`를 사용합니다.\n  - `Rn` : `R0` ~ `R15` (대소문자 구분 없음)\n  - `=Value` : 상수 값 (최대 4바이트)\n    - 10진수 :\n      - **예)** `41`, `-27`\n    - 16진수 :\n      - **예)** `0x1234`, `-0x1EF`\n    - 예) `LDR R0, =100`, `LDR R13, =0x1234`\n\n#### 상수 표현\n\n- `OP2`의 상수는 8비트의 값고 짝수 비트 ROR(Rotate Right)로 표현되어야 합니다.\n  - 32비트 명령 안에서 상수 값을 함께 저장하다보니 범위 제한이 발생하기 때문입니다.\n  - `0`~`255` 범위의 상수는 무조건 사용이 가능합니다.\n\n#### 사용된 상수가 `MOV` 명령에서 사용 가능한지 불가능한지 판단해보자\n\n- `MOV R0, #0x7F00` : **가능** ![Example1](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-2/2019-03-04-Simple-ARM-Operating-System-Chapter-2_2.png)\n\n- `MOV R0, #0x30C0` : **가능** ![Example2](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-2/2019-03-04-Simple-ARM-Operating-System-Chapter-2_3.png)\n\n- `MOV R3, #0x14E` : **불가능** ![Example3](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-2/2019-03-04-Simple-ARM-Operating-System-Chapter-2_4.png)\n\n- `LDR`을 사용하면, **범위 제한 없는 32비트 값으로 표현 가능**\n  - 실제 상수 값은 메모리에 존재하며 레지스터 참조로 변환됩니다.\n\n\u003e `MOV`보다 `LDR`이 느리지만, `LDR`은 32비트 데이터를 사용할 수 있습니다.\n\n#### 레지스터 간접참조 `LDR`, `STR`\n\n- 레지스터 간접 참조 :\n  - `LDR Rd, [Rs]`\n    - `Rs` 레지스터 값을 메모리 주소로 하여 `Rd`에 저장\n    - `Rs`, `Rd` : `R0` ~ `R15`\n  - `STR Rs, [Rd]`\n    - `Rd` 레지스터 값을 메모리 주소로 하여 `Rs`를 저장\n    - `Rs`, `Rd` : `R0` ~ `R15`\n\n##### 예)\n\n```assembly\n  LDR R0, =0x1000   @ R0에 상수 0x1000 저장\n  LDR R1, =80       @ R1에 상수 80 저장\n  STR R1, [R0]      @ R0의 값인 0x1000를 메모리 주소로 참조하여\n                    @ 0x1000에 상수 80을 저장\n```\n\n#### `LDR`, `STR` 쉽게 이해하는 방법\n\n![LDR STR Tip!](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-2/2019-03-04-Simple-ARM-Operating-System-Chapter-2_5.png)\n\n### Label\n\n```assembly\nSTART:  MOV R0, #10       @ R0 레지스터에 상수 10을 저장\n        STR R0, [R1]      @ R1에 저장되어 있는 주소에 R0 값을 저장\n        LDR PC, =START    @ START의 주소를 PC(Program counter)에 저장\n```\n\n- Label은 모두 주소 값(해당 Label 위치의 주소)입니다.\n- 위의 코드는 `START`의 주소 값을 PC(Program counter)에 저장하여 무한 루프를 하게 됩니다.\n\n### `LDR`, `STR` Post Indexing\n\n#### Post Indexing 사용 방법:\n\n```assembly\n  LDR R0, [R1], #4            @ R1 주소에 있는 값을 R0에 넣고, R1에 4를 더합니다.\n  STR R0, [R2], #-4           @ R0의 값을 R2의 주소에 넣고, R2에 4를 뺍니다.\n```\n\n```assembly\n  LDR R0, [R1], R3            @ R1 주소에 있는 값을 R0에 넣고, R1에 R3의 값을 더합니다.\n  STR R0, [R2], -R3           @ R0의 값을 R2의 주소에 넣고, R2에 R3의 값을 뺍니다.\n```\n\n```assembly\n  LDR R0, [R1], R3, LSL #2    @ R1 주소에 있는 값을 R0에 넣고,\n                              @ R1에 R3, LSL #2한 값을 더합니다.\n  STR R0, [R2], -R3, ASR #2   @ R2 주소에 있는 값을 R0에 넣고,\n                              @ R2에 R3, ASR #2한 값을 뺍니다.\n```\n\n##### 예)\n\n```assembly\n  LDR R1, 0x1000              @ R1에 상수 0x1000을 넣습니다.\n                              @ R1 : 0x1000\n\n  LDR R0, [R1], #4            @ R0에 0x1000를 참조한 값(R1의 메모리 참조주소)을 넣고,\n                              @ R1에 4를 더합니다.\n                              @ R1 : 0x1004\n\n  LDR R2, [R1], #4            @ R2에 0x1004를 참조한 값(R1의 메모리 참조주소)을 넣고,\n                              @ R1에 4를 더합니다.\n                              @ R1 : 0x1008\n```\n\n### `LDR`, `STR` Pre Indexing\n\n#### Pre Indexing 사용 방법:\n\n```assembly\n  LDR R0, [R1], #4            @ R1에 4를 더한것을 참조하여 R0에 넣습니다.\n  STR R0, [R2], #-4           @ R0의 값을 R2에 4를 뺀 주소에 넣습니다.\n```\n\n```assembly\n  LDR R0, [R1], R3            @ R1에 R3의 값을 더한것을 참조하여 R0에 넣습니다.\n  STR R0, [R2], -R3           @ R0의 값을 R2에 R3의 값을 뺀 주소에 넣습니다.\n```\n\n```assembly\n  LDR R0, [R1], R3, LSL #2    @ R1에 R3, LSL #2한 값을 더한뒤,\n                              @ 주소에 있는 값을 R0에 넣습니다.\n  STR R0, [R2], -R3, ASR #2   @ R2에 R3, ASR #2한 값을 뺀뒤,\n                              @ R0의 값을 변경된 주소로 넣습니다.\n```\n\n##### 예)\n\n```assembly\n  LDR R1, 0x1000              @ R1에 상수 0x1000을 넣습니다.\n                              @ R1 : 0x1000\n\n  LDR R0, [R1, #4]            @ R1에 4를 더한 주소의 참조한 값(0x1004)을 R0에 넣습니다.\n                              @ R1 : 0x1000\n\n  LDR R2, [R1, #4]            @ R1에 4를 더한 주소의 참조한 값(0x1004)을 R2에 넣습니다.\n                              @ R1 : 0x1000\n```\n\n\u003e Pre Indexing에서는 **값이 업데이트 되지 않습니다!** 만약 값을 업데이트하고 싶다면 아래의 `!`(Auto Update) 옵션을 사용해야합니다.\n\n#### '`!`(Auto Update) suffix' 사용 예시)\n\n```assembly\n  LDR R1, 0x1000              @ R1에 상수 0x1000을 넣습니다.\n                              @ R1 : 0x1000\n\n  LDR R0, [R1, #4]!           @ R1에 4를 더한 주소의 참조한 값(0x1004)을 R0에 넣습니다.\n                              @ ! suffix가 있으므로, 자동으로 값이 업데이트 됩니다.\n                              @ R1 : 0x1004\n\n  LDR R2, [R1, #4]            @ R1에 4를 더한 주소의 참조한 값(0x1008)을 R2에 넣습니다.\n                              @ ! suffix가 없으므로, 자동으로 값이 업데이트 되지 않습니다.\n                              @ R1 : 0x1004\n```\n\n#### `LSL`, `LSR` Shift\n\n- `LSL #n` : 최후에 밀려난 비트가 `CPSR`(상태레지스터)의 C(Carry) flag에 저장\n  - Logical Shift Left\n  - `LSL` : `signed/unsigned` 곱하기 2\n- `LSR #n` : 최후에 밀려난 비트가 `CPSR`(상태레지스터)의 C(Carry) flag에 저장\n  - Logical Shift Right\n  - `LSR` : `unsigned` 나누기 2\n\n#### `ASR` Shift\n\n- `ASR #n` : MSB(부호)를 유지하고, 밀려난 비트가 `CPSR`(상태레지스터)의 C(Carry) flag에 저장\n  - 레지스터를 우측으로 지정한 비트 수 만큼 **부호를 유지하며** Shift합니다.\n  - `ASR`은 `signed int`의 나누기 2 동작을 수행합니다.\n\n---\n\n### 비트제어 명령어\n\n- `ORR` : 원하는 비트만 1로 설정합니다.\n\n  - 예) `ORR R0, R0, #0x1F` , `ORR R0, R1, R2, LSL #2`\n\n- `EOR` : 원하는 비트만 반전 시킵니다.\n\n  - 예) `EOR R0, R0, #0x1F` , `EOR R0, R1, R2, LSL #2`\n\n- `AND` : 원하는 비트만 0으로 설정합니다.\n\n  - **0인 비트에 0으로 설정합니다.**\n  - 예) `AND R0, R0, #0x1F` , `AND R0, R1, R2, LSL #2`\n\n- `BIC` : 원하는 비트만 0으로 설정합니다.\n  - **1인 비트에 0으로 설정합니다.**\n  - `AND`보다 편리한 장점이 있습니다.\n  - 예) `BIC R0, R0, #0x1F` , `BIC R0, R1, R2, LSL #2`\n\n#### 다양한 비트연산\n\n- **[문제]** `0x1000`의 4~7번 비트를 `1010`으로 변경하는 어셈블리 코드를 작성하세요.\n\n![Example4](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-2/2019-03-04-Simple-ARM-Operating-System-Chapter-2_6.png)\n\n```assembly\n  LDR R0, =0x1000           @ R0에 상수 0x1000을 넣습니다.\n  LDR R1, [R0]              @ R1에 R0을 참조한 값을 넣습니다.\n  BIC R1, R1, 0xF \u003c\u003c 4      @ '1111'을 4번 Left Shift하면 '11110000'가 됩니다.\n                            @ BIC로 R1의 4~7 비트를 0으로 설정합니다.\n  ORR R1, R1, 0xA \u003c\u003c 4      @ '1010'을 4번 Left Shift하면 '10100000'가 됩니다.\n                            @ ORR로 R1의 5, 7번 비트를 1로 설정합니다.\n  STR R1, [R0]              @ R1의 데이터를 R0에 저장되어있는 메모리주소에 저장합니다.\n```\n\n---\n\n### 분기 명령어\n\n- `B` 명령 사용 예시:\n  1. `B add` : Global Label\n  2. `B 1f` : Local Label\n  3. `B . ` : 무한 루프 (`.`은 제자리를 말합니다.)\n- `B R0`와 같이 `B` 명령은 분기 주소로 레지스터를 쓸수 없습니다.\n\n---\n\n### 비교 연산 명령어\n\n- `CMP` : `CMP Rs, OP2`\n  - `Rn - OP2` 연산을 하여 `CPSR`(상태레지스터)의 Flag만 변경합니다.\n- `CMN` : `CMN Rs, OP2`\n  - `Rn + OP2` 연산을 하여 `CPSR`(상태레지스터)의 Flag만 변경합니다.\n  - 컴파일러단에서 주로 사용되니, 되도록이면 `CMP`를 사용하자.\n- `TST` : `TST Rs, OP2`\n  - `Rn \u0026 OP2` 연산을 하여 `CPSR`(상태레지스터)의 Flag만 변경합니다.\n  - **특정비트를 확인하기 위해 사용됩니다.**\n  - 비교 비트가 **1이면, Z clear, 0이면 Z set**\n- `TEQ` : `TEQ Rs, OP2`\n  - `Rn ^ OP2` 연산을 하여 `CPSR`(상태레지스터)의 Flag만 변경합니다.\n  - **두 데이터의 비트가 완전 똑같은지 확인하기 위해 사용됩니다**\n  - 비트 패턴이 **동일하면, Zero set**\n\n\u003e 비교연산은 레지스터에 변화가 없으며, Flag만 변합니다.\n\n- **[문제]** `R0`의 7번 비트가 `1`이면 `R1` 레지스터에 2를 기록하고, `0`이면 `R1` 레지스터에 3을 기록하는 프로그램을 작성하시오.\n\n- `AND`를 사용하여 해결:\n\n```assembly\n  AND R0, R0, #1 \u003c\u003c 7\n  CMP R0, #0\n  MOVEQ R1, #3\n  MOVNE R1, #2\n```\n\n- `TST`를 사용하여 해결:\n\n```assembly\n  TST R0, #1 \u003c\u003c 7\n  MOVEQ R1, #3\n  MOVNE R1, #2\n```\n\n---\n\n### `CPSR`(상태레지스터)과 Flag\n\n![CPSR : https://www.wikinote.org/Main/Savitribai-Phule-Pune-University/ENTC/AP-TE/Unit-1/Registers-CPSR-SPSR](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-2/2019-03-04-Simple-ARM-Operating-System-Chapter-2_7.jpg)\n\n비교 연산을 할때는 NZCV만 사용한다\n\n- N (Negative) : 연산결과가 음수인 경우\n- Z (Zero) : 연산결과가 0인 경우\n- C (Carry) : 덧셈 Carry에 Set, 뺄셈 Borrow에 Clear, Rotate시 밀린 비트 저장\n- V (oVerflow) : `signed` 덧셈, 뺄셈 연산 결과로 값의 초과가 발생한 경우\n\n\u003e Carry는 덧셈을 했을때 범위를 초과해서 자리 올림이 발생했을때를 말하는것입니다. Overflow와는 다릅니다.\n\n---\n\n### 상태 플래그와 조건\n\n```assembly\n  CMP R0, R1\n  B□□ LOOP\n```\n\n□ 부분에 아래의 16가지 조건식이 들어가게 됩니다.\n\n| 약어          | 뜻                                     | Flag 상태                    |\n| ------------- | -------------------------------------- | ---------------------------- |\n| **`EQ`**      | **Eq**ual / Equals zero (False)        | Z set                        |\n| **`NE`**      | **N**ot **E**qual (True)               | Z clear                      |\n| **`CS`**/`HS` | Carry Set / Unsigned higher or same    | **C set**                    |\n| **`CC`**/`LO` | Carry Clear / Unsigned Lower           | **C clear**                  |\n| **`MI`**      | **Mi**nus / Negative                   | N set                        |\n| **`PL`**      | **Pl**us / Positive or zero            | N clear                      |\n| **`VS`**      | Overflow                               | **V s**et                    |\n| **`VC`**      | No Overflow                            | **V c**lear                  |\n| **`HI`**      | `Unsigned` **hi**gher                  | C set and Z clear            |\n| **`LS`**      | `Unsigned` **l**ower or **s**ame       | C clear and Z set            |\n| **`GE`**      | `Signed` **g**reater then or **e**qual | N equals V                   |\n| **`LT`**      | `Signed` **l**ess **t**han             | N is not equals V            |\n| **`GT`**      | `Signed` **g**reater **t**han          | Z clear and N equals V       |\n| **`LE`**      | `Signed` **l**ess than or **e**qual    | Z set or N is not equal to V |\n| **`AL`**      | **Al**ways                             | Any state                    |\n| **`NV`**      | **N**e**v**er                          | None                         |\n\n- 주소 연산을 할때는 `HI`, `LO`, `HS`, `LS`와 같은 `Unsigned` 비교를 사용합니다.\n\n---\n\n### 산술 명령어\n\n- **ADD** : `ADD Rd, Rs, OP2`\n  - `Rd := Rs + OP2`\n- **ADC** : `ADC Rd, Rs, OP2`\n  - `Rd := Rs + OP2 + Carry`\n- **SUB** : `SUB Rd, Rs, OP2`\n  - `Rd := Rs - OP2`\n- **SBC** : `SBC Rd, Rs, OP2`\n  - `Rd := Rs - OP2 - !Carry`\n- **RSB** : `RSB Rd, Rs, OP2`\n  - `Rd := OP2 - Rs`\n- **RSC** : `RSC Rd, Rs, OP2`\n\n  - `Rd := OP2 - Rs - !Carry`\n\n- `RSB`, `RSC`에 있는 R은 Reverse라고 생각합시다.\n\n#### 일정 횟수를 반복하는 프로그램\n\n1. `for(i=0; i\u003c10; i++)` 방식\n\n```assembly\n  MOV R0, #0\n1:\n  @ 이곳에 코드 작성\n\n  ADD R0, R0, #1\n  CMP R0, #10\n  BLT 1b\n```\n\n2. `for(i=10; i\u003e0; i--)` 방식\n\n```assembly\n  MOV R0, #10\n1:\n  @ 이곳에 코드 작성\n\n  SUB R0, R0, #1\n  CMP R0, #0\n  BGT 1b\n```\n\n위의 두 방법도 좋지만, Down Count 방식에 S-Suffix를 사용하는게 더 효율적입니다.\n\n```assembly\n  MOV R0, #10\n1:\n  @ 이곳에 코드 작성\n\n  SUBS R0, R0, #1\n  BGT 1b\n```\n\n---\n\n### 서브루틴 호출\n\n- `BL label` : Branch and Link\n  - `BL` : 서브루틴 호출 명령\n  - `label` : 서브루틴의 상대주소 값\n  - `B`와 달리 복귀한 주소(따음 명령 주소) 값을 `R14`에 저장합니다.  \n    ![Subroutine](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-2/2019-03-04-Simple-ARM-Operating-System-Chapter-2_8.png)\n  - `BL`은 분기 주소로 레지스터를 사용하지 못합니다.\n\n#### 서브루틴 호출과 복귀\n\n- **서브루틴 호출** (`BL label`):\n  1. 복귀할 주소를 `LR`(`R14`)에 저장합니다.\n  2. 서브루틴의 주소를 `PC`(`R15`)에 저장합니다.\n- **서브루틴 복귀** (`BX LR`):\n\n  - `LR`(`R14`)의 값을 `PC`(`R15`)에 저장하여 복귀합니다.\n\n- 왜 함수라고 하지 않고 서브루틴이라고 부를까?\n  - 함수는 다른 값들에 영향을 주지 않지만, 서브루틴은 다른 값들에 영향을 줄수 있습니다.\n\n---\n\n### 특수용도 레지스터\n\n| 레지스터     | 설명                            | 용도                                         |\n| ------------ | ------------------------------- | -------------------------------------------- |\n| `SP` / `R13` | Stack Pointer                   | C언어 사용시 스택의 주소를 저장              |\n| `LR` / `R14` | Link Register                   | 함수 호출 시 되돌아갈 함수의 주소가 저장     |\n| `PC` / `R15` | Program Counter                 | 프로그램 수행 시 읽어오는 명령의 주소를 저장 |\n| CPSR         | Current Program Status Register | 연산결과, IRQ, FIQ금지, 동작모드 등을 저장   |\n\n- `SP`, `LR`은 일반 레지스터로 사용해도 무방합니다.\n"},"__N_SSG":true},"page":"/article/[category]/[year]/[month]/[day]/[slug]","query":{"category":"simple-arm-operating-system","year":"2019","month":"03","day":"04","slug":"Simple-ARM-Operating-System-Chapter-2"},"buildId":"46Dhy2L_ENuWomFHDRk1g","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>