<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><style id="stitches"></style><link rel="preload" href="/_next/static/css/98b299b94b0a7962.css" as="style"/><link rel="stylesheet" href="/_next/static/css/98b299b94b0a7962.css" data-n-g=""/><link rel="preload" href="/_next/static/css/5c3da54741072322.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5c3da54741072322.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-dea678fb5840c50f.js" defer=""></script><script src="/_next/static/chunks/framework-64ad27b21261a9ce.js" defer=""></script><script src="/_next/static/chunks/main-f2f237ba7e9012fc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9b6890f28bc766f1.js" defer=""></script><script src="/_next/static/chunks/803-9fe1c131242daf24.js" defer=""></script><script src="/_next/static/chunks/785-d1ab2e5b6dacd475.js" defer=""></script><script src="/_next/static/chunks/pages/article/%5Bcategory%5D/%5Byear%5D/%5Bmonth%5D/%5Bday%5D/%5Bslug%5D-6501b82d330bbee5.js" defer=""></script><script src="/_next/static/dFiaKGJXnX9ZfXI4gZrP9/_buildManifest.js" defer=""></script><script src="/_next/static/dFiaKGJXnX9ZfXI4gZrP9/_ssgManifest.js" defer=""></script></head><body><div id="__next"></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"excerpt":" Source Code는 https://github.com/LeeKyuHyuk/Simple-ARM-Operating-System/tree/raspberry-pi-zero/Chapter-5/src 에있습니다. UART(범용 비동기화 송수신기: Universal asynchronous re","url":"/article/simple-arm-operating-system/2019/03/04/Simple-ARM-Operating-System-Chapter-5","frontmatter":{"title":"Chapter 5: UART를 구현해보자!","date":"2019-03-04 23:07:05","category":"Simple-ARM-Operating-System"},"content":"\n\u003e Source Code는 [https://github.com/LeeKyuHyuk/Simple-ARM-Operating-System/tree/raspberry-pi-zero/Chapter-5/src](https://github.com/LeeKyuHyuk/Simple-ARM-Operating-System/tree/raspberry-pi-zero/Chapter-5/src)에있습니다.\n\n\u003e UART(범용 비동기화 송수신기: Universal asynchronous receiver/transmitter)는 병렬 데이터의 형태를직렬 방식으로 전환하여 데이터를 전송하는 컴퓨터 하드웨어의 일종이다. UART는 일반적으로 EIA RS-232, RS-422, RS-485와 같은 통신 표준과 함께 사용한다. [Wikipedia - UART](https://ko.wikipedia.org/wiki/UART)\n\nMini UART를 사용하여 UART를 구현해보도록 하겠습니다.\n\n### `uart_init()` : UART Initialization\n\n1. `AUXENB` Register의 `0`번 비트(Mini UART enable)를 `1`로 설정합니다.  \n   ![AUXENB](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_ENABLES.png)\n\n2. `AUX_MU_CNTL_REG` Register의 모든 비트를 `0`으로 설정합니다. Tx, Rx가 비활성화 됩니다.  \n   ![AUX_MU_CNTL_REG](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_CNTL.png)\n\n3. `AUX_MU_LCR_REG` Register의 `0`번, `1`번 비트를 `1`으로 설정합니다.  \n   `0`번 비트는 8-bit mode를 사용하도록 설정되며, `1`번 비트 또한 같은 이유로 설정되어야 합니다.  \n   **_문서에는 `5`:`1`번 비트가 Reserved라고 표기 되어있지만 이렇게 하지 않으면 정상적인 데이터가 전송되지 않습니다._**  \n   [BCM2835 datasheet errata #14P](https://elinux.org/BCM2835_datasheet_errata#p14)에 BCM2835 Datasheet의 `AUX_MU_LCR_REG`의 틀린 부분이 언급되어 있습니다.  \n   ![AUX_MU_LCR_REG](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_LCR.png)\n\n4. `AUX_MU_MCR_REG` Register의 모든 비트를 `0`으로 설정합니다.  \n   ![AUX_MU_MCR_REG](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_MCR.png)\n\n5. `AUX_MU_IER_REG` Register의 모든 비트를 `0`으로 설정합니다.  \n   ![AUX_MU_IER_REG](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_IER.png)\n\n6. `AUX_MU_IIR_REG` Register의 비트를 `11000001`로 설정합니다.  \n   ![AUX_MU_IIR_REG](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_IIR.png)\n\n- Interrupt Pending[`0`], FIFO Enable[`7`:`6`]\n\n7. `AUX_MU_BAUD` Register를 `270`으로 설정합니다.  \n   ![AUX_MU_BAUD](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_BAUD.png)\n\n- `baudrate = system_clock_freq / 8 * (baudrate_reg + 1)`\n- **`baudrate_reg` 계산 방법:**\n  - `baudrate_reg = (system_clock_freq / 8 * baudrate) - 1`\n  - `baudrate_reg = (250000000 / 8 * 115200) - 1 = 270.267‥ ≈ 270`\n\n8. `GPFSEL1` Register에서 GPIO 14, 15 Pin을 'Alternate function 5'로 설정합니다.  \n   ![Alternative Function Assignments](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/alternative_function_assignments_gpio_14_15.png)  \n   ![GPFSEL1](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/GPFSEL1.png)\n\n9. `GPPUD` Register의 [`1`:`0`]을 `0`으로 설정합니다.  \n   ![GPPUD](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/GPPUD.png)\n\n- Off - Disable Pull-up/down\n\n10. `GPPUDCLK0` Register에서 `14`, `15`번 비트를 `1`로 설정합니다.  \n    (GPIO Pin 14, 15를 Assert Clock on line으로 만듭니다)  \n    ![GPPUDCLK0](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/GPPUDCLK0.png)\n\n11. `GPPUDCLK0` Register를 `0`으로 설정하여, 모든 GPIO Pin을 No Effect로 만듭니다.\n\n\u003e **9번 ~ 11번 과정 설명 :**\n\u003e\n\u003e 1. `GPPUD`에 기록하여 필요한 control signal를 설정합니다.\n\u003e 2. control signal를 설정하기 위해 150 사이클을 기다립니다.\n\u003e 3. `GPPUD`에서 수정한 GPIO의 control signal에 clock을 보내기 위해 `GPPUDCLK0`에서도 해당 GPIO 핀을수정합니다.\n\u003e 4. 150 사이클을 기다립니다.\n\u003e 5. '1'에서 `GPPUD`에 기록했던 GPIO의 설정을 제거합니다.\n\u003e 6. '3'에서 `GPPUDCLK0`에 기록했던 GPIO의 설정을 제거합니다.\n\n12. `AUX_MU_CNTL_REG` Register의 `0`, `1`번 비트를 `1`로 설정하여 Tx, Rx를 활성화 합니다.  \n    ![AUX_MU_CNTL_REG](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_CNTL.png)\n\n```c\n/* initialize UART */\nvoid uart_init() {\n  volatile unsigned char delay;\n\n  AUX_ENABLES |= 1; // Mini UART 활성화\n  AUX_MU_CNTL = 0;  // Tx, Rx 비활성화\n  AUX_MU_LCR = 3;   // Data size : 8-bit mode\n  AUX_MU_MCR = 0;\n  AUX_MU_IER = 0;\n  AUX_MU_IIR = 0xC1; // Interrupts 비활성화\n  AUX_MU_BAUD = 270; // Baudrate를 115200로 설정\n\n  // UART1 GPIO pins setting\n  GPFSEL1 = (2 \u003c\u003c 12) | (2 \u003c\u003c 15); // GPIO 14, 15핀을 alternate function 5로 설정\n  GPPUD = 0;                       // GPIO 14, 15핀 활성화\n  for (delay = 0; delay \u003c 150; delay++)\n    asm volatile(\"nop\");\n  GPPUDCLK0 = (1 \u003c\u003c 14) | (1 \u003c\u003c 15);\n  for (delay = 0; delay \u003c 150; delay++)\n    asm volatile(\"nop\");\n  GPPUDCLK0 = 0;   // Flush GPIO setup\n  AUX_MU_CNTL = 3; // Tx, Rx 활성화\n}\n```\n\n### `uart_send()` : Send a character\n\n1. `AUX_MU_LSR_REG` Register의 `5`번째 비트인 'Transmitter Empty'를 확인합니다. ![AUX_MU_LSR_REG](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_LSR.png)\n\n2. 'Transmitter Empty'가 `1`이면 `AUX_MU_IO_REG`에 Data를 넣어 Buffer에 문자를 기록합니다.  \n   ![AUX_MU_IO_REG](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_IO.png)\n\n```c\n/* Send a character */\nvoid uart_send(unsigned int data) {\n  // AUX_MU_LSR의 Transmitter Empty 비트가 '1'이 될 때까지 대기합니다.\n  do {\n    asm volatile(\"nop\");\n  } while (!(AUX_MU_LSR \u0026 (1\u003c\u003c5)));\n  // Buffer에 문자를 기록합니다.\n  AUX_MU_IO = data;\n}\n```\n\n### `uart_getc()` : Receive a character\n\n1. `AUX_MU_LSR_REG` Register의 `1`번째 비트인 'Data ready'를 확인합니다. ![AUX_MU_LSR_REG](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_LSR.png)\n\n2. 'Data ready'가 `1`이면 `AUX_MU_IO_REG`의 Data를 읽어 반환합니다.  \n   ![AUX_MU_IO_REG](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_IO.png)\n\n```c\n/*  Receive a character */\nchar uart_getc() {\n  char character;\n  // Buffer에 무엇인가 있을때까지 대기합니다.\n  do {\n    asm volatile(\"nop\");\n  } while (!(AUX_MU_LSR \u0026 1));\n  // AUX_MU_IO에서 값을 읽어오고 return 합니다.\n  character = (char)(AUX_MU_IO);\n  // '\\r'를 '\\n'으로 변환합니다.\n  return character == '\\r' ? '\\n' : character;\n}\n```\n\n### `uart_puts()` : Display a string\n\n앞에서 만들었던 `uart_send()`를 사용하여, `string`의 index를 1씩 더하며 `string`이 `NULL`이 될 때까지 `uart_send(*string++);`을 호출합니다.\n\n```c\n/* Display a string */\nvoid uart_puts(char *string) {\n  while (*string) {\n    // '\\n'를 '\\r'으로 변환합니다.\n    if (*string == '\\n')\n      uart_send('\\r');\n    uart_send(*string++);\n  }\n}\n```\n\n### Source Code\n\n**Makefile :**\n\n```\nSRCS = $(wildcard *.c)\nOBJS = $(SRCS:.c=.o)\nCFLAGS = -Wall -O2 -ffreestanding -nostdinc -nostdlib -nostartfiles\n\nall: clean kernel.bin\n\nboot.o: boot.S\n\tarm-none-eabi-gcc $(CFLAGS) -c boot.S -o boot.o\n\n%.o: %.c\n\tarm-none-eabi-gcc $(CFLAGS) -c $\u003c -o $@\n\nkernel.bin: boot.o $(OBJS)\n\tarm-none-eabi-ld -nostdlib -nostartfiles boot.o $(OBJS) -Map kernel.map -T linker.ld -o kernel.elf\n\tarm-none-eabi-objcopy kernel.elf -O binary kernel.bin\n\tarm-none-eabi-objdump -D kernel.elf \u003e kernel.dump\n\nclean:\n\trm kernel.elf kernel.bin kernel.dump kernel.map *.o \u003e/dev/null 2\u003e/dev/null || true\n```\n\n**boot.S :**\n\n```\n.section \".text.boot\"\n\n.global _start\n\n_start:\n\tbl      main\n```\n\n**gpio.h :**\n\n```c\n#define MMIO_BASE       0x20000000\n\n/* GPIO registers */\n#define GPFSEL1         (*(volatile unsigned int*)(MMIO_BASE+0x00200004))\n#define GPPUD           (*(volatile unsigned int*)(MMIO_BASE+0x00200094))\n#define GPPUDCLK0       (*(volatile unsigned int*)(MMIO_BASE+0x00200098))\n\n/* Auxilary mini UART registers */\n#define AUX_ENABLES     (*(volatile unsigned int*)(MMIO_BASE+0x00215004))\n#define AUX_MU_IO       (*(volatile unsigned int*)(MMIO_BASE+0x00215040))\n#define AUX_MU_IER      (*(volatile unsigned int*)(MMIO_BASE+0x00215044))\n#define AUX_MU_IIR      (*(volatile unsigned int*)(MMIO_BASE+0x00215048))\n#define AUX_MU_LCR      (*(volatile unsigned int*)(MMIO_BASE+0x0021504C))\n#define AUX_MU_MCR      (*(volatile unsigned int*)(MMIO_BASE+0x00215050))\n#define AUX_MU_LSR      (*(volatile unsigned int*)(MMIO_BASE+0x00215054))\n#define AUX_MU_CNTL     (*(volatile unsigned int*)(MMIO_BASE+0x00215060))\n#define AUX_MU_BAUD     (*(volatile unsigned int*)(MMIO_BASE+0x00215068))\n```\n\n**linker.ld :**\n\n```\nSECTIONS\n{\n    . = 0x8000;\n    .text : { KEEP(*(.text.boot)) *(.text .text.* .gnu.linkonce.t*) }\n    .rodata : { *(.rodata .rodata.* .gnu.linkonce.r*) }\n    PROVIDE(_data = .);\n    .data : { *(.data .data.* .gnu.linkonce.d*) }\n    .bss (NOLOAD) : {\n        . = ALIGN(16);\n        __bss_start = .;\n        *(.bss .bss.*)\n        *(COMMON)\n        __bss_end = .;\n    }\n    _end = .;\n\n   /DISCARD/ : { *(.comment) *(.gnu*) *(.note*) *(.eh_frame*) }\n}\n__bss_size = (__bss_end - __bss_start)\u003e\u003e3;\n```\n\n**uart.h :**\n\n```c\nvoid uart_init();\nvoid uart_send(unsigned int c);\nchar uart_getc();\nvoid uart_puts(char *s);\n```\n\n**uart.c :**\n\n```c\n#include \"gpio.h\"\n\n/**\n * initialize UART\n */\nvoid uart_init() {\n  volatile unsigned char delay;\n\n  AUX_ENABLES |= 1; // Mini UART 활성화\n  AUX_MU_CNTL = 0;  // Tx, Rx 비활성화\n  AUX_MU_LCR = 3;   // Data size : 8-bit mode\n  AUX_MU_MCR = 0;\n  AUX_MU_IER = 0;\n  AUX_MU_IIR = 0xC1; // Interrupts 비활성화\n  AUX_MU_BAUD = 270; // Baudrate를 115200로 설정\n\n  // UART1 GPIO pins setting\n  GPFSEL1 = (2 \u003c\u003c 12) | (2 \u003c\u003c 15); // GPIO 14, 15핀을 alternate function 5로 설정\n  GPPUD = 0;                 // GPIO 14, 15핀 활성화\n  for (delay = 0; delay \u003c 150; delay++)\n    asm volatile(\"nop\");\n  GPPUDCLK0 = (1 \u003c\u003c 14) | (1 \u003c\u003c 15);\n  for (delay = 0; delay \u003c 150; delay++)\n    asm volatile(\"nop\");\n  GPPUDCLK0 = 0;   // Flush GPIO setup\n  AUX_MU_CNTL = 3; // Tx, Rx 활성화\n}\n\n/**\n * Send a character\n */\nvoid uart_send(unsigned int data) {\n  // AUX_MU_LSR의 Transmitter Empty 비트가 '1'이 될 때까지 대기합니다.\n  do {\n    asm volatile(\"nop\");\n  } while (!(AUX_MU_LSR \u0026 (1 \u003c\u003c 5)));\n  // Buffer에 문자를 기록합니다.\n  AUX_MU_IO = data;\n}\n\n/**\n * Receive a character\n */\nchar uart_getc() {\n  char character;\n  // Buffer에 무엇인가 있을때까지 대기합니다.\n  do {\n    asm volatile(\"nop\");\n  } while (!(AUX_MU_LSR \u0026 1));\n  // AUX_MU_IO에서 값을 읽어오고 return 합니다.\n  character = (char)(AUX_MU_IO);\n  // '\\r'를 '\\n'으로 변환합니다.\n  return character == '\\r' ? '\\n' : character;\n  ;\n}\n\n/**\n * Display a string\n */\nvoid uart_puts(char *string) {\n  while (*string) {\n    // '\\n'를 '\\r'으로 변환합니다.\n    if (*string == '\\n')\n      uart_send('\\r');\n    uart_send(*string++);\n  }\n}\n```\n\n**main.c :**\n\n```c\n#include \"uart.h\"\n\nvoid main() {\n  // UART 초기화\n  uart_init();\n\n  // \"Hello World!\"를 UART로 출력\n  uart_puts(\"Hello World!\\n\");\n  uart_puts(\"Raspberry Pi Zero UART\\n\");\n\n  // UART 입력되는 것을 UART로 출력 (Echo 기능)\n  while (1) {\n    uart_send(uart_getc());\n  }\n}\n```\n\n![Putty](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/putty.png)\n"},"__N_SSG":true},"page":"/article/[category]/[year]/[month]/[day]/[slug]","query":{"category":"simple-arm-operating-system","year":"2019","month":"03","day":"04","slug":"Simple-ARM-Operating-System-Chapter-5"},"buildId":"dFiaKGJXnX9ZfXI4gZrP9","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>