<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta property="og:image" content="https://kyuhyuk.kr/thumbnail.png"/><title>Chapter 5: UART를 구현해보자!</title><meta name="author" content="KyuHyuk Lee"/><meta name="generator" content="KyuHyuk Lee"/><meta name="description" content=" Source Code는 https://github.com/LeeKyuHyuk/Simple-ARM-Operating-System/tree/raspberry-pi-zero/Chapter-5/src 에있습니다. UART(범용 비동기화 송수신기: Universal asynchronous re"/><meta itemProp="url" content="https://kyuhyuk.kr/article/simple-arm-operating-system/2019/03/04/Simple-ARM-Operating-System-Chapter-5"/><meta itemProp="headline" content="Chapter 5: UART를 구현해보자!"/><meta property="og:type" content="article"/><meta property="og:url" content="https://kyuhyuk.kr/article/simple-arm-operating-system/2019/03/04/Simple-ARM-Operating-System-Chapter-5"/><meta property="og:title" content="Chapter 5: UART를 구현해보자!"/><meta property="og:description" content=" Source Code는 https://github.com/LeeKyuHyuk/Simple-ARM-Operating-System/tree/raspberry-pi-zero/Chapter-5/src 에있습니다. UART(범용 비동기화 송수신기: Universal asynchronous re"/><meta property="og:site_name" content="KyuHyuk Blog"/><meta property="og:locale" content="ko_KR"/><meta name="next-head-count" content="15"/><style id="stitches">--sxs{--sxs:2 c-opBYf c-bHyrwK c-uBnvQ c-hehuMV c-bjkCdF c-hAoZGi c-jfcKOQ c-ezyKJG c-iAzQif c-bvdusc c-ezRQNp c-iosjjB c-jYwCTI c-iOPkYY c-cpkrrK c-fiqONv c-iUFgVP c-cshSRb c-fxvkZv c-dIcdES}@media{.c-opBYf{display:flex;align-items:center;background:#FFFFFF;height:60px;justify-content:space-between;-webkit-box-align:center;-webkit-box-pack:justify}.c-bHyrwK{display:flex;align-items:center;justify-content:center;-webkit-box-align:center;-webkit-box-pack:center}.c-uBnvQ{width:32px;height:32px;color:#FFFFFF;background:#000000;border-radius:4px;display:flex;align-items:center;justify-content:center;margin-right:12px;font-weight:700;cursor:default;-webkit-box-align:center;-webkit-box-pack:center}.c-hehuMV{font-weight:900;font-size:18px;letter-spacing:0.5px;color:#000000;cursor:default}.c-bjkCdF{list-style:none;padding:0;margin:0;display:flex;justify-content:center;align-items:center;font-size:24px;color:rgb(134, 142, 150);transition:all 0.3s ease 0s;-webkit-box-pack:center;-webkit-box-align:center}.c-hAoZGi{font-size:28px;color:inherit;text-decoration:none;margin:8px}.c-jfcKOQ{max-width:768px;margin-top:2rem;margin-left:auto;margin-right:auto}.c-ezyKJG{min-width:72px;display:flex;flex-direction:row;justify-content:center;align-items:center;padding:6px 16px;background:#12B886;box-shadow:0px 1px 2px rgba(98, 16, 204, 0.3);border:none;border-radius:14px;vertical-align:middle;color:#FFFFFF;font-size:1rem;height:2rem;float:right}.c-iAzQif{display:inline-block;margin-top:2rem}.c-bvdusc{font-size:2rem;line-height:1.5;letter-spacing:-0.004em;margin-top:0;margin-bottom:2rem;font-weight:700;color:#212529;word-break:keep-all;transition:color 0.125s ease-in 0s;}.c-ezRQNp{font-size:1.125rem;color:#212529;transition:color 0.125s ease-in 0s;;line-height:1.7;letter-spacing:-0.004em;word-break:break-all;overflow-wrap:break-word}.c-iosjjB{background:#F8F9FA;padding:0 1rem;height:2rem;border-radius:1rem;display:inline-flex;align-items:center;margin-right:0.875rem;color:#12B886;text-decoration:none;font-weight:400;font-size:1rem}.c-jYwCTI{font-size:1rem;color:#495057}.c-iOPkYY{margin-top:3rem;background-color:rgba(51,51,51,.1);border:0;height:1px}.c-cpkrrK{width:100%;height:300px;display:flex;align-items:center;justify-content:center;flex-direction:column;-webkit-box-align:center;-webkit-box-pack:center}.c-fiqONv{color:rgb(206, 212, 218);margin-bottom:8px;font-size:22px;font-weight:700}.c-iUFgVP{width:32px;height:32px;color:#FFFFFF;background:rgb(206, 212, 218);border-radius:4px;display:flex;align-items:center;justify-content:center;margin-right:12px;font-weight:700;cursor:default;-webkit-box-align:center;-webkit-box-pack:center}.c-cshSRb{font-weight:900;font-size:18px;letter-spacing:0.5px;color:rgb(206, 212, 218);cursor:default;text-transform:uppercase}.c-fxvkZv{font-size:2.5rem;line-height:1.5;letter-spacing:-0.004em;margin-top:0;margin-bottom:2rem;font-weight:700;color:#212529;word-break:keep-all;transition:color 0.125s ease-in 0s;}.c-dIcdES{margin-top:2rem;font-size:1.125rem;color:#212529;transition:color 0.125s ease-in 0s;;line-height:1.7;letter-spacing:-0.004em;word-break:keep-all;overflow-wrap:break-word}}</style><link rel="preload" href="/_next/static/css/98b299b94b0a7962.css" as="style"/><link rel="stylesheet" href="/_next/static/css/98b299b94b0a7962.css" data-n-g=""/><link rel="preload" href="/_next/static/css/c2a527101433f11d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c2a527101433f11d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-c354a30bda3d62a6.js" defer=""></script><script src="/_next/static/chunks/pages/_app-8265bb1a072646d3.js" defer=""></script><script src="/_next/static/chunks/776-f277552409ab147f.js" defer=""></script><script src="/_next/static/chunks/305-e325b960616dc0fd.js" defer=""></script><script src="/_next/static/chunks/pages/article/%5Bcategory%5D/%5Byear%5D/%5Bmonth%5D/%5Bday%5D/%5Bslug%5D-aa033f8eb8939164.js" defer=""></script><script src="/_next/static/ZyJ0P4wUHhxVoXujUtGq7/_buildManifest.js" defer=""></script><script src="/_next/static/ZyJ0P4wUHhxVoXujUtGq7/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="c-opBYf"><a href="https://kyuhyuk.kr"><div class="c-bHyrwK"><div class="c-uBnvQ">Kh.</div><div class="c-hehuMV">KyuHyuk Blog</div></div></a><ul class="c-bjkCdF"><li><a href="https://github.com/LeeKyuHyuk" class="c-hAoZGi"><span role="img" aria-label="github" class="anticon anticon-github"><svg viewBox="64 64 896 896" focusable="false" data-icon="github" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0138.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"></path></svg></span></a></li><li><a href="https://linkedin.com/in/leekyuhyuk" class="c-hAoZGi"><span role="img" aria-label="linkedin" class="anticon anticon-linkedin"><svg viewBox="64 64 896 896" focusable="false" data-icon="linkedin" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zM349.3 793.7H230.6V411.9h118.7v381.8zm-59.3-434a68.8 68.8 0 1168.8-68.8c-.1 38-30.9 68.8-68.8 68.8zm503.7 434H675.1V608c0-44.3-.8-101.2-61.7-101.2-61.7 0-71.2 48.2-71.2 98v188.9H423.7V411.9h113.8v52.2h1.6c15.8-30 54.5-61.7 112.3-61.7 120.2 0 142.3 79.1 142.3 181.9v209.4z"></path></svg></span></a></li><li><a href="mailto:lee@kyuhyuk.kr" class="c-hAoZGi"><span role="img" aria-label="mail" class="anticon anticon-mail"><svg viewBox="64 64 896 896" focusable="false" data-icon="mail" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-80.8 108.9L531.7 514.4c-7.8 6.1-18.7 6.1-26.5 0L189.6 268.9A7.2 7.2 0 01194 256h648.8a7.2 7.2 0 014.4 12.9z"></path></svg></span></a></li></ul></header><main class="c-jfcKOQ"><article><h1 class="c-fxvkZv"><a href="https://kyuhyuk.kr/article/simple-arm-operating-system/2019/03/04/Simple-ARM-Operating-System-Chapter-5">Chapter 5: UART를 구현해보자!</a></h1><a href="https://kyuhyuk.kr/category/Simple-ARM-Operating-System" class="c-iosjjB">Simple ARM Operating System</a><time dateTime="2019-03-04 23:07:05" class="c-jYwCTI">Mar 04, 2019 11:07:05 PM</time><div id="post" class="c-dIcdES"><blockquote>
<p>Source Code는 <a href="https://github.com/LeeKyuHyuk/Simple-ARM-Operating-System/tree/raspberry-pi-zero/Chapter-5/src">https://github.com/LeeKyuHyuk/Simple-ARM-Operating-System/tree/raspberry-pi-zero/Chapter-5/src</a>에있습니다.</p>
</blockquote>
<blockquote>
<p>UART(범용 비동기화 송수신기: Universal asynchronous receiver/transmitter)는 병렬 데이터의 형태를직렬 방식으로 전환하여 데이터를 전송하는 컴퓨터 하드웨어의 일종이다. UART는 일반적으로 EIA RS-232, RS-422, RS-485와 같은 통신 표준과 함께 사용한다. <a href="https://ko.wikipedia.org/wiki/UART">Wikipedia - UART</a></p>
</blockquote>
<p>Mini UART를 사용하여 UART를 구현해보도록 하겠습니다.</p>
<h3><code>uart_init()</code> : UART Initialization</h3>
<ol>
<li>
<p><code>AUXENB</code> Register의 <code>0</code>번 비트(Mini UART enable)를 <code>1</code>로 설정합니다.<br>
<img src="/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_ENABLES.png" alt="AUXENB"></p>
</li>
<li>
<p><code>AUX_MU_CNTL_REG</code> Register의 모든 비트를 <code>0</code>으로 설정합니다. Tx, Rx가 비활성화 됩니다.<br>
<img src="/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_CNTL.png" alt="AUX_MU_CNTL_REG"></p>
</li>
<li>
<p><code>AUX_MU_LCR_REG</code> Register의 <code>0</code>번, <code>1</code>번 비트를 <code>1</code>으로 설정합니다.<br>
<code>0</code>번 비트는 8-bit mode를 사용하도록 설정되며, <code>1</code>번 비트 또한 같은 이유로 설정되어야 합니다.<br>
<strong><em>문서에는 <code>5</code>:<code>1</code>번 비트가 Reserved라고 표기 되어있지만 이렇게 하지 않으면 정상적인 데이터가 전송되지 않습니다.</em></strong><br>
<a href="https://elinux.org/BCM2835_datasheet_errata#p14">BCM2835 datasheet errata #14P</a>에 BCM2835 Datasheet의 <code>AUX_MU_LCR_REG</code>의 틀린 부분이 언급되어 있습니다.<br>
<img src="/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_LCR.png" alt="AUX_MU_LCR_REG"></p>
</li>
<li>
<p><code>AUX_MU_MCR_REG</code> Register의 모든 비트를 <code>0</code>으로 설정합니다.<br>
<img src="/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_MCR.png" alt="AUX_MU_MCR_REG"></p>
</li>
<li>
<p><code>AUX_MU_IER_REG</code> Register의 모든 비트를 <code>0</code>으로 설정합니다.<br>
<img src="/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_IER.png" alt="AUX_MU_IER_REG"></p>
</li>
<li>
<p><code>AUX_MU_IIR_REG</code> Register의 비트를 <code>11000001</code>로 설정합니다.<br>
<img src="/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_IIR.png" alt="AUX_MU_IIR_REG"></p>
</li>
</ol>
<ul>
<li>Interrupt Pending[<code>0</code>], FIFO Enable[<code>7</code>:<code>6</code>]</li>
</ul>
<ol start="7">
<li><code>AUX_MU_BAUD</code> Register를 <code>270</code>으로 설정합니다.<br>
<img src="/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_BAUD.png" alt="AUX_MU_BAUD"></li>
</ol>
<ul>
<li><code>baudrate = system_clock_freq / 8 * (baudrate_reg + 1)</code></li>
<li><strong><code>baudrate_reg</code> 계산 방법:</strong>
<ul>
<li><code>baudrate_reg = (system_clock_freq / 8 * baudrate) - 1</code></li>
<li><code>baudrate_reg = (250000000 / 8 * 115200) - 1 = 270.267‥ ≈ 270</code></li>
</ul>
</li>
</ul>
<ol start="8">
<li>
<p><code>GPFSEL1</code> Register에서 GPIO 14, 15 Pin을 'Alternate function 5'로 설정합니다.<br>
<img src="/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/alternative_function_assignments_gpio_14_15.png" alt="Alternative Function Assignments"><br>
<img src="/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/GPFSEL1.png" alt="GPFSEL1"></p>
</li>
<li>
<p><code>GPPUD</code> Register의 [<code>1</code>:<code>0</code>]을 <code>0</code>으로 설정합니다.<br>
<img src="/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/GPPUD.png" alt="GPPUD"></p>
</li>
</ol>
<ul>
<li>Off - Disable Pull-up/down</li>
</ul>
<ol start="10">
<li>
<p><code>GPPUDCLK0</code> Register에서 <code>14</code>, <code>15</code>번 비트를 <code>1</code>로 설정합니다.<br>
(GPIO Pin 14, 15를 Assert Clock on line으로 만듭니다)<br>
<img src="/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/GPPUDCLK0.png" alt="GPPUDCLK0"></p>
</li>
<li>
<p><code>GPPUDCLK0</code> Register를 <code>0</code>으로 설정하여, 모든 GPIO Pin을 No Effect로 만듭니다.</p>
</li>
</ol>
<blockquote>
<p><strong>9번 ~ 11번 과정 설명 :</strong></p>
<ol>
<li><code>GPPUD</code>에 기록하여 필요한 control signal를 설정합니다.</li>
<li>control signal를 설정하기 위해 150 사이클을 기다립니다.</li>
<li><code>GPPUD</code>에서 수정한 GPIO의 control signal에 clock을 보내기 위해 <code>GPPUDCLK0</code>에서도 해당 GPIO 핀을수정합니다.</li>
<li>150 사이클을 기다립니다.</li>
<li>'1'에서 <code>GPPUD</code>에 기록했던 GPIO의 설정을 제거합니다.</li>
<li>'3'에서 <code>GPPUDCLK0</code>에 기록했던 GPIO의 설정을 제거합니다.</li>
</ol>
</blockquote>
<ol start="12">
<li><code>AUX_MU_CNTL_REG</code> Register의 <code>0</code>, <code>1</code>번 비트를 <code>1</code>로 설정하여 Tx, Rx를 활성화 합니다.<br>
<img src="/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_CNTL.png" alt="AUX_MU_CNTL_REG"></li>
</ol>
<pre><code class="language-c"><span class="hljs-comment">/* initialize UART */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">uart_init</span><span class="hljs-params">()</span> {
  <span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> delay;

  AUX_ENABLES |= <span class="hljs-number">1</span>; <span class="hljs-comment">// Mini UART 활성화</span>
  AUX_MU_CNTL = <span class="hljs-number">0</span>;  <span class="hljs-comment">// Tx, Rx 비활성화</span>
  AUX_MU_LCR = <span class="hljs-number">3</span>;   <span class="hljs-comment">// Data size : 8-bit mode</span>
  AUX_MU_MCR = <span class="hljs-number">0</span>;
  AUX_MU_IER = <span class="hljs-number">0</span>;
  AUX_MU_IIR = <span class="hljs-number">0xC1</span>; <span class="hljs-comment">// Interrupts 비활성화</span>
  AUX_MU_BAUD = <span class="hljs-number">270</span>; <span class="hljs-comment">// Baudrate를 115200로 설정</span>

  <span class="hljs-comment">// UART1 GPIO pins setting</span>
  GPFSEL1 = (<span class="hljs-number">2</span> &lt;&lt; <span class="hljs-number">12</span>) | (<span class="hljs-number">2</span> &lt;&lt; <span class="hljs-number">15</span>); <span class="hljs-comment">// GPIO 14, 15핀을 alternate function 5로 설정</span>
  GPPUD = <span class="hljs-number">0</span>;                       <span class="hljs-comment">// GPIO 14, 15핀 활성화</span>
  <span class="hljs-keyword">for</span> (delay = <span class="hljs-number">0</span>; delay &lt; <span class="hljs-number">150</span>; delay++)
    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;nop&quot;</span>)</span>;
  GPPUDCLK0 = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">14</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">15</span>);
  <span class="hljs-keyword">for</span> (delay = <span class="hljs-number">0</span>; delay &lt; <span class="hljs-number">150</span>; delay++)
    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;nop&quot;</span>)</span>;
  GPPUDCLK0 = <span class="hljs-number">0</span>;   <span class="hljs-comment">// Flush GPIO setup</span>
  AUX_MU_CNTL = <span class="hljs-number">3</span>; <span class="hljs-comment">// Tx, Rx 활성화</span>
}
</code></pre>
<h3><code>uart_send()</code> : Send a character</h3>
<ol>
<li>
<p><code>AUX_MU_LSR_REG</code> Register의 <code>5</code>번째 비트인 'Transmitter Empty'를 확인합니다. <img src="/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_LSR.png" alt="AUX_MU_LSR_REG"></p>
</li>
<li>
<p>'Transmitter Empty'가 <code>1</code>이면 <code>AUX_MU_IO_REG</code>에 Data를 넣어 Buffer에 문자를 기록합니다.<br>
<img src="/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_IO.png" alt="AUX_MU_IO_REG"></p>
</li>
</ol>
<pre><code class="language-c"><span class="hljs-comment">/* Send a character */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">uart_send</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> data)</span> {
  <span class="hljs-comment">// AUX_MU_LSR의 Transmitter Empty 비트가 &#x27;1&#x27;이 될 때까지 대기합니다.</span>
  <span class="hljs-keyword">do</span> {
    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;nop&quot;</span>)</span>;
  } <span class="hljs-keyword">while</span> (!(AUX_MU_LSR &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>)));
  <span class="hljs-comment">// Buffer에 문자를 기록합니다.</span>
  AUX_MU_IO = data;
}
</code></pre>
<h3><code>uart_getc()</code> : Receive a character</h3>
<ol>
<li>
<p><code>AUX_MU_LSR_REG</code> Register의 <code>1</code>번째 비트인 'Data ready'를 확인합니다. <img src="/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_LSR.png" alt="AUX_MU_LSR_REG"></p>
</li>
<li>
<p>'Data ready'가 <code>1</code>이면 <code>AUX_MU_IO_REG</code>의 Data를 읽어 반환합니다.<br>
<img src="/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_IO.png" alt="AUX_MU_IO_REG"></p>
</li>
</ol>
<pre><code class="language-c"><span class="hljs-comment">/*  Receive a character */</span>
<span class="hljs-type">char</span> <span class="hljs-title function_">uart_getc</span><span class="hljs-params">()</span> {
  <span class="hljs-type">char</span> character;
  <span class="hljs-comment">// Buffer에 무엇인가 있을때까지 대기합니다.</span>
  <span class="hljs-keyword">do</span> {
    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;nop&quot;</span>)</span>;
  } <span class="hljs-keyword">while</span> (!(AUX_MU_LSR &amp; <span class="hljs-number">1</span>));
  <span class="hljs-comment">// AUX_MU_IO에서 값을 읽어오고 return 합니다.</span>
  character = (<span class="hljs-type">char</span>)(AUX_MU_IO);
  <span class="hljs-comment">// &#x27;\r&#x27;를 &#x27;\n&#x27;으로 변환합니다.</span>
  <span class="hljs-keyword">return</span> character == <span class="hljs-string">&#x27;\r&#x27;</span> ? <span class="hljs-string">&#x27;\n&#x27;</span> : character;
}
</code></pre>
<h3><code>uart_puts()</code> : Display a string</h3>
<p>앞에서 만들었던 <code>uart_send()</code>를 사용하여, <code>string</code>의 index를 1씩 더하며 <code>string</code>이 <code>NULL</code>이 될 때까지 <code>uart_send(*string++);</code>을 호출합니다.</p>
<pre><code class="language-c"><span class="hljs-comment">/* Display a string */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">uart_puts</span><span class="hljs-params">(<span class="hljs-type">char</span> *<span class="hljs-built_in">string</span>)</span> {
  <span class="hljs-keyword">while</span> (*<span class="hljs-built_in">string</span>) {
    <span class="hljs-comment">// &#x27;\n&#x27;를 &#x27;\r&#x27;으로 변환합니다.</span>
    <span class="hljs-keyword">if</span> (*<span class="hljs-built_in">string</span> == <span class="hljs-string">&#x27;\n&#x27;</span>)
      uart_send(<span class="hljs-string">&#x27;\r&#x27;</span>);
    uart_send(*<span class="hljs-built_in">string</span>++);
  }
}
</code></pre>
<h3>Source Code</h3>
<p><strong>Makefile :</strong></p>
<pre><code>SRCS = $(wildcard *.c)
OBJS = $(SRCS:.c=.o)
CFLAGS = -Wall -O2 -ffreestanding -nostdinc -nostdlib -nostartfiles

all: clean kernel.bin

boot.o: boot.S
	arm-none-eabi-gcc $(CFLAGS) -c boot.S -o boot.o

%.o: %.c
	arm-none-eabi-gcc $(CFLAGS) -c $&lt; -o $@

kernel.bin: boot.o $(OBJS)
	arm-none-eabi-ld -nostdlib -nostartfiles boot.o $(OBJS) -Map kernel.map -T linker.ld -o kernel.elf
	arm-none-eabi-objcopy kernel.elf -O binary kernel.bin
	arm-none-eabi-objdump -D kernel.elf &gt; kernel.dump

clean:
	rm kernel.elf kernel.bin kernel.dump kernel.map *.o &gt;/dev/null 2&gt;/dev/null || true
</code></pre>
<p><strong>boot.S :</strong></p>
<pre><code>.section &quot;.text.boot&quot;

.global _start

_start:
	bl      main
</code></pre>
<p><strong>gpio.h :</strong></p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MMIO_BASE       0x20000000</span>

<span class="hljs-comment">/* GPIO registers */</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> GPFSEL1         (*(volatile unsigned int*)(MMIO_BASE+0x00200004))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> GPPUD           (*(volatile unsigned int*)(MMIO_BASE+0x00200094))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> GPPUDCLK0       (*(volatile unsigned int*)(MMIO_BASE+0x00200098))</span>

<span class="hljs-comment">/* Auxilary mini UART registers */</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> AUX_ENABLES     (*(volatile unsigned int*)(MMIO_BASE+0x00215004))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> AUX_MU_IO       (*(volatile unsigned int*)(MMIO_BASE+0x00215040))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> AUX_MU_IER      (*(volatile unsigned int*)(MMIO_BASE+0x00215044))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> AUX_MU_IIR      (*(volatile unsigned int*)(MMIO_BASE+0x00215048))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> AUX_MU_LCR      (*(volatile unsigned int*)(MMIO_BASE+0x0021504C))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> AUX_MU_MCR      (*(volatile unsigned int*)(MMIO_BASE+0x00215050))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> AUX_MU_LSR      (*(volatile unsigned int*)(MMIO_BASE+0x00215054))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> AUX_MU_CNTL     (*(volatile unsigned int*)(MMIO_BASE+0x00215060))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> AUX_MU_BAUD     (*(volatile unsigned int*)(MMIO_BASE+0x00215068))</span>
</code></pre>
<p><strong>linker.ld :</strong></p>
<pre><code>SECTIONS
{
    . = 0x8000;
    .text : { KEEP(*(.text.boot)) *(.text .text.* .gnu.linkonce.t*) }
    .rodata : { *(.rodata .rodata.* .gnu.linkonce.r*) }
    PROVIDE(_data = .);
    .data : { *(.data .data.* .gnu.linkonce.d*) }
    .bss (NOLOAD) : {
        . = ALIGN(16);
        __bss_start = .;
        *(.bss .bss.*)
        *(COMMON)
        __bss_end = .;
    }
    _end = .;

   /DISCARD/ : { *(.comment) *(.gnu*) *(.note*) *(.eh_frame*) }
}
__bss_size = (__bss_end - __bss_start)&gt;&gt;3;
</code></pre>
<p><strong>uart.h :</strong></p>
<pre><code class="language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">uart_init</span><span class="hljs-params">()</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">uart_send</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> c)</span>;
<span class="hljs-type">char</span> <span class="hljs-title function_">uart_getc</span><span class="hljs-params">()</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">uart_puts</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span>;
</code></pre>
<p><strong>uart.c :</strong></p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;gpio.h&quot;</span></span>

<span class="hljs-comment">/**
 * initialize UART
 */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">uart_init</span><span class="hljs-params">()</span> {
  <span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> delay;

  AUX_ENABLES |= <span class="hljs-number">1</span>; <span class="hljs-comment">// Mini UART 활성화</span>
  AUX_MU_CNTL = <span class="hljs-number">0</span>;  <span class="hljs-comment">// Tx, Rx 비활성화</span>
  AUX_MU_LCR = <span class="hljs-number">3</span>;   <span class="hljs-comment">// Data size : 8-bit mode</span>
  AUX_MU_MCR = <span class="hljs-number">0</span>;
  AUX_MU_IER = <span class="hljs-number">0</span>;
  AUX_MU_IIR = <span class="hljs-number">0xC1</span>; <span class="hljs-comment">// Interrupts 비활성화</span>
  AUX_MU_BAUD = <span class="hljs-number">270</span>; <span class="hljs-comment">// Baudrate를 115200로 설정</span>

  <span class="hljs-comment">// UART1 GPIO pins setting</span>
  GPFSEL1 = (<span class="hljs-number">2</span> &lt;&lt; <span class="hljs-number">12</span>) | (<span class="hljs-number">2</span> &lt;&lt; <span class="hljs-number">15</span>); <span class="hljs-comment">// GPIO 14, 15핀을 alternate function 5로 설정</span>
  GPPUD = <span class="hljs-number">0</span>;                 <span class="hljs-comment">// GPIO 14, 15핀 활성화</span>
  <span class="hljs-keyword">for</span> (delay = <span class="hljs-number">0</span>; delay &lt; <span class="hljs-number">150</span>; delay++)
    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;nop&quot;</span>)</span>;
  GPPUDCLK0 = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">14</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">15</span>);
  <span class="hljs-keyword">for</span> (delay = <span class="hljs-number">0</span>; delay &lt; <span class="hljs-number">150</span>; delay++)
    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;nop&quot;</span>)</span>;
  GPPUDCLK0 = <span class="hljs-number">0</span>;   <span class="hljs-comment">// Flush GPIO setup</span>
  AUX_MU_CNTL = <span class="hljs-number">3</span>; <span class="hljs-comment">// Tx, Rx 활성화</span>
}

<span class="hljs-comment">/**
 * Send a character
 */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">uart_send</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> data)</span> {
  <span class="hljs-comment">// AUX_MU_LSR의 Transmitter Empty 비트가 &#x27;1&#x27;이 될 때까지 대기합니다.</span>
  <span class="hljs-keyword">do</span> {
    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;nop&quot;</span>)</span>;
  } <span class="hljs-keyword">while</span> (!(AUX_MU_LSR &amp; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>)));
  <span class="hljs-comment">// Buffer에 문자를 기록합니다.</span>
  AUX_MU_IO = data;
}

<span class="hljs-comment">/**
 * Receive a character
 */</span>
<span class="hljs-type">char</span> <span class="hljs-title function_">uart_getc</span><span class="hljs-params">()</span> {
  <span class="hljs-type">char</span> character;
  <span class="hljs-comment">// Buffer에 무엇인가 있을때까지 대기합니다.</span>
  <span class="hljs-keyword">do</span> {
    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;nop&quot;</span>)</span>;
  } <span class="hljs-keyword">while</span> (!(AUX_MU_LSR &amp; <span class="hljs-number">1</span>));
  <span class="hljs-comment">// AUX_MU_IO에서 값을 읽어오고 return 합니다.</span>
  character = (<span class="hljs-type">char</span>)(AUX_MU_IO);
  <span class="hljs-comment">// &#x27;\r&#x27;를 &#x27;\n&#x27;으로 변환합니다.</span>
  <span class="hljs-keyword">return</span> character == <span class="hljs-string">&#x27;\r&#x27;</span> ? <span class="hljs-string">&#x27;\n&#x27;</span> : character;
  ;
}

<span class="hljs-comment">/**
 * Display a string
 */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">uart_puts</span><span class="hljs-params">(<span class="hljs-type">char</span> *<span class="hljs-built_in">string</span>)</span> {
  <span class="hljs-keyword">while</span> (*<span class="hljs-built_in">string</span>) {
    <span class="hljs-comment">// &#x27;\n&#x27;를 &#x27;\r&#x27;으로 변환합니다.</span>
    <span class="hljs-keyword">if</span> (*<span class="hljs-built_in">string</span> == <span class="hljs-string">&#x27;\n&#x27;</span>)
      uart_send(<span class="hljs-string">&#x27;\r&#x27;</span>);
    uart_send(*<span class="hljs-built_in">string</span>++);
  }
}
</code></pre>
<p><strong>main.c :</strong></p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;uart.h&quot;</span></span>

<span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
  <span class="hljs-comment">// UART 초기화</span>
  uart_init();

  <span class="hljs-comment">// &quot;Hello World!&quot;를 UART로 출력</span>
  uart_puts(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);
  uart_puts(<span class="hljs-string">&quot;Raspberry Pi Zero UART\n&quot;</span>);

  <span class="hljs-comment">// UART 입력되는 것을 UART로 출력 (Echo 기능)</span>
  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
    uart_send(uart_getc());
  }
}
</code></pre>
<p><img src="/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/putty.png" alt="Putty"></p>
</div></article></main><footer class="c-cpkrrK"><div class="c-fiqONv">© <!-- -->2022</div><div class="c-bHyrwK"><div class="c-iUFgVP">Kh.</div><div class="c-cshSRb">KyuHyuk Lee</div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"excerpt":" Source Code는 https://github.com/LeeKyuHyuk/Simple-ARM-Operating-System/tree/raspberry-pi-zero/Chapter-5/src 에있습니다. UART(범용 비동기화 송수신기: Universal asynchronous re","url":"/article/simple-arm-operating-system/2019/03/04/Simple-ARM-Operating-System-Chapter-5","frontmatter":{"title":"Chapter 5: UART를 구현해보자!","date":"2019-03-04 23:07:05","category":"Simple-ARM-Operating-System"},"content":"\n\u003e Source Code는 [https://github.com/LeeKyuHyuk/Simple-ARM-Operating-System/tree/raspberry-pi-zero/Chapter-5/src](https://github.com/LeeKyuHyuk/Simple-ARM-Operating-System/tree/raspberry-pi-zero/Chapter-5/src)에있습니다.\n\n\u003e UART(범용 비동기화 송수신기: Universal asynchronous receiver/transmitter)는 병렬 데이터의 형태를직렬 방식으로 전환하여 데이터를 전송하는 컴퓨터 하드웨어의 일종이다. UART는 일반적으로 EIA RS-232, RS-422, RS-485와 같은 통신 표준과 함께 사용한다. [Wikipedia - UART](https://ko.wikipedia.org/wiki/UART)\n\nMini UART를 사용하여 UART를 구현해보도록 하겠습니다.\n\n### `uart_init()` : UART Initialization\n\n1. `AUXENB` Register의 `0`번 비트(Mini UART enable)를 `1`로 설정합니다.  \n   ![AUXENB](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_ENABLES.png)\n\n2. `AUX_MU_CNTL_REG` Register의 모든 비트를 `0`으로 설정합니다. Tx, Rx가 비활성화 됩니다.  \n   ![AUX_MU_CNTL_REG](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_CNTL.png)\n\n3. `AUX_MU_LCR_REG` Register의 `0`번, `1`번 비트를 `1`으로 설정합니다.  \n   `0`번 비트는 8-bit mode를 사용하도록 설정되며, `1`번 비트 또한 같은 이유로 설정되어야 합니다.  \n   **_문서에는 `5`:`1`번 비트가 Reserved라고 표기 되어있지만 이렇게 하지 않으면 정상적인 데이터가 전송되지 않습니다._**  \n   [BCM2835 datasheet errata #14P](https://elinux.org/BCM2835_datasheet_errata#p14)에 BCM2835 Datasheet의 `AUX_MU_LCR_REG`의 틀린 부분이 언급되어 있습니다.  \n   ![AUX_MU_LCR_REG](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_LCR.png)\n\n4. `AUX_MU_MCR_REG` Register의 모든 비트를 `0`으로 설정합니다.  \n   ![AUX_MU_MCR_REG](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_MCR.png)\n\n5. `AUX_MU_IER_REG` Register의 모든 비트를 `0`으로 설정합니다.  \n   ![AUX_MU_IER_REG](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_IER.png)\n\n6. `AUX_MU_IIR_REG` Register의 비트를 `11000001`로 설정합니다.  \n   ![AUX_MU_IIR_REG](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_IIR.png)\n\n- Interrupt Pending[`0`], FIFO Enable[`7`:`6`]\n\n7. `AUX_MU_BAUD` Register를 `270`으로 설정합니다.  \n   ![AUX_MU_BAUD](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_BAUD.png)\n\n- `baudrate = system_clock_freq / 8 * (baudrate_reg + 1)`\n- **`baudrate_reg` 계산 방법:**\n  - `baudrate_reg = (system_clock_freq / 8 * baudrate) - 1`\n  - `baudrate_reg = (250000000 / 8 * 115200) - 1 = 270.267‥ ≈ 270`\n\n8. `GPFSEL1` Register에서 GPIO 14, 15 Pin을 'Alternate function 5'로 설정합니다.  \n   ![Alternative Function Assignments](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/alternative_function_assignments_gpio_14_15.png)  \n   ![GPFSEL1](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/GPFSEL1.png)\n\n9. `GPPUD` Register의 [`1`:`0`]을 `0`으로 설정합니다.  \n   ![GPPUD](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/GPPUD.png)\n\n- Off - Disable Pull-up/down\n\n10. `GPPUDCLK0` Register에서 `14`, `15`번 비트를 `1`로 설정합니다.  \n    (GPIO Pin 14, 15를 Assert Clock on line으로 만듭니다)  \n    ![GPPUDCLK0](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/GPPUDCLK0.png)\n\n11. `GPPUDCLK0` Register를 `0`으로 설정하여, 모든 GPIO Pin을 No Effect로 만듭니다.\n\n\u003e **9번 ~ 11번 과정 설명 :**\n\u003e\n\u003e 1. `GPPUD`에 기록하여 필요한 control signal를 설정합니다.\n\u003e 2. control signal를 설정하기 위해 150 사이클을 기다립니다.\n\u003e 3. `GPPUD`에서 수정한 GPIO의 control signal에 clock을 보내기 위해 `GPPUDCLK0`에서도 해당 GPIO 핀을수정합니다.\n\u003e 4. 150 사이클을 기다립니다.\n\u003e 5. '1'에서 `GPPUD`에 기록했던 GPIO의 설정을 제거합니다.\n\u003e 6. '3'에서 `GPPUDCLK0`에 기록했던 GPIO의 설정을 제거합니다.\n\n12. `AUX_MU_CNTL_REG` Register의 `0`, `1`번 비트를 `1`로 설정하여 Tx, Rx를 활성화 합니다.  \n    ![AUX_MU_CNTL_REG](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_CNTL.png)\n\n```c\n/* initialize UART */\nvoid uart_init() {\n  volatile unsigned char delay;\n\n  AUX_ENABLES |= 1; // Mini UART 활성화\n  AUX_MU_CNTL = 0;  // Tx, Rx 비활성화\n  AUX_MU_LCR = 3;   // Data size : 8-bit mode\n  AUX_MU_MCR = 0;\n  AUX_MU_IER = 0;\n  AUX_MU_IIR = 0xC1; // Interrupts 비활성화\n  AUX_MU_BAUD = 270; // Baudrate를 115200로 설정\n\n  // UART1 GPIO pins setting\n  GPFSEL1 = (2 \u003c\u003c 12) | (2 \u003c\u003c 15); // GPIO 14, 15핀을 alternate function 5로 설정\n  GPPUD = 0;                       // GPIO 14, 15핀 활성화\n  for (delay = 0; delay \u003c 150; delay++)\n    asm volatile(\"nop\");\n  GPPUDCLK0 = (1 \u003c\u003c 14) | (1 \u003c\u003c 15);\n  for (delay = 0; delay \u003c 150; delay++)\n    asm volatile(\"nop\");\n  GPPUDCLK0 = 0;   // Flush GPIO setup\n  AUX_MU_CNTL = 3; // Tx, Rx 활성화\n}\n```\n\n### `uart_send()` : Send a character\n\n1. `AUX_MU_LSR_REG` Register의 `5`번째 비트인 'Transmitter Empty'를 확인합니다. ![AUX_MU_LSR_REG](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_LSR.png)\n\n2. 'Transmitter Empty'가 `1`이면 `AUX_MU_IO_REG`에 Data를 넣어 Buffer에 문자를 기록합니다.  \n   ![AUX_MU_IO_REG](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_IO.png)\n\n```c\n/* Send a character */\nvoid uart_send(unsigned int data) {\n  // AUX_MU_LSR의 Transmitter Empty 비트가 '1'이 될 때까지 대기합니다.\n  do {\n    asm volatile(\"nop\");\n  } while (!(AUX_MU_LSR \u0026 (1\u003c\u003c5)));\n  // Buffer에 문자를 기록합니다.\n  AUX_MU_IO = data;\n}\n```\n\n### `uart_getc()` : Receive a character\n\n1. `AUX_MU_LSR_REG` Register의 `1`번째 비트인 'Data ready'를 확인합니다. ![AUX_MU_LSR_REG](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_LSR.png)\n\n2. 'Data ready'가 `1`이면 `AUX_MU_IO_REG`의 Data를 읽어 반환합니다.  \n   ![AUX_MU_IO_REG](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/AUX_MU_IO.png)\n\n```c\n/*  Receive a character */\nchar uart_getc() {\n  char character;\n  // Buffer에 무엇인가 있을때까지 대기합니다.\n  do {\n    asm volatile(\"nop\");\n  } while (!(AUX_MU_LSR \u0026 1));\n  // AUX_MU_IO에서 값을 읽어오고 return 합니다.\n  character = (char)(AUX_MU_IO);\n  // '\\r'를 '\\n'으로 변환합니다.\n  return character == '\\r' ? '\\n' : character;\n}\n```\n\n### `uart_puts()` : Display a string\n\n앞에서 만들었던 `uart_send()`를 사용하여, `string`의 index를 1씩 더하며 `string`이 `NULL`이 될 때까지 `uart_send(*string++);`을 호출합니다.\n\n```c\n/* Display a string */\nvoid uart_puts(char *string) {\n  while (*string) {\n    // '\\n'를 '\\r'으로 변환합니다.\n    if (*string == '\\n')\n      uart_send('\\r');\n    uart_send(*string++);\n  }\n}\n```\n\n### Source Code\n\n**Makefile :**\n\n```\nSRCS = $(wildcard *.c)\nOBJS = $(SRCS:.c=.o)\nCFLAGS = -Wall -O2 -ffreestanding -nostdinc -nostdlib -nostartfiles\n\nall: clean kernel.bin\n\nboot.o: boot.S\n\tarm-none-eabi-gcc $(CFLAGS) -c boot.S -o boot.o\n\n%.o: %.c\n\tarm-none-eabi-gcc $(CFLAGS) -c $\u003c -o $@\n\nkernel.bin: boot.o $(OBJS)\n\tarm-none-eabi-ld -nostdlib -nostartfiles boot.o $(OBJS) -Map kernel.map -T linker.ld -o kernel.elf\n\tarm-none-eabi-objcopy kernel.elf -O binary kernel.bin\n\tarm-none-eabi-objdump -D kernel.elf \u003e kernel.dump\n\nclean:\n\trm kernel.elf kernel.bin kernel.dump kernel.map *.o \u003e/dev/null 2\u003e/dev/null || true\n```\n\n**boot.S :**\n\n```\n.section \".text.boot\"\n\n.global _start\n\n_start:\n\tbl      main\n```\n\n**gpio.h :**\n\n```c\n#define MMIO_BASE       0x20000000\n\n/* GPIO registers */\n#define GPFSEL1         (*(volatile unsigned int*)(MMIO_BASE+0x00200004))\n#define GPPUD           (*(volatile unsigned int*)(MMIO_BASE+0x00200094))\n#define GPPUDCLK0       (*(volatile unsigned int*)(MMIO_BASE+0x00200098))\n\n/* Auxilary mini UART registers */\n#define AUX_ENABLES     (*(volatile unsigned int*)(MMIO_BASE+0x00215004))\n#define AUX_MU_IO       (*(volatile unsigned int*)(MMIO_BASE+0x00215040))\n#define AUX_MU_IER      (*(volatile unsigned int*)(MMIO_BASE+0x00215044))\n#define AUX_MU_IIR      (*(volatile unsigned int*)(MMIO_BASE+0x00215048))\n#define AUX_MU_LCR      (*(volatile unsigned int*)(MMIO_BASE+0x0021504C))\n#define AUX_MU_MCR      (*(volatile unsigned int*)(MMIO_BASE+0x00215050))\n#define AUX_MU_LSR      (*(volatile unsigned int*)(MMIO_BASE+0x00215054))\n#define AUX_MU_CNTL     (*(volatile unsigned int*)(MMIO_BASE+0x00215060))\n#define AUX_MU_BAUD     (*(volatile unsigned int*)(MMIO_BASE+0x00215068))\n```\n\n**linker.ld :**\n\n```\nSECTIONS\n{\n    . = 0x8000;\n    .text : { KEEP(*(.text.boot)) *(.text .text.* .gnu.linkonce.t*) }\n    .rodata : { *(.rodata .rodata.* .gnu.linkonce.r*) }\n    PROVIDE(_data = .);\n    .data : { *(.data .data.* .gnu.linkonce.d*) }\n    .bss (NOLOAD) : {\n        . = ALIGN(16);\n        __bss_start = .;\n        *(.bss .bss.*)\n        *(COMMON)\n        __bss_end = .;\n    }\n    _end = .;\n\n   /DISCARD/ : { *(.comment) *(.gnu*) *(.note*) *(.eh_frame*) }\n}\n__bss_size = (__bss_end - __bss_start)\u003e\u003e3;\n```\n\n**uart.h :**\n\n```c\nvoid uart_init();\nvoid uart_send(unsigned int c);\nchar uart_getc();\nvoid uart_puts(char *s);\n```\n\n**uart.c :**\n\n```c\n#include \"gpio.h\"\n\n/**\n * initialize UART\n */\nvoid uart_init() {\n  volatile unsigned char delay;\n\n  AUX_ENABLES |= 1; // Mini UART 활성화\n  AUX_MU_CNTL = 0;  // Tx, Rx 비활성화\n  AUX_MU_LCR = 3;   // Data size : 8-bit mode\n  AUX_MU_MCR = 0;\n  AUX_MU_IER = 0;\n  AUX_MU_IIR = 0xC1; // Interrupts 비활성화\n  AUX_MU_BAUD = 270; // Baudrate를 115200로 설정\n\n  // UART1 GPIO pins setting\n  GPFSEL1 = (2 \u003c\u003c 12) | (2 \u003c\u003c 15); // GPIO 14, 15핀을 alternate function 5로 설정\n  GPPUD = 0;                 // GPIO 14, 15핀 활성화\n  for (delay = 0; delay \u003c 150; delay++)\n    asm volatile(\"nop\");\n  GPPUDCLK0 = (1 \u003c\u003c 14) | (1 \u003c\u003c 15);\n  for (delay = 0; delay \u003c 150; delay++)\n    asm volatile(\"nop\");\n  GPPUDCLK0 = 0;   // Flush GPIO setup\n  AUX_MU_CNTL = 3; // Tx, Rx 활성화\n}\n\n/**\n * Send a character\n */\nvoid uart_send(unsigned int data) {\n  // AUX_MU_LSR의 Transmitter Empty 비트가 '1'이 될 때까지 대기합니다.\n  do {\n    asm volatile(\"nop\");\n  } while (!(AUX_MU_LSR \u0026 (1 \u003c\u003c 5)));\n  // Buffer에 문자를 기록합니다.\n  AUX_MU_IO = data;\n}\n\n/**\n * Receive a character\n */\nchar uart_getc() {\n  char character;\n  // Buffer에 무엇인가 있을때까지 대기합니다.\n  do {\n    asm volatile(\"nop\");\n  } while (!(AUX_MU_LSR \u0026 1));\n  // AUX_MU_IO에서 값을 읽어오고 return 합니다.\n  character = (char)(AUX_MU_IO);\n  // '\\r'를 '\\n'으로 변환합니다.\n  return character == '\\r' ? '\\n' : character;\n  ;\n}\n\n/**\n * Display a string\n */\nvoid uart_puts(char *string) {\n  while (*string) {\n    // '\\n'를 '\\r'으로 변환합니다.\n    if (*string == '\\n')\n      uart_send('\\r');\n    uart_send(*string++);\n  }\n}\n```\n\n**main.c :**\n\n```c\n#include \"uart.h\"\n\nvoid main() {\n  // UART 초기화\n  uart_init();\n\n  // \"Hello World!\"를 UART로 출력\n  uart_puts(\"Hello World!\\n\");\n  uart_puts(\"Raspberry Pi Zero UART\\n\");\n\n  // UART 입력되는 것을 UART로 출력 (Echo 기능)\n  while (1) {\n    uart_send(uart_getc());\n  }\n}\n```\n\n![Putty](/assets/image/2019-03-04-Simple-ARM-Operating-System-Chapter-5/putty.png)\n"},"__N_SSG":true},"page":"/article/[category]/[year]/[month]/[day]/[slug]","query":{"category":"simple-arm-operating-system","year":"2019","month":"03","day":"04","slug":"Simple-ARM-Operating-System-Chapter-5"},"buildId":"ZyJ0P4wUHhxVoXujUtGq7","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>