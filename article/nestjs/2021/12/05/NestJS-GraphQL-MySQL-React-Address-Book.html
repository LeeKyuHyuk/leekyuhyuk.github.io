<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><style id="stitches"></style><link rel="preload" href="/_next/static/css/98b299b94b0a7962.css" as="style"/><link rel="stylesheet" href="/_next/static/css/98b299b94b0a7962.css" data-n-g=""/><link rel="preload" href="/_next/static/css/5c3da54741072322.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5c3da54741072322.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-dea678fb5840c50f.js" defer=""></script><script src="/_next/static/chunks/framework-64ad27b21261a9ce.js" defer=""></script><script src="/_next/static/chunks/main-f2f237ba7e9012fc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9b6890f28bc766f1.js" defer=""></script><script src="/_next/static/chunks/803-9fe1c131242daf24.js" defer=""></script><script src="/_next/static/chunks/785-d1ab2e5b6dacd475.js" defer=""></script><script src="/_next/static/chunks/pages/article/%5Bcategory%5D/%5Byear%5D/%5Bmonth%5D/%5Bday%5D/%5Bslug%5D-6501b82d330bbee5.js" defer=""></script><script src="/_next/static/dFiaKGJXnX9ZfXI4gZrP9/_buildManifest.js" defer=""></script><script src="/_next/static/dFiaKGJXnX9ZfXI4gZrP9/_ssgManifest.js" defer=""></script></head><body><div id="__next"></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"excerpt":" MariaDB Installation MariaDB는 Oracle 소유의 불확실한 MySQL의 라이선스 상태에 반발하여 만들어졌습니다. MySQL의 소스코드를 Fork하여 만들어졌으므로 사용방법과 구조가 MySQL과 동일합니다. MySQL은 상업용으로 사용하면 유료이지만, MariaD","url":"/article/nestjs/2021/12/05/NestJS-GraphQL-MySQL-React-Address-Book","frontmatter":{"title":"NestJS, GraphQL, React을 사용하여 주소록 구현 하기","date":"2021-12-05 15:21:11","category":"NestJS"},"content":"\r\n# MariaDB Installation\r\n\r\n\u003e MariaDB는 Oracle 소유의 불확실한 MySQL의 라이선스 상태에 반발하여 만들어졌습니다. MySQL의 소스코드를 Fork하여 만들어졌으므로 사용방법과 구조가 MySQL과 동일합니다.  \r\n\u003e MySQL은 상업용으로 사용하면 유료이지만, MariaDB는 상업용으로 사용해도 비용을 지불하지 않아도 되는장점이 있습니다.\r\n\r\n[Download MariaDB Server](https://mariadb.org/download/)에 접속하여 MariaDB Server 설치 파일을 다운로드하고 설치합니다.  \r\n![Download MariaDB Server](/assets/image/2021-12-05-NestJS-GraphQL-MySQL-React-Address-Book/2021-12-05-NestJS-GraphQL-MySQL-React-Address-Book_1.png)\r\n\r\nMariaDB에 `address_book` 데이터베이스와 `contact` 테이블을 추가합니다.\r\n\r\n```bash\r\nCREATE DATABASE address_book default CHARACTER SET UTF8;\r\nUSE `address_book`;\r\nCREATE TABLE `contact` (\r\n\t`id` CHAR(50) NOT NULL,\r\n\t`name` CHAR(50) NOT NULL,\r\n\t`number` CHAR(50) NULL DEFAULT NULL,\r\n\t`email` CHAR(50) NULL DEFAULT NULL\r\n)\r\nCOLLATE='utf8mb3_general_ci';\r\n```\r\n\r\n# Create Address Book Project\r\n\r\nNest.js + GraphQL + React.js 조합의 프로젝트를 생성할 것입니다.  \r\nAddress Book 프로젝트에 Backend와 Frontend 프로젝트를 포함시켜 관리할 것입니다.\r\n\r\n우선 아래와 같이 `address-book` 프로젝트를 생성합니다.\r\n\r\n```bash\r\nmkdir address-book\r\ncd address-book\r\nnpm init\r\n```\r\n\r\n`npm`의 [workspaces](https://docs.npmjs.com/cli/v8/using-npm/workspaces)를 사용하여 `backend`와 `frontend` 프로젝트를 추가합니다.\r\n\r\n```bash\r\nnpm init -w backend\r\nnpm init -w frontend\r\n```\r\n\r\n위 명령어로 `backend`와 `frontend` 프로젝트를 추가하면 아래와 같은 구조로 되어있을 것입니다.\r\n\r\n```\r\n├── backend\r\n│   └── package.json\r\n├── frontend\r\n│   └── package.json\r\n└── package.json\r\n```\r\n\r\n이제 `backend` 프로젝트를 설정해 봅시다.\r\n\r\n# Configuration Backend Project\r\n\r\nBackend를 Nest.js와 GraphQL로 구성하기 위해 아래의 패키지를 설치합니다.\r\n\r\n```bash\r\nnpm install --save @nestjs/axios @nestjs/common @nestjs/core @nestjs/platform-express reflect-metadata rxjs @nestjs/graphql apollo-server-express graphql @nestjs/typeorm typeorm mysql2 -w backend\r\nnpm install --save-dev @nestjs/cli @nestjs/schematics @types/express @types/node ts-loader ts-node tsconfig-paths typescript cross-env -w backend\r\n```\r\n\r\n`backend/package.json`에 `\"main\": \"index.js\"` 행을 삭제하고 아래 내용을 추가합니다.\r\n\r\n```json\r\n\"private\": true,\r\n\"scripts\": {\r\n    \"build\": \"nest build\",\r\n    \"start\": \"nest start\",\r\n    \"start:dev\": \"cross-env NODE_ENV=development nest start --watch\",\r\n    \"start:debug\": \"cross-env NODE_ENV=development nest start --debug --watch\",\r\n    \"start:prod\": \"npm run build \u0026\u0026 NODE_ENV=production node dist/main\"\r\n},\r\n```\r\n\r\n`backend/nest-cli.json`, `backend/tsconfig.build.json`, `backend/tsconfig.json`을 아래와 같이 작성하여 저장합니다.\r\n\r\n**`backend/nest-cli.json` :**\r\n\r\n```json\r\n{\r\n  \"collection\": \"@nestjs/schematics\",\r\n  \"sourceRoot\": \"src\"\r\n}\r\n```\r\n\r\n**`backend/tsconfig.build.json` :**\r\n\r\n```json\r\n{\r\n  \"extends\": \"./tsconfig.json\",\r\n  \"exclude\": [\"node_modules\", \"dist\", \"test\", \"**/*spec.ts\"]\r\n}\r\n```\r\n\r\n**`backend/tsconfig.json` :**\r\n\r\n```json\r\n{\r\n  \"compilerOptions\": {\r\n    \"module\": \"commonjs\",\r\n    \"declaration\": true,\r\n    \"removeComments\": true,\r\n    \"emitDecoratorMetadata\": true,\r\n    \"experimentalDecorators\": true,\r\n    \"allowSyntheticDefaultImports\": true,\r\n    \"target\": \"es2017\",\r\n    \"sourceMap\": true,\r\n    \"outDir\": \"./dist\",\r\n    \"baseUrl\": \"./\",\r\n    \"incremental\": true,\r\n    \"skipLibCheck\": true\r\n  }\r\n}\r\n```\r\n\r\n`backend/src` 폴더를 만들고 `backend/src/app.module.ts`와 `backend/src/main.ts`를 생성합니다.\r\n\r\n**`backend/src/app.module.ts` :**\r\n\r\n```typescript\r\nimport { Module } from '@nestjs/common';\r\nimport { GraphQLModule } from '@nestjs/graphql';\r\nimport { TypeOrmModule } from '@nestjs/typeorm';\r\n\r\n@Module({\r\n  imports: [\r\n    TypeOrmModule.forRoot(),\r\n    GraphQLModule.forRoot({\r\n      typePaths: ['./**/*.graphql'],\r\n    }),\r\n  ],\r\n})\r\nexport class AppModule {}\r\n```\r\n\r\n**`backend/src/main.ts` :**\r\n\r\n```typescript\r\nimport { NestFactory } from '@nestjs/core';\r\nimport { AppModule } from './app.module';\r\n\r\nasync function bootstrap() {\r\n  const app = await NestFactory.create(AppModule);\r\n  await app.listen(8081);\r\n}\r\nbootstrap();\r\n```\r\n\r\nMySQL과 연동하기 위해 `ormconfig.json`를 작성합니다.  \r\n\u003cspan style=\"color:red;\"\u003eBackend 프로젝트에 생성하지 않고, Address Book 프로젝트에 생성합니다 .\u003c/span\u003e\r\n\r\n**`ormconfig.json` :**\r\n\r\n```json\r\n{\r\n  \"type\": \"mysql\",\r\n  \"host\": \"localhost\",\r\n  \"port\": 3306,\r\n  \"username\": \"root\",\r\n  \"password\": \"root\",\r\n  \"database\": \"address_book\",\r\n  \"entities\": [\"dist/**/*.entity{.ts,.js}\"]\r\n}\r\n```\r\n\r\n# GraphQL Schema와 Query, Mutation 만들기\r\n\r\nSchema는 아래와 같이 정의할 수 있습니다. 간단하게 주소록에 필요한 Schema를 작성해 보겠습니다.  \r\n`backend/graphql` 폴더를 생성하고 `contact.graphql` 파일을 생성합니다.\r\n\r\n**`backend/graphql/contact.graphql` :**\r\n\r\n```graphql\r\ntype Contact {\r\n  id: String!\r\n  name: String!\r\n  number: String\r\n  email: String\r\n}\r\n\r\ninput ContactInput {\r\n  name: String!\r\n  number: String\r\n  email: String\r\n}\r\n\r\ntype ContactResponse {\r\n  result: String!\r\n  msg: String!\r\n}\r\n\r\ntype Query {\r\n  getAllContact: [Contact]\r\n  getContact(id: String!): Contact\r\n}\r\n\r\ntype Mutation {\r\n  addContact(contact: ContactInput!): ContactResponse\r\n  removeContact(id: String!): ContactResponse\r\n}\r\n```\r\n\r\n# Resolver 만들기\r\n\r\n위에서 정의한 GraphQL Schema를 바탕으로 Type를 만들어줍니다.  \r\n`backend/src/types` 폴더를 생성하고 `contact.ts` 파일을 생성합니다.\r\n\r\n```typescript\r\nexport type Contact = {\r\n  id: string;\r\n  name: string;\r\n  number?: string;\r\n  email?: string;\r\n};\r\n\r\nexport type ContactInput = {\r\n  name: string;\r\n  number?: string;\r\n  email?: string;\r\n};\r\n\r\nexport type ContactResponse = {\r\n  result: string;\r\n  msg: string;\r\n};\r\n```\r\n\r\nTypeORM을 사용하여 Repository Design Pattern을 정의합니다. 아래와 같이 `Contact` Entity를 정의합니다 .\r\n\r\n**`backend/src/repository/contact.entity.ts` :**\r\n\r\n```typescript\r\nimport { Entity, Column, PrimaryGeneratedColumn } from 'typeorm';\r\n\r\n@Entity()\r\nexport class Contact {\r\n  @PrimaryGeneratedColumn('uuid')\r\n  id?: string;\r\n\r\n  @Column()\r\n  name: string;\r\n\r\n  @Column()\r\n  number?: string;\r\n\r\n  @Column()\r\n  email?: string;\r\n}\r\n```\r\n\r\n`backend/src/models` 폴더를 만들고, `contact.service.ts`, `contact.resolver.ts`, `contact.module.ts`를 작성합니다.\r\n\r\n**`backend/src/models/contact.service.ts` :**\r\n\r\n```typescript\r\nimport { Injectable } from '@nestjs/common';\r\nimport { InjectRepository } from '@nestjs/typeorm';\r\nimport { Contact } from '../repository/contact.entity';\r\nimport { Repository } from 'typeorm';\r\n\r\n@Injectable()\r\nexport class ContactService {\r\n  constructor(\r\n    @InjectRepository(Contact)\r\n    private ContactRepository: Repository\u003cContact\u003e\r\n  ) {}\r\n\r\n  findAll(): Promise\u003cContact[]\u003e {\r\n    return this.ContactRepository.find();\r\n  }\r\n\r\n  findOne(id: string): Promise\u003cContact\u003e {\r\n    return this.ContactRepository.findOne(id);\r\n  }\r\n\r\n  async add(Contact: Contact): Promise\u003cvoid\u003e {\r\n    await this.ContactRepository.save(Contact);\r\n  }\r\n\r\n  async remove(id: string): Promise\u003cvoid\u003e {\r\n    await this.ContactRepository.delete(id);\r\n  }\r\n}\r\n```\r\n\r\n**`backend/src/models/contact.resolver.ts` :**\r\n\r\n```typescript\r\nimport { Args, Mutation, Query, Resolver } from '@nestjs/graphql';\r\nimport { Contact } from 'src/repository/contact.entity';\r\nimport { ContactInput, ContactResponse } from '../types/Contact';\r\nimport { ContactService } from './contact.service';\r\n\r\n@Resolver('Contact')\r\nexport class ContactResolver {\r\n  constructor(private contactService: ContactService) {}\r\n\r\n  @Query()\r\n  async getAllContact(): Promise\u003cContact[]\u003e {\r\n    return await this.contactService.findAll();\r\n  }\r\n\r\n  @Query()\r\n  async getContact(@Args('id') id: string): Promise\u003cContact\u003e {\r\n    const result = await this.contactService.findOne(id);\r\n    if (result) return result;\r\n    return {\r\n      id: 'Error',\r\n      name: 'There is no information about that Contact ID.',\r\n    };\r\n  }\r\n\r\n  @Mutation()\r\n  async addContact(@Args('contact') contact: ContactInput): Promise\u003cContactResponse\u003e {\r\n    try {\r\n      await this.contactService.add(contact);\r\n      return {\r\n        result: 'Success',\r\n        msg: 'Added successfully.',\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        result: 'Error',\r\n        msg: error,\r\n      };\r\n    }\r\n  }\r\n\r\n  @Mutation()\r\n  async removeContact(@Args('id') id: string): Promise\u003cContactResponse\u003e {\r\n    try {\r\n      await this.contactService.remove(id);\r\n      return {\r\n        result: 'Success',\r\n        msg: 'Removed successfully.',\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        result: 'Error',\r\n        msg: error,\r\n      };\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n**`backend/src/models/contact.module.ts` :**\r\n\r\n```typescript\r\nimport { Module } from '@nestjs/common';\r\nimport { TypeOrmModule } from '@nestjs/typeorm';\r\nimport { Contact } from '../repository/contact.entity';\r\nimport { ContactResolver } from './contact.resolver';\r\nimport { ContactService } from './contact.service';\r\n\r\n@Module({\r\n  imports: [TypeOrmModule.forFeature([Contact])],\r\n  providers: [ContactResolver, ContactService],\r\n})\r\nexport class ContactModule {}\r\n```\r\n\r\n`backend/src/app.module.ts`에 `ContactModule`를 추가합니다.\r\n\r\n**`backend/src/models/app.module.ts` :**\r\n\r\n```typescript\r\nimport { Module } from '@nestjs/common';\r\nimport { GraphQLModule } from '@nestjs/graphql';\r\nimport { TypeOrmModule } from '@nestjs/typeorm';\r\nimport { ContactModule } from './models/contact.module';\r\n\r\n@Module({\r\n  imports: [\r\n    TypeOrmModule.forRoot(),\r\n    GraphQLModule.forRoot({\r\n      typePaths: ['./**/*.graphql'],\r\n    }),\r\n    ContactModule,\r\n  ],\r\n})\r\nexport class AppModule {}\r\n```\r\n\r\n# GraphQL Playground\r\n\r\nGraphQL Playground를 통하여 원하는 대로 동작하는지 확인을 해보겠습니다.\r\n\r\n```bash\r\nnpm run start:dev --workspace=backend\r\n```\r\n\r\n위의 명령어로 Nest.js Dev Server를 실행하고, [http://localhost:8081/graphql](http://localhost:8081/graphql)에 접속합니다.  \r\n접속하면 아래와 같이 우리가 구현한 Query와 Mutation이 Docs에 출력되는 것을 확인할 수 있습니다.  \r\n![GraphQL Playground](/assets/image/2021-12-05-NestJS-GraphQL-MySQL-React-Address-Book/2021-12-05-NestJS-GraphQL-MySQL-React-Address-Book_2.png)\r\n\r\n아래와 같이 Mutation을 작성하여 요청해봅시다.\r\n\r\n```graphql\r\nmutation {\r\n  addContact(contact: { name: \"이규혁\", number: \"+82 10-1234-5678\", email: \"lee@kyuhyuk.kr\" }) {\r\n    result\r\n    msg\r\n  }\r\n}\r\n```\r\n\r\n아래와 같이 성공적으로 추가되었다는 메세지가 출력됩니다.  \r\n![addContact Mutation](/assets/image/2021-12-05-NestJS-GraphQL-MySQL-React-Address-Book/2021-12-05-NestJS-GraphQL-MySQL-React-Address-Book_3.png)\r\n\r\n이제 `getAllContact` Query를 사용하여 추가된 주소록을 확인해 봅시다.\r\n\r\n```graphql\r\nquery {\r\n  getAllContact {\r\n    id\r\n    name\r\n    number\r\n    email\r\n  }\r\n}\r\n```\r\n\r\n![getAllContact Query](/assets/image/2021-12-05-NestJS-GraphQL-MySQL-React-Address-Book/2021-12-05-NestJS-GraphQL-MySQL-React-Address-Book_4.png)\r\n\r\n위에 출력된 `id`를 사용하여 `getContact` Query를 테스트해봅시다.  \r\n![getContact Query](/assets/image/2021-12-05-NestJS-GraphQL-MySQL-React-Address-Book/2021-12-05-NestJS-GraphQL-MySQL-React-Address-Book_5.png)\r\n\r\n정상적으로 작동되는 것을 확인했으니, 마지막으로 `removeContact` Mutation을 사용하여 정상적으로 삭제되는지도 확인해 봅시다.  \r\n![removeContact Mutation](/assets/image/2021-12-05-NestJS-GraphQL-MySQL-React-Address-Book/2021-12-05-NestJS-GraphQL-MySQL-React-Address-Book_6.png)\r\n\r\n`getAllContact` Query를 사용하여 주소록을 확인해 봅시다.  \r\n![getAllContact Query](/assets/image/2021-12-05-NestJS-GraphQL-MySQL-React-Address-Book/2021-12-05-NestJS-GraphQL-MySQL-React-Address-Book_7.png)\r\n\r\n모두 정상적으로 동작되는 것을 확인하였으니, 다음 단계인 React를 사용하여 Frontend를 구현해 봅시다.\r\n\r\n# Configuration Frontend Project\r\n\r\n```bash\r\nnpm install --save @apollo/client graphql@15.7.2 react react-dom react-router react-router-dom -w frontend\r\nnpm install --save-dev @types/react @types/react-dom @types/react-router @types/react-router-dom @types/webpack apollo apollo-language-server clean-webpack-plugin cross-env css-loader file-loader html-webpack-plugin style-loader ts-loader typescript webpack webpack-cli webpack-dev-server -w frontend\r\n```\r\n\r\n`frontend/package.json`에 `\"main\": \"index.js\"` 행을 삭제하고 아래 내용을 추가합니다.\r\n\r\n```json\r\n\"private\": true,\r\n\"scripts\": {\r\n  \"dev\": \"cross-env NODE_ENV=development webpack serve --progress\",\r\n  \"build\": \"cross-env NODE_ENV=production webpack --progress\",\r\n  \"apollo:codegen\": \"apollo client:codegen src/types --target=typescript --outputFlat\"\r\n},\r\n```\r\n\r\n`frontend/apollo.config.js`, `frontend/tsconfig.json`, `frontend/webpack.config.js`을 아래와 같이 작성하여 저장합니다.\r\n\r\n**`frontend/apollo.config.js` :**\r\n\r\n```javascript\r\nmodule.exports = {\r\n  client: {\r\n    service: {\r\n      name: 'My GraphQL Server',\r\n      url: 'http://localhost:8081/graphql',\r\n      // Optional disable SSL validation check\r\n      skipSSLValidation: true,\r\n    },\r\n    includes: ['./src/**/*.tsx', './src/**/*.ts'],\r\n    tagName: 'gql',\r\n  },\r\n};\r\n```\r\n\r\n**`frontend/tsconfig.json` :**\r\n\r\n```json\r\n{\r\n  \"compilerOptions\": {\r\n    \"outDir\": \"./dist\",\r\n    \"target\": \"es5\",\r\n    \"module\": \"esnext\",\r\n    \"jsx\": \"react\",\r\n    \"noImplicitAny\": true,\r\n    \"allowSyntheticDefaultImports\": true,\r\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\r\n    \"allowJs\": true,\r\n    \"skipLibCheck\": true,\r\n    \"esModuleInterop\": true,\r\n    \"strict\": true,\r\n    \"forceConsistentCasingInFileNames\": true,\r\n    \"moduleResolution\": \"node\",\r\n    \"resolveJsonModule\": true,\r\n    \"isolatedModules\": false\r\n  },\r\n  \"include\": [\"src/**/*\"]\r\n}\r\n```\r\n\r\n**`frontend/webpack.config.js` :**\r\n\r\n```javascript\r\nconst path = require('path');\r\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\r\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\r\n\r\nconst mode = process.env.NODE_ENV || 'development';\r\n\r\nmodule.exports = {\r\n  mode,\r\n  devServer: {\r\n    historyApiFallback: true,\r\n    port: 8080,\r\n  },\r\n  entry: {\r\n    app: path.join(__dirname, 'src', 'index.tsx'),\r\n  },\r\n  output: {\r\n    filename: '[name].js',\r\n    path: path.resolve(__dirname, 'dist'),\r\n    publicPath: '/',\r\n  },\r\n  resolve: {\r\n    extensions: ['.ts', '.tsx', '.js'],\r\n  },\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.(ts|tsx)$/,\r\n        use: 'ts-loader',\r\n        exclude: /node_modules/,\r\n      },\r\n      {\r\n        test: /\\.(scss|css)$/,\r\n        use: ['style-loader', 'css-loader'],\r\n      },\r\n      {\r\n        test: /\\.(jpg|png)$/,\r\n        use: 'file-loader?name=assets/[name].[ext]',\r\n      },\r\n    ],\r\n  },\r\n  plugins: [\r\n    new HtmlWebpackPlugin({\r\n      template: './src/index.html',\r\n      templateParameters: {\r\n        env: process.env.NODE_ENV === 'production' ? '' : 'development',\r\n      },\r\n      minify:\r\n        process.env.NODE_ENV === 'production'\r\n          ? {\r\n              collapseWhitespace: true,\r\n              removeComments: true,\r\n            }\r\n          : false,\r\n    }),\r\n    new CleanWebpackPlugin(),\r\n  ],\r\n};\r\n```\r\n\r\n`frontend/src` 폴더를 생성하고, `index.html`을 아래와 같이 작성합니다.\r\n\r\n**`frontend/src/index.html` :**\r\n\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"ko\"\u003e\r\n  \u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\" /\u003e\r\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e\r\n    \u003cmeta property=\"og:type\" content=\"website\" /\u003e\r\n    \u003ctitle\u003eAddress Book\u003c/title\u003e\r\n  \u003c/head\u003e\r\n  \u003cbody\u003e\r\n    \u003cdiv id=\"root\"\u003e\u003c/div\u003e\r\n  \u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n# GraphQL API의 Type 받아오기\r\n\r\n`frontend/src/GraphQL` 폴더를 만들고, `Contact.ts`를 아래와 같이 작성합니다.  \r\n`frontend/src/GraphQL/Contact.ts`에는 Frontend에서 사용하는 GraphQL Query, Mutation가 정의됩니다.\r\n\r\n**`frontend/src/GraphQL/Contact.ts` :**\r\n\r\n```typescript\r\nimport { gql } from '@apollo/client';\r\n\r\nexport const GET_ALL_CONTACT = gql`\r\n  query GetAllContact {\r\n    getAllContact {\r\n      id\r\n      name\r\n      number\r\n      email\r\n    }\r\n  }\r\n`;\r\n\r\nexport const GET_CONTACT = gql`\r\n  query GetContact($id: String!) {\r\n    getContact(id: $id) {\r\n      name\r\n      number\r\n      email\r\n    }\r\n  }\r\n`;\r\n\r\nexport const ADD_CONTACT = gql`\r\n  mutation AddContact($contact: ContactInput!) {\r\n    addContact(contact: $contact) {\r\n      result\r\n      msg\r\n    }\r\n  }\r\n`;\r\n\r\nexport const REMOVE_CONTACT = gql`\r\n  mutation RemoveContact($id: String!) {\r\n    removeContact(id: $id) {\r\n      result\r\n      msg\r\n    }\r\n  }\r\n`;\r\n```\r\n\r\n사용할 Query와 Mutation을 모두 작성했다면, 아래 명령을 실행하여 GraphQL Type을 생성합니다.\r\n\r\n```bash\r\nnpm run apollo:codegen --workspace=frontend\r\n```\r\n\r\n\u003cspan style=\"color:red;\"\u003e2021년 12월 5일 기준으로 아래와 같은 오류가 발생하고 있습니다.\u003c/span\u003e  \r\n![apollo:codegen Error](/assets/image/2021-12-05-NestJS-GraphQL-MySQL-React-Address-Book/2021-12-05-NestJS-GraphQL-MySQL-React-Address-Book_8.png)\r\n\r\n`node_modules/apollo-language-server/node_modules/graphql` 폴더를 삭제하면 아래와 같이 정상적으로 생성됩니다.  \r\n![apollo:codegen](/assets/image/2021-12-05-NestJS-GraphQL-MySQL-React-Address-Book/2021-12-05-NestJS-GraphQL-MySQL-React-Address-Book_9.png)\r\n\r\n# List, Add, Detail 컴포넌트 만들기\r\n\r\n주소록 목록을 보여주는 `frontend/src/List.tsx`를 간단하게 만들어봅시다.\r\n\r\n**`frontend/src/List.tsx` :**\r\n\r\n```typescript\r\nimport { useQuery } from '@apollo/client';\r\nimport React from 'react';\r\nimport { Link } from 'react-router-dom';\r\nimport { GET_ALL_CONTACT } from './GraphQL/Contact';\r\nimport { GetAllContact } from './types/GetAllContact';\r\n\r\nconst List = () =\u003e {\r\n  const { loading, error, data } = useQuery\u003cGetAllContact\u003e(GET_ALL_CONTACT);\r\n\r\n  if (loading) return \u003cp\u003eLoading...\u003c/p\u003e;\r\n  if (error) return \u003cp\u003e{error.message}\u003c/p\u003e;\r\n\r\n  return (\r\n    \u003c\u003e\r\n      \u003ch1\u003eAddress Book :\u003c/h1\u003e\r\n      \u003cLink to=\"/add\"\u003e\r\n        \u003cbutton\u003eAdd\u003c/button\u003e\r\n      \u003c/Link\u003e\r\n      \u003cul\u003e\r\n        {data?.getAllContact?.map((contact) =\u003e (\r\n          \u003cli key={contact?.id}\u003e\r\n            \u003ca href={`/detail/${contact?.id}`}\u003e{contact?.name}\u003c/a\u003e\r\n          \u003c/li\u003e\r\n        ))}\r\n      \u003c/ul\u003e\r\n    \u003c/\u003e\r\n  );\r\n};\r\n\r\nexport default List;\r\n```\r\n\r\n주소록을 추가하는 `frontend/src/Add.tsx`도 아래와 같이 만들어봅시다.\r\n\r\n**`frontend/src/Add.tsx` :**\r\n\r\n```typescript\r\nimport { useMutation } from '@apollo/client';\r\nimport React from 'react';\r\nimport { ADD_CONTACT } from './GraphQL/Contact';\r\nimport { AddContact, AddContactVariables } from './types/AddContact';\r\n\r\nconst Add = () =\u003e {\r\n  const [name, setName] = React.useState\u003cstring\u003e('');\r\n  const [number, setNumber] = React.useState\u003cstring\u003e('');\r\n  const [email, setEmail] = React.useState\u003cstring\u003e('');\r\n\r\n  const [addContact] = useMutation\u003cAddContact, AddContactVariables\u003e(ADD_CONTACT);\r\n\r\n  const handleSubmit = async () =\u003e {\r\n    await addContact({\r\n      variables: {\r\n        contact: {\r\n          name,\r\n          number,\r\n          email,\r\n        },\r\n      },\r\n    });\r\n  };\r\n\r\n  return (\r\n    \u003c\u003e\r\n      \u003cform action=\"/\" onSubmit={handleSubmit}\u003e\r\n        \u003clabel\u003e\r\n          Name :\r\n          \u003cinput type=\"text\" value={name} onChange={(event) =\u003e setName(event.target.value)} /\u003e\r\n        \u003c/label\u003e\r\n        \u003clabel\u003e\r\n          Number :\r\n          \u003cinput type=\"text\" value={number} onChange={(event) =\u003e setNumber(event.target.value)} /\u003e\r\n        \u003c/label\u003e\r\n        \u003clabel\u003e\r\n          Email :\r\n          \u003cinput type=\"email\" value={email} onChange={(event) =\u003e setEmail(event.target.value)} /\u003e\r\n        \u003c/label\u003e\r\n        \u003cinput type=\"submit\" value=\"Submit\" /\u003e\r\n      \u003c/form\u003e\r\n    \u003c/\u003e\r\n  );\r\n};\r\n\r\nexport default Add;\r\n```\r\n\r\n주소록 내용을 보여주는 `frontend/src/Detail.tsx`도 작성합니다.\r\n\r\n**`frontend/src/Detail.tsx` :**\r\n\r\n```typescript\r\nimport { useQuery } from '@apollo/client';\r\nimport React from 'react';\r\nimport { useParams } from 'react-router';\r\nimport { GET_CONTACT } from './GraphQL/Contact';\r\nimport { GetContact, GetContactVariables } from './types/GetContact';\r\n\r\nconst Detail = () =\u003e {\r\n  const { id } = useParams();\r\n  const { loading, error, data } = useQuery\u003cGetContact, GetContactVariables\u003e(GET_CONTACT, {\r\n    variables: { id: id || '' },\r\n  });\r\n\r\n  if (loading) return \u003cp\u003eLoading...\u003c/p\u003e;\r\n  if (error) return \u003cp\u003e{error.message}\u003c/p\u003e;\r\n\r\n  return (\r\n    \u003c\u003e\r\n      \u003ch1\u003e{data?.getContact?.name}\u003c/h1\u003e\r\n      \u003cul\u003e\r\n        \u003cli\u003eNumber : {data?.getContact?.number || 'N/A'}\u003c/li\u003e\r\n        \u003cli\u003eEmail : {data?.getContact?.email || 'N/A'}\u003c/li\u003e\r\n      \u003c/ul\u003e\r\n    \u003c/\u003e\r\n  );\r\n};\r\n\r\nexport default Detail;\r\n```\r\n\r\n이제 필요한 Component는 모두 만들어졌습니다.\r\n\r\n`frontend/src/index.tsx`를 아래와 같이 작성합니다.  \r\n`index.tsx`에서는 `ApolloClient`와 Router를 설정합니다.\r\n\r\n**`frontend/src/index.tsx` :**\r\n\r\n```typescript\r\nimport { ApolloClient, ApolloProvider, InMemoryCache } from '@apollo/client';\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport { BrowserRouter, Route, Routes } from 'react-router-dom';\r\nimport Detail from './Detail';\r\nimport Add from './Add';\r\nimport List from './List';\r\n\r\nconst client = new ApolloClient({\r\n  uri: 'http://localhost:8081/graphql',\r\n  cache: new InMemoryCache(),\r\n});\r\n\r\nReactDOM.render(\r\n  \u003cApolloProvider client={client}\u003e\r\n    \u003cBrowserRouter\u003e\r\n      \u003cRoutes\u003e\r\n        \u003cRoute path=\"/\" element={\u003cList /\u003e} /\u003e\r\n        \u003cRoute path=\"/add\" element={\u003cAdd /\u003e} /\u003e\r\n        \u003cRoute path=\"detail/:id\" element={\u003cDetail /\u003e} /\u003e\r\n      \u003c/Routes\u003e\r\n    \u003c/BrowserRouter\u003e\r\n  \u003c/ApolloProvider\u003e,\r\n  document.getElementById('root')\r\n);\r\n```\r\n\r\n# 결과물 확인하기\r\n\r\n아래 명령어로 Backend와 Frontend의 Dev Server를 실행합니다.\r\n\r\n```bash\r\nnpm run start:dev --workspace=backend\r\nnpm run dev --workspace=frontend\r\n```\r\n\r\n[http://localhost:8080](http://localhost:8080)에 접속하면 아래와 같은 화면이 출력될 것입니다.  \r\n![List](/assets/image/2021-12-05-NestJS-GraphQL-MySQL-React-Address-Book/2021-12-05-NestJS-GraphQL-MySQL-React-Address-Book_10.png)  \r\nAdd 버튼을 눌러 주소록을 추가해 봅시다.  \r\n![Add](/assets/image/2021-12-05-NestJS-GraphQL-MySQL-React-Address-Book/2021-12-05-NestJS-GraphQL-MySQL-React-Address-Book_11.png)  \r\n추가한 주소록이 목록에 보입니다. 클릭해 봅시다.  \r\n![List Check](/assets/image/2021-12-05-NestJS-GraphQL-MySQL-React-Address-Book/2021-12-05-NestJS-GraphQL-MySQL-React-Address-Book_12.png)  \r\n입력한 정보가 정상적으로 출력되고 있음을 확인할 수 있습니다.  \r\n![Detail](/assets/image/2021-12-05-NestJS-GraphQL-MySQL-React-Address-Book/2021-12-05-NestJS-GraphQL-MySQL-React-Address-Book_13.png)\r\n\r\n\u003e 삭제 기능은 `Detail.tsx`에 추가해 봅시다. `Add.tsx`에 있는 `useMutation()`를 참고하여 구현할 수 있습니다.\r\n\r\n# 마무리\r\n\r\n간편하게 프로젝트 관리를 하기 위해 `address-book`에 있는 `package.json`을 수정해 봅시다.  \r\n우선, 아래 명령어로 `concurrently`와 `rimraf` 패키지를 추가합니다.\r\n\r\n```bash\r\nnpm install --save concurrently rimraf\r\n```\r\n\r\n`package.json`의 `scripts`를 아래와 같이 수정합니다.\r\n\r\n```json\r\n\"scripts\": {\r\n  \"postinstall\": \"rimraf node_modules/apollo-language-server/node_modules/graphql\",\r\n  \"dev\": \"concurrently \\\"npm run start:dev --workspace=backend\\\" \\\"npm run dev --workspace=frontend\\\"\",\r\n  \"build\": \"npm run build --workspace=backend --workspace=frontend\",\r\n  \"apollo:codegen\": \"npm run apollo:codegen --workspace=frontend\"\r\n},\r\n```\r\n\r\n- `postinstall`은 현재(2021년 12월 5일 기준) 발생되는 GraphQL의 문제를 해결하기 위해 넣었습니다.\r\n- `dev`를 위와 같이 설정하면, `address-book`에서 `npm run dev` 명령어 한 번으로 Backend, Frontend의 Dev Server를 동시에 실행할 수 있습니다.\r\n"},"__N_SSG":true},"page":"/article/[category]/[year]/[month]/[day]/[slug]","query":{"category":"nestjs","year":"2021","month":"12","day":"05","slug":"NestJS-GraphQL-MySQL-React-Address-Book"},"buildId":"dFiaKGJXnX9ZfXI4gZrP9","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>